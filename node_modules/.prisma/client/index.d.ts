
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model aplica_b
 * 
 */
export type aplica_b = {
  cedulaEmpleado: string
  fechaHora: Date
  cedulaJuridica: string
  nombreProyecto: string
  nombreBeneficio: string
}

/**
 * Model aplica_do
 * 
 */
export type aplica_do = {
  cedulaEmpleado: string
  fechaHora: Date
  nombreDO: string
}

/**
 * Model aplica_dv
 * 
 */
export type aplica_dv = {
  cedulaEmpleado: string
  fechaHora: Date
  cedulaJuridica: string
  nombreProyecto: string
  nombreDeduccion: string
}

/**
 * Model beneficios
 * 
 */
export type beneficios = {
  cedulaJuridica: string
  nombreProyecto: string
  nombreBeneficio: string
  montoPago: number | null
  descripcion: string | null
  habilitado: boolean | null
}

/**
 * Model credenciales
 * 
 */
export type credenciales = {
  email: string
  contrasenna: string | null
  verificado: boolean | null
}

/**
 * Model deduccionObligatoria
 * 
 */
export type deduccionObligatoria = {
  nombre: string
  porcentaje: number | null
}

/**
 * Model deduccionVoluntaria
 * 
 */
export type deduccionVoluntaria = {
  cedulaJuridica: string
  nombreProyecto: string
  nombreDeduccion: string
  descripcion: string | null
  monto: number | null
  habilitado: boolean | null
}

/**
 * Model empleado
 * 
 */
export type empleado = {
  cedula: string
  cedulaJuridica: string | null
}

/**
 * Model empleador
 * 
 */
export type empleador = {
  cedula: string
}

/**
 * Model empresa
 * 
 */
export type empresa = {
  cedulaJuridica: string
  direccion: string | null
  razonSocial: string | null
  email: string | null
  habilitado: boolean | null
  cedulaEmpleador: string | null
  telefono: string | null
}

/**
 * Model escoge
 * 
 */
export type escoge = {
  cedulaEmpleado: string
  cedulaJuridica: string
  nombreProyecto: string
  nombreDeduccion: string
  aporte: number | null
}

/**
 * Model esContratado
 * 
 */
export type esContratado = {
  cedulaJuridica: string
  nombreProyecto: string
  cedulaEmpleado: string
  tipoEmpleado: string | null
  puesto: string | null
  fechaInicio: Date | null
  fechaFin: Date | null
  jornada: string | null
  salario: number | null
}

/**
 * Model genera
 * 
 */
export type genera = {
  cedulaEmpleado: string
  fechaHora: Date
  cedulaJuridica: string
  nombreProyecto: string
}

/**
 * Model hace_uso
 * 
 */
export type hace_uso = {
  cedula: string
  email: string
}

/**
 * Model pago
 * 
 */
export type pago = {
  cedulaEmpleado: string
  fechaHora: Date
  deduccionesEmpleado: string | null
  deduccionesPatrono: string | null
  salarioBruto: number | null
  beneficios: string | null
  salarioNeto: number | null
  deduccionesVoluntarias: string | null
}

/**
 * Model persona
 * 
 */
export type persona = {
  cedula: string
  nombre: string | null
  telefono: string | null
}

/**
 * Model proyecto
 * 
 */
export type proyecto = {
  cedulaJuridica: string
  nombre: string
  cantidadMaximaBeneficios: number | null
  montoMaximoBeneficio: number | null
  frecuenciaPago: string | null
  moneda: string | null
  fechaInicio: Date | null
  habilitado: boolean | null
  fechaFin: Date | null
  fechaUltimoPago: Date | null
}

/**
 * Model reporteHoras
 * 
 */
export type reporteHoras = {
  cedulaEmpleado: string
  cedulaEmpleador: string | null
  cedulaJuridica: string | null
  nombreProyecto: string | null
  fechaHora: Date
  horasTrabajadas: number | null
  estado: number | null
}

/**
 * Model selecciona
 * 
 */
export type selecciona = {
  cedulaEmpleado: string
  cedulaJuridica: string
  nombreProyecto: string
  nombreBeneficio: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Aplica_bs
 * const aplica_bs = await prisma.aplica_b.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Aplica_bs
   * const aplica_bs = await prisma.aplica_b.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.aplica_b`: Exposes CRUD operations for the **aplica_b** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aplica_bs
    * const aplica_bs = await prisma.aplica_b.findMany()
    * ```
    */
  get aplica_b(): Prisma.aplica_bDelegate<GlobalReject>;

  /**
   * `prisma.aplica_do`: Exposes CRUD operations for the **aplica_do** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aplica_dos
    * const aplica_dos = await prisma.aplica_do.findMany()
    * ```
    */
  get aplica_do(): Prisma.aplica_doDelegate<GlobalReject>;

  /**
   * `prisma.aplica_dv`: Exposes CRUD operations for the **aplica_dv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aplica_dvs
    * const aplica_dvs = await prisma.aplica_dv.findMany()
    * ```
    */
  get aplica_dv(): Prisma.aplica_dvDelegate<GlobalReject>;

  /**
   * `prisma.beneficios`: Exposes CRUD operations for the **beneficios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beneficios
    * const beneficios = await prisma.beneficios.findMany()
    * ```
    */
  get beneficios(): Prisma.beneficiosDelegate<GlobalReject>;

  /**
   * `prisma.credenciales`: Exposes CRUD operations for the **credenciales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credenciales
    * const credenciales = await prisma.credenciales.findMany()
    * ```
    */
  get credenciales(): Prisma.credencialesDelegate<GlobalReject>;

  /**
   * `prisma.deduccionObligatoria`: Exposes CRUD operations for the **deduccionObligatoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeduccionObligatorias
    * const deduccionObligatorias = await prisma.deduccionObligatoria.findMany()
    * ```
    */
  get deduccionObligatoria(): Prisma.deduccionObligatoriaDelegate<GlobalReject>;

  /**
   * `prisma.deduccionVoluntaria`: Exposes CRUD operations for the **deduccionVoluntaria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeduccionVoluntarias
    * const deduccionVoluntarias = await prisma.deduccionVoluntaria.findMany()
    * ```
    */
  get deduccionVoluntaria(): Prisma.deduccionVoluntariaDelegate<GlobalReject>;

  /**
   * `prisma.empleado`: Exposes CRUD operations for the **empleado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleados
    * const empleados = await prisma.empleado.findMany()
    * ```
    */
  get empleado(): Prisma.empleadoDelegate<GlobalReject>;

  /**
   * `prisma.empleador`: Exposes CRUD operations for the **empleador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleadors
    * const empleadors = await prisma.empleador.findMany()
    * ```
    */
  get empleador(): Prisma.empleadorDelegate<GlobalReject>;

  /**
   * `prisma.empresa`: Exposes CRUD operations for the **empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.empresaDelegate<GlobalReject>;

  /**
   * `prisma.escoge`: Exposes CRUD operations for the **escoge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escoges
    * const escoges = await prisma.escoge.findMany()
    * ```
    */
  get escoge(): Prisma.escogeDelegate<GlobalReject>;

  /**
   * `prisma.esContratado`: Exposes CRUD operations for the **esContratado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EsContratados
    * const esContratados = await prisma.esContratado.findMany()
    * ```
    */
  get esContratado(): Prisma.esContratadoDelegate<GlobalReject>;

  /**
   * `prisma.genera`: Exposes CRUD operations for the **genera** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genera
    * const genera = await prisma.genera.findMany()
    * ```
    */
  get genera(): Prisma.generaDelegate<GlobalReject>;

  /**
   * `prisma.hace_uso`: Exposes CRUD operations for the **hace_uso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hace_usos
    * const hace_usos = await prisma.hace_uso.findMany()
    * ```
    */
  get hace_uso(): Prisma.hace_usoDelegate<GlobalReject>;

  /**
   * `prisma.pago`: Exposes CRUD operations for the **pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagos
    * const pagos = await prisma.pago.findMany()
    * ```
    */
  get pago(): Prisma.pagoDelegate<GlobalReject>;

  /**
   * `prisma.persona`: Exposes CRUD operations for the **persona** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personas
    * const personas = await prisma.persona.findMany()
    * ```
    */
  get persona(): Prisma.personaDelegate<GlobalReject>;

  /**
   * `prisma.proyecto`: Exposes CRUD operations for the **proyecto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proyectos
    * const proyectos = await prisma.proyecto.findMany()
    * ```
    */
  get proyecto(): Prisma.proyectoDelegate<GlobalReject>;

  /**
   * `prisma.reporteHoras`: Exposes CRUD operations for the **reporteHoras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReporteHoras
    * const reporteHoras = await prisma.reporteHoras.findMany()
    * ```
    */
  get reporteHoras(): Prisma.reporteHorasDelegate<GlobalReject>;

  /**
   * `prisma.selecciona`: Exposes CRUD operations for the **selecciona** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seleccionas
    * const seleccionas = await prisma.selecciona.findMany()
    * ```
    */
  get selecciona(): Prisma.seleccionaDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.14.0
   * Query Engine version: 2b0c12756921c891fec4f68d9444e18c7d5d4a6a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    aplica_b: 'aplica_b',
    aplica_do: 'aplica_do',
    aplica_dv: 'aplica_dv',
    beneficios: 'beneficios',
    credenciales: 'credenciales',
    deduccionObligatoria: 'deduccionObligatoria',
    deduccionVoluntaria: 'deduccionVoluntaria',
    empleado: 'empleado',
    empleador: 'empleador',
    empresa: 'empresa',
    escoge: 'escoge',
    esContratado: 'esContratado',
    genera: 'genera',
    hace_uso: 'hace_uso',
    pago: 'pago',
    persona: 'persona',
    proyecto: 'proyecto',
    reporteHoras: 'reporteHoras',
    selecciona: 'selecciona'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BeneficiosCountOutputType
   */


  export type BeneficiosCountOutputType = {
    aplica_b: number
    selecciona: number
  }

  export type BeneficiosCountOutputTypeSelect = {
    aplica_b?: boolean
    selecciona?: boolean
  }

  export type BeneficiosCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BeneficiosCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BeneficiosCountOutputType
    : S extends undefined
    ? never
    : S extends BeneficiosCountOutputTypeArgs
    ?'include' extends U
    ? BeneficiosCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BeneficiosCountOutputType ? BeneficiosCountOutputType[P] : never
  } 
    : BeneficiosCountOutputType
  : BeneficiosCountOutputType




  // Custom InputTypes

  /**
   * BeneficiosCountOutputType without action
   */
  export type BeneficiosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BeneficiosCountOutputType
     * 
    **/
    select?: BeneficiosCountOutputTypeSelect | null
  }



  /**
   * Count Type CredencialesCountOutputType
   */


  export type CredencialesCountOutputType = {
    hace_uso: number
  }

  export type CredencialesCountOutputTypeSelect = {
    hace_uso?: boolean
  }

  export type CredencialesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CredencialesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CredencialesCountOutputType
    : S extends undefined
    ? never
    : S extends CredencialesCountOutputTypeArgs
    ?'include' extends U
    ? CredencialesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CredencialesCountOutputType ? CredencialesCountOutputType[P] : never
  } 
    : CredencialesCountOutputType
  : CredencialesCountOutputType




  // Custom InputTypes

  /**
   * CredencialesCountOutputType without action
   */
  export type CredencialesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CredencialesCountOutputType
     * 
    **/
    select?: CredencialesCountOutputTypeSelect | null
  }



  /**
   * Count Type DeduccionObligatoriaCountOutputType
   */


  export type DeduccionObligatoriaCountOutputType = {
    aplica_do: number
  }

  export type DeduccionObligatoriaCountOutputTypeSelect = {
    aplica_do?: boolean
  }

  export type DeduccionObligatoriaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DeduccionObligatoriaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DeduccionObligatoriaCountOutputType
    : S extends undefined
    ? never
    : S extends DeduccionObligatoriaCountOutputTypeArgs
    ?'include' extends U
    ? DeduccionObligatoriaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DeduccionObligatoriaCountOutputType ? DeduccionObligatoriaCountOutputType[P] : never
  } 
    : DeduccionObligatoriaCountOutputType
  : DeduccionObligatoriaCountOutputType




  // Custom InputTypes

  /**
   * DeduccionObligatoriaCountOutputType without action
   */
  export type DeduccionObligatoriaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DeduccionObligatoriaCountOutputType
     * 
    **/
    select?: DeduccionObligatoriaCountOutputTypeSelect | null
  }



  /**
   * Count Type DeduccionVoluntariaCountOutputType
   */


  export type DeduccionVoluntariaCountOutputType = {
    aplica_dv: number
    escoge: number
  }

  export type DeduccionVoluntariaCountOutputTypeSelect = {
    aplica_dv?: boolean
    escoge?: boolean
  }

  export type DeduccionVoluntariaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DeduccionVoluntariaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DeduccionVoluntariaCountOutputType
    : S extends undefined
    ? never
    : S extends DeduccionVoluntariaCountOutputTypeArgs
    ?'include' extends U
    ? DeduccionVoluntariaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DeduccionVoluntariaCountOutputType ? DeduccionVoluntariaCountOutputType[P] : never
  } 
    : DeduccionVoluntariaCountOutputType
  : DeduccionVoluntariaCountOutputType




  // Custom InputTypes

  /**
   * DeduccionVoluntariaCountOutputType without action
   */
  export type DeduccionVoluntariaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DeduccionVoluntariaCountOutputType
     * 
    **/
    select?: DeduccionVoluntariaCountOutputTypeSelect | null
  }



  /**
   * Count Type EmpleadoCountOutputType
   */


  export type EmpleadoCountOutputType = {
    escoge: number
    esContratado: number
    pago: number
    reporteHoras: number
    selecciona: number
  }

  export type EmpleadoCountOutputTypeSelect = {
    escoge?: boolean
    esContratado?: boolean
    pago?: boolean
    reporteHoras?: boolean
    selecciona?: boolean
  }

  export type EmpleadoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EmpleadoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EmpleadoCountOutputType
    : S extends undefined
    ? never
    : S extends EmpleadoCountOutputTypeArgs
    ?'include' extends U
    ? EmpleadoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EmpleadoCountOutputType ? EmpleadoCountOutputType[P] : never
  } 
    : EmpleadoCountOutputType
  : EmpleadoCountOutputType




  // Custom InputTypes

  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EmpleadoCountOutputType
     * 
    **/
    select?: EmpleadoCountOutputTypeSelect | null
  }



  /**
   * Count Type EmpleadorCountOutputType
   */


  export type EmpleadorCountOutputType = {
    empresa: number
    reporteHoras: number
  }

  export type EmpleadorCountOutputTypeSelect = {
    empresa?: boolean
    reporteHoras?: boolean
  }

  export type EmpleadorCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EmpleadorCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EmpleadorCountOutputType
    : S extends undefined
    ? never
    : S extends EmpleadorCountOutputTypeArgs
    ?'include' extends U
    ? EmpleadorCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EmpleadorCountOutputType ? EmpleadorCountOutputType[P] : never
  } 
    : EmpleadorCountOutputType
  : EmpleadorCountOutputType




  // Custom InputTypes

  /**
   * EmpleadorCountOutputType without action
   */
  export type EmpleadorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EmpleadorCountOutputType
     * 
    **/
    select?: EmpleadorCountOutputTypeSelect | null
  }



  /**
   * Count Type EmpresaCountOutputType
   */


  export type EmpresaCountOutputType = {
    empleado: number
    proyecto: number
  }

  export type EmpresaCountOutputTypeSelect = {
    empleado?: boolean
    proyecto?: boolean
  }

  export type EmpresaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EmpresaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EmpresaCountOutputType
    : S extends undefined
    ? never
    : S extends EmpresaCountOutputTypeArgs
    ?'include' extends U
    ? EmpresaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EmpresaCountOutputType ? EmpresaCountOutputType[P] : never
  } 
    : EmpresaCountOutputType
  : EmpresaCountOutputType




  // Custom InputTypes

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EmpresaCountOutputType
     * 
    **/
    select?: EmpresaCountOutputTypeSelect | null
  }



  /**
   * Count Type PagoCountOutputType
   */


  export type PagoCountOutputType = {
    aplica_b: number
    aplica_do: number
    aplica_dv: number
    genera: number
  }

  export type PagoCountOutputTypeSelect = {
    aplica_b?: boolean
    aplica_do?: boolean
    aplica_dv?: boolean
    genera?: boolean
  }

  export type PagoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PagoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PagoCountOutputType
    : S extends undefined
    ? never
    : S extends PagoCountOutputTypeArgs
    ?'include' extends U
    ? PagoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PagoCountOutputType ? PagoCountOutputType[P] : never
  } 
    : PagoCountOutputType
  : PagoCountOutputType




  // Custom InputTypes

  /**
   * PagoCountOutputType without action
   */
  export type PagoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PagoCountOutputType
     * 
    **/
    select?: PagoCountOutputTypeSelect | null
  }



  /**
   * Count Type PersonaCountOutputType
   */


  export type PersonaCountOutputType = {
    hace_uso: number
  }

  export type PersonaCountOutputTypeSelect = {
    hace_uso?: boolean
  }

  export type PersonaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PersonaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PersonaCountOutputType
    : S extends undefined
    ? never
    : S extends PersonaCountOutputTypeArgs
    ?'include' extends U
    ? PersonaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PersonaCountOutputType ? PersonaCountOutputType[P] : never
  } 
    : PersonaCountOutputType
  : PersonaCountOutputType




  // Custom InputTypes

  /**
   * PersonaCountOutputType without action
   */
  export type PersonaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PersonaCountOutputType
     * 
    **/
    select?: PersonaCountOutputTypeSelect | null
  }



  /**
   * Count Type ProyectoCountOutputType
   */


  export type ProyectoCountOutputType = {
    beneficios: number
    deduccionVoluntaria: number
    esContratado: number
    genera: number
    reporteHoras: number
  }

  export type ProyectoCountOutputTypeSelect = {
    beneficios?: boolean
    deduccionVoluntaria?: boolean
    esContratado?: boolean
    genera?: boolean
    reporteHoras?: boolean
  }

  export type ProyectoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProyectoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProyectoCountOutputType
    : S extends undefined
    ? never
    : S extends ProyectoCountOutputTypeArgs
    ?'include' extends U
    ? ProyectoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProyectoCountOutputType ? ProyectoCountOutputType[P] : never
  } 
    : ProyectoCountOutputType
  : ProyectoCountOutputType




  // Custom InputTypes

  /**
   * ProyectoCountOutputType without action
   */
  export type ProyectoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProyectoCountOutputType
     * 
    **/
    select?: ProyectoCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model aplica_b
   */


  export type AggregateAplica_b = {
    _count: Aplica_bCountAggregateOutputType | null
    _min: Aplica_bMinAggregateOutputType | null
    _max: Aplica_bMaxAggregateOutputType | null
  }

  export type Aplica_bMinAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreBeneficio: string | null
  }

  export type Aplica_bMaxAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreBeneficio: string | null
  }

  export type Aplica_bCountAggregateOutputType = {
    cedulaEmpleado: number
    fechaHora: number
    cedulaJuridica: number
    nombreProyecto: number
    nombreBeneficio: number
    _all: number
  }


  export type Aplica_bMinAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreBeneficio?: true
  }

  export type Aplica_bMaxAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreBeneficio?: true
  }

  export type Aplica_bCountAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreBeneficio?: true
    _all?: true
  }

  export type Aplica_bAggregateArgs = {
    /**
     * Filter which aplica_b to aggregate.
     * 
    **/
    where?: aplica_bWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aplica_bs to fetch.
     * 
    **/
    orderBy?: Enumerable<aplica_bOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: aplica_bWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aplica_bs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aplica_bs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aplica_bs
    **/
    _count?: true | Aplica_bCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Aplica_bMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Aplica_bMaxAggregateInputType
  }

  export type GetAplica_bAggregateType<T extends Aplica_bAggregateArgs> = {
        [P in keyof T & keyof AggregateAplica_b]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAplica_b[P]>
      : GetScalarType<T[P], AggregateAplica_b[P]>
  }




  export type Aplica_bGroupByArgs = {
    where?: aplica_bWhereInput
    orderBy?: Enumerable<aplica_bOrderByWithAggregationInput>
    by: Array<Aplica_bScalarFieldEnum>
    having?: aplica_bScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Aplica_bCountAggregateInputType | true
    _min?: Aplica_bMinAggregateInputType
    _max?: Aplica_bMaxAggregateInputType
  }


  export type Aplica_bGroupByOutputType = {
    cedulaEmpleado: string
    fechaHora: Date
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
    _count: Aplica_bCountAggregateOutputType | null
    _min: Aplica_bMinAggregateOutputType | null
    _max: Aplica_bMaxAggregateOutputType | null
  }

  type GetAplica_bGroupByPayload<T extends Aplica_bGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Aplica_bGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Aplica_bGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Aplica_bGroupByOutputType[P]>
            : GetScalarType<T[P], Aplica_bGroupByOutputType[P]>
        }
      >
    >


  export type aplica_bSelect = {
    cedulaEmpleado?: boolean
    fechaHora?: boolean
    cedulaJuridica?: boolean
    nombreProyecto?: boolean
    nombreBeneficio?: boolean
    pago?: boolean | pagoArgs
    beneficios?: boolean | beneficiosArgs
  }

  export type aplica_bInclude = {
    pago?: boolean | pagoArgs
    beneficios?: boolean | beneficiosArgs
  }

  export type aplica_bGetPayload<
    S extends boolean | null | undefined | aplica_bArgs,
    U = keyof S
      > = S extends true
        ? aplica_b
    : S extends undefined
    ? never
    : S extends aplica_bArgs | aplica_bFindManyArgs
    ?'include' extends U
    ? aplica_b  & {
    [P in TrueKeys<S['include']>]:
        P extends 'pago' ? pagoGetPayload<S['include'][P]> :
        P extends 'beneficios' ? beneficiosGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'pago' ? pagoGetPayload<S['select'][P]> :
        P extends 'beneficios' ? beneficiosGetPayload<S['select'][P]> :  P extends keyof aplica_b ? aplica_b[P] : never
  } 
    : aplica_b
  : aplica_b


  type aplica_bCountArgs = Merge<
    Omit<aplica_bFindManyArgs, 'select' | 'include'> & {
      select?: Aplica_bCountAggregateInputType | true
    }
  >

  export interface aplica_bDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Aplica_b that matches the filter.
     * @param {aplica_bFindUniqueArgs} args - Arguments to find a Aplica_b
     * @example
     * // Get one Aplica_b
     * const aplica_b = await prisma.aplica_b.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends aplica_bFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, aplica_bFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'aplica_b'> extends True ? CheckSelect<T, Prisma__aplica_bClient<aplica_b>, Prisma__aplica_bClient<aplica_bGetPayload<T>>> : CheckSelect<T, Prisma__aplica_bClient<aplica_b | null >, Prisma__aplica_bClient<aplica_bGetPayload<T> | null >>

    /**
     * Find the first Aplica_b that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_bFindFirstArgs} args - Arguments to find a Aplica_b
     * @example
     * // Get one Aplica_b
     * const aplica_b = await prisma.aplica_b.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends aplica_bFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, aplica_bFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'aplica_b'> extends True ? CheckSelect<T, Prisma__aplica_bClient<aplica_b>, Prisma__aplica_bClient<aplica_bGetPayload<T>>> : CheckSelect<T, Prisma__aplica_bClient<aplica_b | null >, Prisma__aplica_bClient<aplica_bGetPayload<T> | null >>

    /**
     * Find zero or more Aplica_bs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_bFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aplica_bs
     * const aplica_bs = await prisma.aplica_b.findMany()
     * 
     * // Get first 10 Aplica_bs
     * const aplica_bs = await prisma.aplica_b.findMany({ take: 10 })
     * 
     * // Only select the `cedulaEmpleado`
     * const aplica_bWithCedulaEmpleadoOnly = await prisma.aplica_b.findMany({ select: { cedulaEmpleado: true } })
     * 
    **/
    findMany<T extends aplica_bFindManyArgs>(
      args?: SelectSubset<T, aplica_bFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<aplica_b>>, PrismaPromise<Array<aplica_bGetPayload<T>>>>

    /**
     * Create a Aplica_b.
     * @param {aplica_bCreateArgs} args - Arguments to create a Aplica_b.
     * @example
     * // Create one Aplica_b
     * const Aplica_b = await prisma.aplica_b.create({
     *   data: {
     *     // ... data to create a Aplica_b
     *   }
     * })
     * 
    **/
    create<T extends aplica_bCreateArgs>(
      args: SelectSubset<T, aplica_bCreateArgs>
    ): CheckSelect<T, Prisma__aplica_bClient<aplica_b>, Prisma__aplica_bClient<aplica_bGetPayload<T>>>

    /**
     * Create many Aplica_bs.
     *     @param {aplica_bCreateManyArgs} args - Arguments to create many Aplica_bs.
     *     @example
     *     // Create many Aplica_bs
     *     const aplica_b = await prisma.aplica_b.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends aplica_bCreateManyArgs>(
      args?: SelectSubset<T, aplica_bCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Aplica_b.
     * @param {aplica_bDeleteArgs} args - Arguments to delete one Aplica_b.
     * @example
     * // Delete one Aplica_b
     * const Aplica_b = await prisma.aplica_b.delete({
     *   where: {
     *     // ... filter to delete one Aplica_b
     *   }
     * })
     * 
    **/
    delete<T extends aplica_bDeleteArgs>(
      args: SelectSubset<T, aplica_bDeleteArgs>
    ): CheckSelect<T, Prisma__aplica_bClient<aplica_b>, Prisma__aplica_bClient<aplica_bGetPayload<T>>>

    /**
     * Update one Aplica_b.
     * @param {aplica_bUpdateArgs} args - Arguments to update one Aplica_b.
     * @example
     * // Update one Aplica_b
     * const aplica_b = await prisma.aplica_b.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends aplica_bUpdateArgs>(
      args: SelectSubset<T, aplica_bUpdateArgs>
    ): CheckSelect<T, Prisma__aplica_bClient<aplica_b>, Prisma__aplica_bClient<aplica_bGetPayload<T>>>

    /**
     * Delete zero or more Aplica_bs.
     * @param {aplica_bDeleteManyArgs} args - Arguments to filter Aplica_bs to delete.
     * @example
     * // Delete a few Aplica_bs
     * const { count } = await prisma.aplica_b.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends aplica_bDeleteManyArgs>(
      args?: SelectSubset<T, aplica_bDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aplica_bs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_bUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aplica_bs
     * const aplica_b = await prisma.aplica_b.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends aplica_bUpdateManyArgs>(
      args: SelectSubset<T, aplica_bUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Aplica_b.
     * @param {aplica_bUpsertArgs} args - Arguments to update or create a Aplica_b.
     * @example
     * // Update or create a Aplica_b
     * const aplica_b = await prisma.aplica_b.upsert({
     *   create: {
     *     // ... data to create a Aplica_b
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aplica_b we want to update
     *   }
     * })
    **/
    upsert<T extends aplica_bUpsertArgs>(
      args: SelectSubset<T, aplica_bUpsertArgs>
    ): CheckSelect<T, Prisma__aplica_bClient<aplica_b>, Prisma__aplica_bClient<aplica_bGetPayload<T>>>

    /**
     * Count the number of Aplica_bs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_bCountArgs} args - Arguments to filter Aplica_bs to count.
     * @example
     * // Count the number of Aplica_bs
     * const count = await prisma.aplica_b.count({
     *   where: {
     *     // ... the filter for the Aplica_bs we want to count
     *   }
     * })
    **/
    count<T extends aplica_bCountArgs>(
      args?: Subset<T, aplica_bCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Aplica_bCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aplica_b.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Aplica_bAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Aplica_bAggregateArgs>(args: Subset<T, Aplica_bAggregateArgs>): PrismaPromise<GetAplica_bAggregateType<T>>

    /**
     * Group by Aplica_b.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Aplica_bGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Aplica_bGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Aplica_bGroupByArgs['orderBy'] }
        : { orderBy?: Aplica_bGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Aplica_bGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAplica_bGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for aplica_b.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__aplica_bClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pago<T extends pagoArgs = {}>(args?: Subset<T, pagoArgs>): CheckSelect<T, Prisma__pagoClient<pago | null >, Prisma__pagoClient<pagoGetPayload<T> | null >>;

    beneficios<T extends beneficiosArgs = {}>(args?: Subset<T, beneficiosArgs>): CheckSelect<T, Prisma__beneficiosClient<beneficios | null >, Prisma__beneficiosClient<beneficiosGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * aplica_b findUnique
   */
  export type aplica_bFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the aplica_b
     * 
    **/
    select?: aplica_bSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_bInclude | null
    /**
     * Throw an Error if a aplica_b can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which aplica_b to fetch.
     * 
    **/
    where: aplica_bWhereUniqueInput
  }


  /**
   * aplica_b findFirst
   */
  export type aplica_bFindFirstArgs = {
    /**
     * Select specific fields to fetch from the aplica_b
     * 
    **/
    select?: aplica_bSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_bInclude | null
    /**
     * Throw an Error if a aplica_b can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which aplica_b to fetch.
     * 
    **/
    where?: aplica_bWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aplica_bs to fetch.
     * 
    **/
    orderBy?: Enumerable<aplica_bOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aplica_bs.
     * 
    **/
    cursor?: aplica_bWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aplica_bs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aplica_bs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aplica_bs.
     * 
    **/
    distinct?: Enumerable<Aplica_bScalarFieldEnum>
  }


  /**
   * aplica_b findMany
   */
  export type aplica_bFindManyArgs = {
    /**
     * Select specific fields to fetch from the aplica_b
     * 
    **/
    select?: aplica_bSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_bInclude | null
    /**
     * Filter, which aplica_bs to fetch.
     * 
    **/
    where?: aplica_bWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aplica_bs to fetch.
     * 
    **/
    orderBy?: Enumerable<aplica_bOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aplica_bs.
     * 
    **/
    cursor?: aplica_bWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aplica_bs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aplica_bs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Aplica_bScalarFieldEnum>
  }


  /**
   * aplica_b create
   */
  export type aplica_bCreateArgs = {
    /**
     * Select specific fields to fetch from the aplica_b
     * 
    **/
    select?: aplica_bSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_bInclude | null
    /**
     * The data needed to create a aplica_b.
     * 
    **/
    data: XOR<aplica_bCreateInput, aplica_bUncheckedCreateInput>
  }


  /**
   * aplica_b createMany
   */
  export type aplica_bCreateManyArgs = {
    /**
     * The data used to create many aplica_bs.
     * 
    **/
    data: Enumerable<aplica_bCreateManyInput>
  }


  /**
   * aplica_b update
   */
  export type aplica_bUpdateArgs = {
    /**
     * Select specific fields to fetch from the aplica_b
     * 
    **/
    select?: aplica_bSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_bInclude | null
    /**
     * The data needed to update a aplica_b.
     * 
    **/
    data: XOR<aplica_bUpdateInput, aplica_bUncheckedUpdateInput>
    /**
     * Choose, which aplica_b to update.
     * 
    **/
    where: aplica_bWhereUniqueInput
  }


  /**
   * aplica_b updateMany
   */
  export type aplica_bUpdateManyArgs = {
    /**
     * The data used to update aplica_bs.
     * 
    **/
    data: XOR<aplica_bUpdateManyMutationInput, aplica_bUncheckedUpdateManyInput>
    /**
     * Filter which aplica_bs to update
     * 
    **/
    where?: aplica_bWhereInput
  }


  /**
   * aplica_b upsert
   */
  export type aplica_bUpsertArgs = {
    /**
     * Select specific fields to fetch from the aplica_b
     * 
    **/
    select?: aplica_bSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_bInclude | null
    /**
     * The filter to search for the aplica_b to update in case it exists.
     * 
    **/
    where: aplica_bWhereUniqueInput
    /**
     * In case the aplica_b found by the `where` argument doesn't exist, create a new aplica_b with this data.
     * 
    **/
    create: XOR<aplica_bCreateInput, aplica_bUncheckedCreateInput>
    /**
     * In case the aplica_b was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<aplica_bUpdateInput, aplica_bUncheckedUpdateInput>
  }


  /**
   * aplica_b delete
   */
  export type aplica_bDeleteArgs = {
    /**
     * Select specific fields to fetch from the aplica_b
     * 
    **/
    select?: aplica_bSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_bInclude | null
    /**
     * Filter which aplica_b to delete.
     * 
    **/
    where: aplica_bWhereUniqueInput
  }


  /**
   * aplica_b deleteMany
   */
  export type aplica_bDeleteManyArgs = {
    /**
     * Filter which aplica_bs to delete
     * 
    **/
    where?: aplica_bWhereInput
  }


  /**
   * aplica_b without action
   */
  export type aplica_bArgs = {
    /**
     * Select specific fields to fetch from the aplica_b
     * 
    **/
    select?: aplica_bSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_bInclude | null
  }



  /**
   * Model aplica_do
   */


  export type AggregateAplica_do = {
    _count: Aplica_doCountAggregateOutputType | null
    _min: Aplica_doMinAggregateOutputType | null
    _max: Aplica_doMaxAggregateOutputType | null
  }

  export type Aplica_doMinAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    nombreDO: string | null
  }

  export type Aplica_doMaxAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    nombreDO: string | null
  }

  export type Aplica_doCountAggregateOutputType = {
    cedulaEmpleado: number
    fechaHora: number
    nombreDO: number
    _all: number
  }


  export type Aplica_doMinAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    nombreDO?: true
  }

  export type Aplica_doMaxAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    nombreDO?: true
  }

  export type Aplica_doCountAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    nombreDO?: true
    _all?: true
  }

  export type Aplica_doAggregateArgs = {
    /**
     * Filter which aplica_do to aggregate.
     * 
    **/
    where?: aplica_doWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aplica_dos to fetch.
     * 
    **/
    orderBy?: Enumerable<aplica_doOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: aplica_doWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aplica_dos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aplica_dos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aplica_dos
    **/
    _count?: true | Aplica_doCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Aplica_doMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Aplica_doMaxAggregateInputType
  }

  export type GetAplica_doAggregateType<T extends Aplica_doAggregateArgs> = {
        [P in keyof T & keyof AggregateAplica_do]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAplica_do[P]>
      : GetScalarType<T[P], AggregateAplica_do[P]>
  }




  export type Aplica_doGroupByArgs = {
    where?: aplica_doWhereInput
    orderBy?: Enumerable<aplica_doOrderByWithAggregationInput>
    by: Array<Aplica_doScalarFieldEnum>
    having?: aplica_doScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Aplica_doCountAggregateInputType | true
    _min?: Aplica_doMinAggregateInputType
    _max?: Aplica_doMaxAggregateInputType
  }


  export type Aplica_doGroupByOutputType = {
    cedulaEmpleado: string
    fechaHora: Date
    nombreDO: string
    _count: Aplica_doCountAggregateOutputType | null
    _min: Aplica_doMinAggregateOutputType | null
    _max: Aplica_doMaxAggregateOutputType | null
  }

  type GetAplica_doGroupByPayload<T extends Aplica_doGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Aplica_doGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Aplica_doGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Aplica_doGroupByOutputType[P]>
            : GetScalarType<T[P], Aplica_doGroupByOutputType[P]>
        }
      >
    >


  export type aplica_doSelect = {
    cedulaEmpleado?: boolean
    fechaHora?: boolean
    nombreDO?: boolean
    pago?: boolean | pagoArgs
    deduccionObligatoria?: boolean | deduccionObligatoriaArgs
  }

  export type aplica_doInclude = {
    pago?: boolean | pagoArgs
    deduccionObligatoria?: boolean | deduccionObligatoriaArgs
  }

  export type aplica_doGetPayload<
    S extends boolean | null | undefined | aplica_doArgs,
    U = keyof S
      > = S extends true
        ? aplica_do
    : S extends undefined
    ? never
    : S extends aplica_doArgs | aplica_doFindManyArgs
    ?'include' extends U
    ? aplica_do  & {
    [P in TrueKeys<S['include']>]:
        P extends 'pago' ? pagoGetPayload<S['include'][P]> :
        P extends 'deduccionObligatoria' ? deduccionObligatoriaGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'pago' ? pagoGetPayload<S['select'][P]> :
        P extends 'deduccionObligatoria' ? deduccionObligatoriaGetPayload<S['select'][P]> :  P extends keyof aplica_do ? aplica_do[P] : never
  } 
    : aplica_do
  : aplica_do


  type aplica_doCountArgs = Merge<
    Omit<aplica_doFindManyArgs, 'select' | 'include'> & {
      select?: Aplica_doCountAggregateInputType | true
    }
  >

  export interface aplica_doDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Aplica_do that matches the filter.
     * @param {aplica_doFindUniqueArgs} args - Arguments to find a Aplica_do
     * @example
     * // Get one Aplica_do
     * const aplica_do = await prisma.aplica_do.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends aplica_doFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, aplica_doFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'aplica_do'> extends True ? CheckSelect<T, Prisma__aplica_doClient<aplica_do>, Prisma__aplica_doClient<aplica_doGetPayload<T>>> : CheckSelect<T, Prisma__aplica_doClient<aplica_do | null >, Prisma__aplica_doClient<aplica_doGetPayload<T> | null >>

    /**
     * Find the first Aplica_do that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_doFindFirstArgs} args - Arguments to find a Aplica_do
     * @example
     * // Get one Aplica_do
     * const aplica_do = await prisma.aplica_do.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends aplica_doFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, aplica_doFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'aplica_do'> extends True ? CheckSelect<T, Prisma__aplica_doClient<aplica_do>, Prisma__aplica_doClient<aplica_doGetPayload<T>>> : CheckSelect<T, Prisma__aplica_doClient<aplica_do | null >, Prisma__aplica_doClient<aplica_doGetPayload<T> | null >>

    /**
     * Find zero or more Aplica_dos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_doFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aplica_dos
     * const aplica_dos = await prisma.aplica_do.findMany()
     * 
     * // Get first 10 Aplica_dos
     * const aplica_dos = await prisma.aplica_do.findMany({ take: 10 })
     * 
     * // Only select the `cedulaEmpleado`
     * const aplica_doWithCedulaEmpleadoOnly = await prisma.aplica_do.findMany({ select: { cedulaEmpleado: true } })
     * 
    **/
    findMany<T extends aplica_doFindManyArgs>(
      args?: SelectSubset<T, aplica_doFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<aplica_do>>, PrismaPromise<Array<aplica_doGetPayload<T>>>>

    /**
     * Create a Aplica_do.
     * @param {aplica_doCreateArgs} args - Arguments to create a Aplica_do.
     * @example
     * // Create one Aplica_do
     * const Aplica_do = await prisma.aplica_do.create({
     *   data: {
     *     // ... data to create a Aplica_do
     *   }
     * })
     * 
    **/
    create<T extends aplica_doCreateArgs>(
      args: SelectSubset<T, aplica_doCreateArgs>
    ): CheckSelect<T, Prisma__aplica_doClient<aplica_do>, Prisma__aplica_doClient<aplica_doGetPayload<T>>>

    /**
     * Create many Aplica_dos.
     *     @param {aplica_doCreateManyArgs} args - Arguments to create many Aplica_dos.
     *     @example
     *     // Create many Aplica_dos
     *     const aplica_do = await prisma.aplica_do.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends aplica_doCreateManyArgs>(
      args?: SelectSubset<T, aplica_doCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Aplica_do.
     * @param {aplica_doDeleteArgs} args - Arguments to delete one Aplica_do.
     * @example
     * // Delete one Aplica_do
     * const Aplica_do = await prisma.aplica_do.delete({
     *   where: {
     *     // ... filter to delete one Aplica_do
     *   }
     * })
     * 
    **/
    delete<T extends aplica_doDeleteArgs>(
      args: SelectSubset<T, aplica_doDeleteArgs>
    ): CheckSelect<T, Prisma__aplica_doClient<aplica_do>, Prisma__aplica_doClient<aplica_doGetPayload<T>>>

    /**
     * Update one Aplica_do.
     * @param {aplica_doUpdateArgs} args - Arguments to update one Aplica_do.
     * @example
     * // Update one Aplica_do
     * const aplica_do = await prisma.aplica_do.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends aplica_doUpdateArgs>(
      args: SelectSubset<T, aplica_doUpdateArgs>
    ): CheckSelect<T, Prisma__aplica_doClient<aplica_do>, Prisma__aplica_doClient<aplica_doGetPayload<T>>>

    /**
     * Delete zero or more Aplica_dos.
     * @param {aplica_doDeleteManyArgs} args - Arguments to filter Aplica_dos to delete.
     * @example
     * // Delete a few Aplica_dos
     * const { count } = await prisma.aplica_do.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends aplica_doDeleteManyArgs>(
      args?: SelectSubset<T, aplica_doDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aplica_dos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_doUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aplica_dos
     * const aplica_do = await prisma.aplica_do.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends aplica_doUpdateManyArgs>(
      args: SelectSubset<T, aplica_doUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Aplica_do.
     * @param {aplica_doUpsertArgs} args - Arguments to update or create a Aplica_do.
     * @example
     * // Update or create a Aplica_do
     * const aplica_do = await prisma.aplica_do.upsert({
     *   create: {
     *     // ... data to create a Aplica_do
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aplica_do we want to update
     *   }
     * })
    **/
    upsert<T extends aplica_doUpsertArgs>(
      args: SelectSubset<T, aplica_doUpsertArgs>
    ): CheckSelect<T, Prisma__aplica_doClient<aplica_do>, Prisma__aplica_doClient<aplica_doGetPayload<T>>>

    /**
     * Count the number of Aplica_dos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_doCountArgs} args - Arguments to filter Aplica_dos to count.
     * @example
     * // Count the number of Aplica_dos
     * const count = await prisma.aplica_do.count({
     *   where: {
     *     // ... the filter for the Aplica_dos we want to count
     *   }
     * })
    **/
    count<T extends aplica_doCountArgs>(
      args?: Subset<T, aplica_doCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Aplica_doCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aplica_do.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Aplica_doAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Aplica_doAggregateArgs>(args: Subset<T, Aplica_doAggregateArgs>): PrismaPromise<GetAplica_doAggregateType<T>>

    /**
     * Group by Aplica_do.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Aplica_doGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Aplica_doGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Aplica_doGroupByArgs['orderBy'] }
        : { orderBy?: Aplica_doGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Aplica_doGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAplica_doGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for aplica_do.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__aplica_doClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pago<T extends pagoArgs = {}>(args?: Subset<T, pagoArgs>): CheckSelect<T, Prisma__pagoClient<pago | null >, Prisma__pagoClient<pagoGetPayload<T> | null >>;

    deduccionObligatoria<T extends deduccionObligatoriaArgs = {}>(args?: Subset<T, deduccionObligatoriaArgs>): CheckSelect<T, Prisma__deduccionObligatoriaClient<deduccionObligatoria | null >, Prisma__deduccionObligatoriaClient<deduccionObligatoriaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * aplica_do findUnique
   */
  export type aplica_doFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the aplica_do
     * 
    **/
    select?: aplica_doSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_doInclude | null
    /**
     * Throw an Error if a aplica_do can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which aplica_do to fetch.
     * 
    **/
    where: aplica_doWhereUniqueInput
  }


  /**
   * aplica_do findFirst
   */
  export type aplica_doFindFirstArgs = {
    /**
     * Select specific fields to fetch from the aplica_do
     * 
    **/
    select?: aplica_doSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_doInclude | null
    /**
     * Throw an Error if a aplica_do can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which aplica_do to fetch.
     * 
    **/
    where?: aplica_doWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aplica_dos to fetch.
     * 
    **/
    orderBy?: Enumerable<aplica_doOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aplica_dos.
     * 
    **/
    cursor?: aplica_doWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aplica_dos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aplica_dos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aplica_dos.
     * 
    **/
    distinct?: Enumerable<Aplica_doScalarFieldEnum>
  }


  /**
   * aplica_do findMany
   */
  export type aplica_doFindManyArgs = {
    /**
     * Select specific fields to fetch from the aplica_do
     * 
    **/
    select?: aplica_doSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_doInclude | null
    /**
     * Filter, which aplica_dos to fetch.
     * 
    **/
    where?: aplica_doWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aplica_dos to fetch.
     * 
    **/
    orderBy?: Enumerable<aplica_doOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aplica_dos.
     * 
    **/
    cursor?: aplica_doWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aplica_dos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aplica_dos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Aplica_doScalarFieldEnum>
  }


  /**
   * aplica_do create
   */
  export type aplica_doCreateArgs = {
    /**
     * Select specific fields to fetch from the aplica_do
     * 
    **/
    select?: aplica_doSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_doInclude | null
    /**
     * The data needed to create a aplica_do.
     * 
    **/
    data: XOR<aplica_doCreateInput, aplica_doUncheckedCreateInput>
  }


  /**
   * aplica_do createMany
   */
  export type aplica_doCreateManyArgs = {
    /**
     * The data used to create many aplica_dos.
     * 
    **/
    data: Enumerable<aplica_doCreateManyInput>
  }


  /**
   * aplica_do update
   */
  export type aplica_doUpdateArgs = {
    /**
     * Select specific fields to fetch from the aplica_do
     * 
    **/
    select?: aplica_doSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_doInclude | null
    /**
     * The data needed to update a aplica_do.
     * 
    **/
    data: XOR<aplica_doUpdateInput, aplica_doUncheckedUpdateInput>
    /**
     * Choose, which aplica_do to update.
     * 
    **/
    where: aplica_doWhereUniqueInput
  }


  /**
   * aplica_do updateMany
   */
  export type aplica_doUpdateManyArgs = {
    /**
     * The data used to update aplica_dos.
     * 
    **/
    data: XOR<aplica_doUpdateManyMutationInput, aplica_doUncheckedUpdateManyInput>
    /**
     * Filter which aplica_dos to update
     * 
    **/
    where?: aplica_doWhereInput
  }


  /**
   * aplica_do upsert
   */
  export type aplica_doUpsertArgs = {
    /**
     * Select specific fields to fetch from the aplica_do
     * 
    **/
    select?: aplica_doSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_doInclude | null
    /**
     * The filter to search for the aplica_do to update in case it exists.
     * 
    **/
    where: aplica_doWhereUniqueInput
    /**
     * In case the aplica_do found by the `where` argument doesn't exist, create a new aplica_do with this data.
     * 
    **/
    create: XOR<aplica_doCreateInput, aplica_doUncheckedCreateInput>
    /**
     * In case the aplica_do was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<aplica_doUpdateInput, aplica_doUncheckedUpdateInput>
  }


  /**
   * aplica_do delete
   */
  export type aplica_doDeleteArgs = {
    /**
     * Select specific fields to fetch from the aplica_do
     * 
    **/
    select?: aplica_doSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_doInclude | null
    /**
     * Filter which aplica_do to delete.
     * 
    **/
    where: aplica_doWhereUniqueInput
  }


  /**
   * aplica_do deleteMany
   */
  export type aplica_doDeleteManyArgs = {
    /**
     * Filter which aplica_dos to delete
     * 
    **/
    where?: aplica_doWhereInput
  }


  /**
   * aplica_do without action
   */
  export type aplica_doArgs = {
    /**
     * Select specific fields to fetch from the aplica_do
     * 
    **/
    select?: aplica_doSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_doInclude | null
  }



  /**
   * Model aplica_dv
   */


  export type AggregateAplica_dv = {
    _count: Aplica_dvCountAggregateOutputType | null
    _min: Aplica_dvMinAggregateOutputType | null
    _max: Aplica_dvMaxAggregateOutputType | null
  }

  export type Aplica_dvMinAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreDeduccion: string | null
  }

  export type Aplica_dvMaxAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreDeduccion: string | null
  }

  export type Aplica_dvCountAggregateOutputType = {
    cedulaEmpleado: number
    fechaHora: number
    cedulaJuridica: number
    nombreProyecto: number
    nombreDeduccion: number
    _all: number
  }


  export type Aplica_dvMinAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreDeduccion?: true
  }

  export type Aplica_dvMaxAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreDeduccion?: true
  }

  export type Aplica_dvCountAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreDeduccion?: true
    _all?: true
  }

  export type Aplica_dvAggregateArgs = {
    /**
     * Filter which aplica_dv to aggregate.
     * 
    **/
    where?: aplica_dvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aplica_dvs to fetch.
     * 
    **/
    orderBy?: Enumerable<aplica_dvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: aplica_dvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aplica_dvs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aplica_dvs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aplica_dvs
    **/
    _count?: true | Aplica_dvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Aplica_dvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Aplica_dvMaxAggregateInputType
  }

  export type GetAplica_dvAggregateType<T extends Aplica_dvAggregateArgs> = {
        [P in keyof T & keyof AggregateAplica_dv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAplica_dv[P]>
      : GetScalarType<T[P], AggregateAplica_dv[P]>
  }




  export type Aplica_dvGroupByArgs = {
    where?: aplica_dvWhereInput
    orderBy?: Enumerable<aplica_dvOrderByWithAggregationInput>
    by: Array<Aplica_dvScalarFieldEnum>
    having?: aplica_dvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Aplica_dvCountAggregateInputType | true
    _min?: Aplica_dvMinAggregateInputType
    _max?: Aplica_dvMaxAggregateInputType
  }


  export type Aplica_dvGroupByOutputType = {
    cedulaEmpleado: string
    fechaHora: Date
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    _count: Aplica_dvCountAggregateOutputType | null
    _min: Aplica_dvMinAggregateOutputType | null
    _max: Aplica_dvMaxAggregateOutputType | null
  }

  type GetAplica_dvGroupByPayload<T extends Aplica_dvGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Aplica_dvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Aplica_dvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Aplica_dvGroupByOutputType[P]>
            : GetScalarType<T[P], Aplica_dvGroupByOutputType[P]>
        }
      >
    >


  export type aplica_dvSelect = {
    cedulaEmpleado?: boolean
    fechaHora?: boolean
    cedulaJuridica?: boolean
    nombreProyecto?: boolean
    nombreDeduccion?: boolean
    pago?: boolean | pagoArgs
    deduccionVoluntaria?: boolean | deduccionVoluntariaArgs
  }

  export type aplica_dvInclude = {
    pago?: boolean | pagoArgs
    deduccionVoluntaria?: boolean | deduccionVoluntariaArgs
  }

  export type aplica_dvGetPayload<
    S extends boolean | null | undefined | aplica_dvArgs,
    U = keyof S
      > = S extends true
        ? aplica_dv
    : S extends undefined
    ? never
    : S extends aplica_dvArgs | aplica_dvFindManyArgs
    ?'include' extends U
    ? aplica_dv  & {
    [P in TrueKeys<S['include']>]:
        P extends 'pago' ? pagoGetPayload<S['include'][P]> :
        P extends 'deduccionVoluntaria' ? deduccionVoluntariaGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'pago' ? pagoGetPayload<S['select'][P]> :
        P extends 'deduccionVoluntaria' ? deduccionVoluntariaGetPayload<S['select'][P]> :  P extends keyof aplica_dv ? aplica_dv[P] : never
  } 
    : aplica_dv
  : aplica_dv


  type aplica_dvCountArgs = Merge<
    Omit<aplica_dvFindManyArgs, 'select' | 'include'> & {
      select?: Aplica_dvCountAggregateInputType | true
    }
  >

  export interface aplica_dvDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Aplica_dv that matches the filter.
     * @param {aplica_dvFindUniqueArgs} args - Arguments to find a Aplica_dv
     * @example
     * // Get one Aplica_dv
     * const aplica_dv = await prisma.aplica_dv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends aplica_dvFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, aplica_dvFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'aplica_dv'> extends True ? CheckSelect<T, Prisma__aplica_dvClient<aplica_dv>, Prisma__aplica_dvClient<aplica_dvGetPayload<T>>> : CheckSelect<T, Prisma__aplica_dvClient<aplica_dv | null >, Prisma__aplica_dvClient<aplica_dvGetPayload<T> | null >>

    /**
     * Find the first Aplica_dv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_dvFindFirstArgs} args - Arguments to find a Aplica_dv
     * @example
     * // Get one Aplica_dv
     * const aplica_dv = await prisma.aplica_dv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends aplica_dvFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, aplica_dvFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'aplica_dv'> extends True ? CheckSelect<T, Prisma__aplica_dvClient<aplica_dv>, Prisma__aplica_dvClient<aplica_dvGetPayload<T>>> : CheckSelect<T, Prisma__aplica_dvClient<aplica_dv | null >, Prisma__aplica_dvClient<aplica_dvGetPayload<T> | null >>

    /**
     * Find zero or more Aplica_dvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_dvFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aplica_dvs
     * const aplica_dvs = await prisma.aplica_dv.findMany()
     * 
     * // Get first 10 Aplica_dvs
     * const aplica_dvs = await prisma.aplica_dv.findMany({ take: 10 })
     * 
     * // Only select the `cedulaEmpleado`
     * const aplica_dvWithCedulaEmpleadoOnly = await prisma.aplica_dv.findMany({ select: { cedulaEmpleado: true } })
     * 
    **/
    findMany<T extends aplica_dvFindManyArgs>(
      args?: SelectSubset<T, aplica_dvFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<aplica_dv>>, PrismaPromise<Array<aplica_dvGetPayload<T>>>>

    /**
     * Create a Aplica_dv.
     * @param {aplica_dvCreateArgs} args - Arguments to create a Aplica_dv.
     * @example
     * // Create one Aplica_dv
     * const Aplica_dv = await prisma.aplica_dv.create({
     *   data: {
     *     // ... data to create a Aplica_dv
     *   }
     * })
     * 
    **/
    create<T extends aplica_dvCreateArgs>(
      args: SelectSubset<T, aplica_dvCreateArgs>
    ): CheckSelect<T, Prisma__aplica_dvClient<aplica_dv>, Prisma__aplica_dvClient<aplica_dvGetPayload<T>>>

    /**
     * Create many Aplica_dvs.
     *     @param {aplica_dvCreateManyArgs} args - Arguments to create many Aplica_dvs.
     *     @example
     *     // Create many Aplica_dvs
     *     const aplica_dv = await prisma.aplica_dv.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends aplica_dvCreateManyArgs>(
      args?: SelectSubset<T, aplica_dvCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Aplica_dv.
     * @param {aplica_dvDeleteArgs} args - Arguments to delete one Aplica_dv.
     * @example
     * // Delete one Aplica_dv
     * const Aplica_dv = await prisma.aplica_dv.delete({
     *   where: {
     *     // ... filter to delete one Aplica_dv
     *   }
     * })
     * 
    **/
    delete<T extends aplica_dvDeleteArgs>(
      args: SelectSubset<T, aplica_dvDeleteArgs>
    ): CheckSelect<T, Prisma__aplica_dvClient<aplica_dv>, Prisma__aplica_dvClient<aplica_dvGetPayload<T>>>

    /**
     * Update one Aplica_dv.
     * @param {aplica_dvUpdateArgs} args - Arguments to update one Aplica_dv.
     * @example
     * // Update one Aplica_dv
     * const aplica_dv = await prisma.aplica_dv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends aplica_dvUpdateArgs>(
      args: SelectSubset<T, aplica_dvUpdateArgs>
    ): CheckSelect<T, Prisma__aplica_dvClient<aplica_dv>, Prisma__aplica_dvClient<aplica_dvGetPayload<T>>>

    /**
     * Delete zero or more Aplica_dvs.
     * @param {aplica_dvDeleteManyArgs} args - Arguments to filter Aplica_dvs to delete.
     * @example
     * // Delete a few Aplica_dvs
     * const { count } = await prisma.aplica_dv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends aplica_dvDeleteManyArgs>(
      args?: SelectSubset<T, aplica_dvDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aplica_dvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_dvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aplica_dvs
     * const aplica_dv = await prisma.aplica_dv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends aplica_dvUpdateManyArgs>(
      args: SelectSubset<T, aplica_dvUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Aplica_dv.
     * @param {aplica_dvUpsertArgs} args - Arguments to update or create a Aplica_dv.
     * @example
     * // Update or create a Aplica_dv
     * const aplica_dv = await prisma.aplica_dv.upsert({
     *   create: {
     *     // ... data to create a Aplica_dv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aplica_dv we want to update
     *   }
     * })
    **/
    upsert<T extends aplica_dvUpsertArgs>(
      args: SelectSubset<T, aplica_dvUpsertArgs>
    ): CheckSelect<T, Prisma__aplica_dvClient<aplica_dv>, Prisma__aplica_dvClient<aplica_dvGetPayload<T>>>

    /**
     * Count the number of Aplica_dvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aplica_dvCountArgs} args - Arguments to filter Aplica_dvs to count.
     * @example
     * // Count the number of Aplica_dvs
     * const count = await prisma.aplica_dv.count({
     *   where: {
     *     // ... the filter for the Aplica_dvs we want to count
     *   }
     * })
    **/
    count<T extends aplica_dvCountArgs>(
      args?: Subset<T, aplica_dvCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Aplica_dvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aplica_dv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Aplica_dvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Aplica_dvAggregateArgs>(args: Subset<T, Aplica_dvAggregateArgs>): PrismaPromise<GetAplica_dvAggregateType<T>>

    /**
     * Group by Aplica_dv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Aplica_dvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Aplica_dvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Aplica_dvGroupByArgs['orderBy'] }
        : { orderBy?: Aplica_dvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Aplica_dvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAplica_dvGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for aplica_dv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__aplica_dvClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pago<T extends pagoArgs = {}>(args?: Subset<T, pagoArgs>): CheckSelect<T, Prisma__pagoClient<pago | null >, Prisma__pagoClient<pagoGetPayload<T> | null >>;

    deduccionVoluntaria<T extends deduccionVoluntariaArgs = {}>(args?: Subset<T, deduccionVoluntariaArgs>): CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria | null >, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * aplica_dv findUnique
   */
  export type aplica_dvFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the aplica_dv
     * 
    **/
    select?: aplica_dvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_dvInclude | null
    /**
     * Throw an Error if a aplica_dv can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which aplica_dv to fetch.
     * 
    **/
    where: aplica_dvWhereUniqueInput
  }


  /**
   * aplica_dv findFirst
   */
  export type aplica_dvFindFirstArgs = {
    /**
     * Select specific fields to fetch from the aplica_dv
     * 
    **/
    select?: aplica_dvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_dvInclude | null
    /**
     * Throw an Error if a aplica_dv can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which aplica_dv to fetch.
     * 
    **/
    where?: aplica_dvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aplica_dvs to fetch.
     * 
    **/
    orderBy?: Enumerable<aplica_dvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aplica_dvs.
     * 
    **/
    cursor?: aplica_dvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aplica_dvs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aplica_dvs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aplica_dvs.
     * 
    **/
    distinct?: Enumerable<Aplica_dvScalarFieldEnum>
  }


  /**
   * aplica_dv findMany
   */
  export type aplica_dvFindManyArgs = {
    /**
     * Select specific fields to fetch from the aplica_dv
     * 
    **/
    select?: aplica_dvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_dvInclude | null
    /**
     * Filter, which aplica_dvs to fetch.
     * 
    **/
    where?: aplica_dvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aplica_dvs to fetch.
     * 
    **/
    orderBy?: Enumerable<aplica_dvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aplica_dvs.
     * 
    **/
    cursor?: aplica_dvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aplica_dvs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aplica_dvs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Aplica_dvScalarFieldEnum>
  }


  /**
   * aplica_dv create
   */
  export type aplica_dvCreateArgs = {
    /**
     * Select specific fields to fetch from the aplica_dv
     * 
    **/
    select?: aplica_dvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_dvInclude | null
    /**
     * The data needed to create a aplica_dv.
     * 
    **/
    data: XOR<aplica_dvCreateInput, aplica_dvUncheckedCreateInput>
  }


  /**
   * aplica_dv createMany
   */
  export type aplica_dvCreateManyArgs = {
    /**
     * The data used to create many aplica_dvs.
     * 
    **/
    data: Enumerable<aplica_dvCreateManyInput>
  }


  /**
   * aplica_dv update
   */
  export type aplica_dvUpdateArgs = {
    /**
     * Select specific fields to fetch from the aplica_dv
     * 
    **/
    select?: aplica_dvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_dvInclude | null
    /**
     * The data needed to update a aplica_dv.
     * 
    **/
    data: XOR<aplica_dvUpdateInput, aplica_dvUncheckedUpdateInput>
    /**
     * Choose, which aplica_dv to update.
     * 
    **/
    where: aplica_dvWhereUniqueInput
  }


  /**
   * aplica_dv updateMany
   */
  export type aplica_dvUpdateManyArgs = {
    /**
     * The data used to update aplica_dvs.
     * 
    **/
    data: XOR<aplica_dvUpdateManyMutationInput, aplica_dvUncheckedUpdateManyInput>
    /**
     * Filter which aplica_dvs to update
     * 
    **/
    where?: aplica_dvWhereInput
  }


  /**
   * aplica_dv upsert
   */
  export type aplica_dvUpsertArgs = {
    /**
     * Select specific fields to fetch from the aplica_dv
     * 
    **/
    select?: aplica_dvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_dvInclude | null
    /**
     * The filter to search for the aplica_dv to update in case it exists.
     * 
    **/
    where: aplica_dvWhereUniqueInput
    /**
     * In case the aplica_dv found by the `where` argument doesn't exist, create a new aplica_dv with this data.
     * 
    **/
    create: XOR<aplica_dvCreateInput, aplica_dvUncheckedCreateInput>
    /**
     * In case the aplica_dv was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<aplica_dvUpdateInput, aplica_dvUncheckedUpdateInput>
  }


  /**
   * aplica_dv delete
   */
  export type aplica_dvDeleteArgs = {
    /**
     * Select specific fields to fetch from the aplica_dv
     * 
    **/
    select?: aplica_dvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_dvInclude | null
    /**
     * Filter which aplica_dv to delete.
     * 
    **/
    where: aplica_dvWhereUniqueInput
  }


  /**
   * aplica_dv deleteMany
   */
  export type aplica_dvDeleteManyArgs = {
    /**
     * Filter which aplica_dvs to delete
     * 
    **/
    where?: aplica_dvWhereInput
  }


  /**
   * aplica_dv without action
   */
  export type aplica_dvArgs = {
    /**
     * Select specific fields to fetch from the aplica_dv
     * 
    **/
    select?: aplica_dvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: aplica_dvInclude | null
  }



  /**
   * Model beneficios
   */


  export type AggregateBeneficios = {
    _count: BeneficiosCountAggregateOutputType | null
    _avg: BeneficiosAvgAggregateOutputType | null
    _sum: BeneficiosSumAggregateOutputType | null
    _min: BeneficiosMinAggregateOutputType | null
    _max: BeneficiosMaxAggregateOutputType | null
  }

  export type BeneficiosAvgAggregateOutputType = {
    montoPago: number | null
  }

  export type BeneficiosSumAggregateOutputType = {
    montoPago: number | null
  }

  export type BeneficiosMinAggregateOutputType = {
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreBeneficio: string | null
    montoPago: number | null
    descripcion: string | null
    habilitado: boolean | null
  }

  export type BeneficiosMaxAggregateOutputType = {
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreBeneficio: string | null
    montoPago: number | null
    descripcion: string | null
    habilitado: boolean | null
  }

  export type BeneficiosCountAggregateOutputType = {
    cedulaJuridica: number
    nombreProyecto: number
    nombreBeneficio: number
    montoPago: number
    descripcion: number
    habilitado: number
    _all: number
  }


  export type BeneficiosAvgAggregateInputType = {
    montoPago?: true
  }

  export type BeneficiosSumAggregateInputType = {
    montoPago?: true
  }

  export type BeneficiosMinAggregateInputType = {
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreBeneficio?: true
    montoPago?: true
    descripcion?: true
    habilitado?: true
  }

  export type BeneficiosMaxAggregateInputType = {
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreBeneficio?: true
    montoPago?: true
    descripcion?: true
    habilitado?: true
  }

  export type BeneficiosCountAggregateInputType = {
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreBeneficio?: true
    montoPago?: true
    descripcion?: true
    habilitado?: true
    _all?: true
  }

  export type BeneficiosAggregateArgs = {
    /**
     * Filter which beneficios to aggregate.
     * 
    **/
    where?: beneficiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficios to fetch.
     * 
    **/
    orderBy?: Enumerable<beneficiosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: beneficiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned beneficios
    **/
    _count?: true | BeneficiosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BeneficiosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BeneficiosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeneficiosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeneficiosMaxAggregateInputType
  }

  export type GetBeneficiosAggregateType<T extends BeneficiosAggregateArgs> = {
        [P in keyof T & keyof AggregateBeneficios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeneficios[P]>
      : GetScalarType<T[P], AggregateBeneficios[P]>
  }




  export type BeneficiosGroupByArgs = {
    where?: beneficiosWhereInput
    orderBy?: Enumerable<beneficiosOrderByWithAggregationInput>
    by: Array<BeneficiosScalarFieldEnum>
    having?: beneficiosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeneficiosCountAggregateInputType | true
    _avg?: BeneficiosAvgAggregateInputType
    _sum?: BeneficiosSumAggregateInputType
    _min?: BeneficiosMinAggregateInputType
    _max?: BeneficiosMaxAggregateInputType
  }


  export type BeneficiosGroupByOutputType = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
    montoPago: number | null
    descripcion: string | null
    habilitado: boolean | null
    _count: BeneficiosCountAggregateOutputType | null
    _avg: BeneficiosAvgAggregateOutputType | null
    _sum: BeneficiosSumAggregateOutputType | null
    _min: BeneficiosMinAggregateOutputType | null
    _max: BeneficiosMaxAggregateOutputType | null
  }

  type GetBeneficiosGroupByPayload<T extends BeneficiosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BeneficiosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeneficiosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeneficiosGroupByOutputType[P]>
            : GetScalarType<T[P], BeneficiosGroupByOutputType[P]>
        }
      >
    >


  export type beneficiosSelect = {
    cedulaJuridica?: boolean
    nombreProyecto?: boolean
    nombreBeneficio?: boolean
    montoPago?: boolean
    descripcion?: boolean
    habilitado?: boolean
    proyecto?: boolean | proyectoArgs
    aplica_b?: boolean | aplica_bFindManyArgs
    selecciona?: boolean | seleccionaFindManyArgs
    _count?: boolean | BeneficiosCountOutputTypeArgs
  }

  export type beneficiosInclude = {
    proyecto?: boolean | proyectoArgs
    aplica_b?: boolean | aplica_bFindManyArgs
    selecciona?: boolean | seleccionaFindManyArgs
    _count?: boolean | BeneficiosCountOutputTypeArgs
  }

  export type beneficiosGetPayload<
    S extends boolean | null | undefined | beneficiosArgs,
    U = keyof S
      > = S extends true
        ? beneficios
    : S extends undefined
    ? never
    : S extends beneficiosArgs | beneficiosFindManyArgs
    ?'include' extends U
    ? beneficios  & {
    [P in TrueKeys<S['include']>]:
        P extends 'proyecto' ? proyectoGetPayload<S['include'][P]> :
        P extends 'aplica_b' ? Array < aplica_bGetPayload<S['include'][P]>>  :
        P extends 'selecciona' ? Array < seleccionaGetPayload<S['include'][P]>>  :
        P extends '_count' ? BeneficiosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'proyecto' ? proyectoGetPayload<S['select'][P]> :
        P extends 'aplica_b' ? Array < aplica_bGetPayload<S['select'][P]>>  :
        P extends 'selecciona' ? Array < seleccionaGetPayload<S['select'][P]>>  :
        P extends '_count' ? BeneficiosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof beneficios ? beneficios[P] : never
  } 
    : beneficios
  : beneficios


  type beneficiosCountArgs = Merge<
    Omit<beneficiosFindManyArgs, 'select' | 'include'> & {
      select?: BeneficiosCountAggregateInputType | true
    }
  >

  export interface beneficiosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Beneficios that matches the filter.
     * @param {beneficiosFindUniqueArgs} args - Arguments to find a Beneficios
     * @example
     * // Get one Beneficios
     * const beneficios = await prisma.beneficios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends beneficiosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, beneficiosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'beneficios'> extends True ? CheckSelect<T, Prisma__beneficiosClient<beneficios>, Prisma__beneficiosClient<beneficiosGetPayload<T>>> : CheckSelect<T, Prisma__beneficiosClient<beneficios | null >, Prisma__beneficiosClient<beneficiosGetPayload<T> | null >>

    /**
     * Find the first Beneficios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosFindFirstArgs} args - Arguments to find a Beneficios
     * @example
     * // Get one Beneficios
     * const beneficios = await prisma.beneficios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends beneficiosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, beneficiosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'beneficios'> extends True ? CheckSelect<T, Prisma__beneficiosClient<beneficios>, Prisma__beneficiosClient<beneficiosGetPayload<T>>> : CheckSelect<T, Prisma__beneficiosClient<beneficios | null >, Prisma__beneficiosClient<beneficiosGetPayload<T> | null >>

    /**
     * Find zero or more Beneficios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beneficios
     * const beneficios = await prisma.beneficios.findMany()
     * 
     * // Get first 10 Beneficios
     * const beneficios = await prisma.beneficios.findMany({ take: 10 })
     * 
     * // Only select the `cedulaJuridica`
     * const beneficiosWithCedulaJuridicaOnly = await prisma.beneficios.findMany({ select: { cedulaJuridica: true } })
     * 
    **/
    findMany<T extends beneficiosFindManyArgs>(
      args?: SelectSubset<T, beneficiosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<beneficios>>, PrismaPromise<Array<beneficiosGetPayload<T>>>>

    /**
     * Create a Beneficios.
     * @param {beneficiosCreateArgs} args - Arguments to create a Beneficios.
     * @example
     * // Create one Beneficios
     * const Beneficios = await prisma.beneficios.create({
     *   data: {
     *     // ... data to create a Beneficios
     *   }
     * })
     * 
    **/
    create<T extends beneficiosCreateArgs>(
      args: SelectSubset<T, beneficiosCreateArgs>
    ): CheckSelect<T, Prisma__beneficiosClient<beneficios>, Prisma__beneficiosClient<beneficiosGetPayload<T>>>

    /**
     * Create many Beneficios.
     *     @param {beneficiosCreateManyArgs} args - Arguments to create many Beneficios.
     *     @example
     *     // Create many Beneficios
     *     const beneficios = await prisma.beneficios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends beneficiosCreateManyArgs>(
      args?: SelectSubset<T, beneficiosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Beneficios.
     * @param {beneficiosDeleteArgs} args - Arguments to delete one Beneficios.
     * @example
     * // Delete one Beneficios
     * const Beneficios = await prisma.beneficios.delete({
     *   where: {
     *     // ... filter to delete one Beneficios
     *   }
     * })
     * 
    **/
    delete<T extends beneficiosDeleteArgs>(
      args: SelectSubset<T, beneficiosDeleteArgs>
    ): CheckSelect<T, Prisma__beneficiosClient<beneficios>, Prisma__beneficiosClient<beneficiosGetPayload<T>>>

    /**
     * Update one Beneficios.
     * @param {beneficiosUpdateArgs} args - Arguments to update one Beneficios.
     * @example
     * // Update one Beneficios
     * const beneficios = await prisma.beneficios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends beneficiosUpdateArgs>(
      args: SelectSubset<T, beneficiosUpdateArgs>
    ): CheckSelect<T, Prisma__beneficiosClient<beneficios>, Prisma__beneficiosClient<beneficiosGetPayload<T>>>

    /**
     * Delete zero or more Beneficios.
     * @param {beneficiosDeleteManyArgs} args - Arguments to filter Beneficios to delete.
     * @example
     * // Delete a few Beneficios
     * const { count } = await prisma.beneficios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends beneficiosDeleteManyArgs>(
      args?: SelectSubset<T, beneficiosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beneficios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beneficios
     * const beneficios = await prisma.beneficios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends beneficiosUpdateManyArgs>(
      args: SelectSubset<T, beneficiosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Beneficios.
     * @param {beneficiosUpsertArgs} args - Arguments to update or create a Beneficios.
     * @example
     * // Update or create a Beneficios
     * const beneficios = await prisma.beneficios.upsert({
     *   create: {
     *     // ... data to create a Beneficios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Beneficios we want to update
     *   }
     * })
    **/
    upsert<T extends beneficiosUpsertArgs>(
      args: SelectSubset<T, beneficiosUpsertArgs>
    ): CheckSelect<T, Prisma__beneficiosClient<beneficios>, Prisma__beneficiosClient<beneficiosGetPayload<T>>>

    /**
     * Count the number of Beneficios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCountArgs} args - Arguments to filter Beneficios to count.
     * @example
     * // Count the number of Beneficios
     * const count = await prisma.beneficios.count({
     *   where: {
     *     // ... the filter for the Beneficios we want to count
     *   }
     * })
    **/
    count<T extends beneficiosCountArgs>(
      args?: Subset<T, beneficiosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeneficiosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Beneficios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeneficiosAggregateArgs>(args: Subset<T, BeneficiosAggregateArgs>): PrismaPromise<GetBeneficiosAggregateType<T>>

    /**
     * Group by Beneficios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BeneficiosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BeneficiosGroupByArgs['orderBy'] }
        : { orderBy?: BeneficiosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BeneficiosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeneficiosGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for beneficios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__beneficiosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    proyecto<T extends proyectoArgs = {}>(args?: Subset<T, proyectoArgs>): CheckSelect<T, Prisma__proyectoClient<proyecto | null >, Prisma__proyectoClient<proyectoGetPayload<T> | null >>;

    aplica_b<T extends aplica_bFindManyArgs = {}>(args?: Subset<T, aplica_bFindManyArgs>): CheckSelect<T, PrismaPromise<Array<aplica_b>>, PrismaPromise<Array<aplica_bGetPayload<T>>>>;

    selecciona<T extends seleccionaFindManyArgs = {}>(args?: Subset<T, seleccionaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<selecciona>>, PrismaPromise<Array<seleccionaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * beneficios findUnique
   */
  export type beneficiosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the beneficios
     * 
    **/
    select?: beneficiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: beneficiosInclude | null
    /**
     * Throw an Error if a beneficios can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which beneficios to fetch.
     * 
    **/
    where: beneficiosWhereUniqueInput
  }


  /**
   * beneficios findFirst
   */
  export type beneficiosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the beneficios
     * 
    **/
    select?: beneficiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: beneficiosInclude | null
    /**
     * Throw an Error if a beneficios can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which beneficios to fetch.
     * 
    **/
    where?: beneficiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficios to fetch.
     * 
    **/
    orderBy?: Enumerable<beneficiosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beneficios.
     * 
    **/
    cursor?: beneficiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beneficios.
     * 
    **/
    distinct?: Enumerable<BeneficiosScalarFieldEnum>
  }


  /**
   * beneficios findMany
   */
  export type beneficiosFindManyArgs = {
    /**
     * Select specific fields to fetch from the beneficios
     * 
    **/
    select?: beneficiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: beneficiosInclude | null
    /**
     * Filter, which beneficios to fetch.
     * 
    **/
    where?: beneficiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficios to fetch.
     * 
    **/
    orderBy?: Enumerable<beneficiosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing beneficios.
     * 
    **/
    cursor?: beneficiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BeneficiosScalarFieldEnum>
  }


  /**
   * beneficios create
   */
  export type beneficiosCreateArgs = {
    /**
     * Select specific fields to fetch from the beneficios
     * 
    **/
    select?: beneficiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: beneficiosInclude | null
    /**
     * The data needed to create a beneficios.
     * 
    **/
    data: XOR<beneficiosCreateInput, beneficiosUncheckedCreateInput>
  }


  /**
   * beneficios createMany
   */
  export type beneficiosCreateManyArgs = {
    /**
     * The data used to create many beneficios.
     * 
    **/
    data: Enumerable<beneficiosCreateManyInput>
  }


  /**
   * beneficios update
   */
  export type beneficiosUpdateArgs = {
    /**
     * Select specific fields to fetch from the beneficios
     * 
    **/
    select?: beneficiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: beneficiosInclude | null
    /**
     * The data needed to update a beneficios.
     * 
    **/
    data: XOR<beneficiosUpdateInput, beneficiosUncheckedUpdateInput>
    /**
     * Choose, which beneficios to update.
     * 
    **/
    where: beneficiosWhereUniqueInput
  }


  /**
   * beneficios updateMany
   */
  export type beneficiosUpdateManyArgs = {
    /**
     * The data used to update beneficios.
     * 
    **/
    data: XOR<beneficiosUpdateManyMutationInput, beneficiosUncheckedUpdateManyInput>
    /**
     * Filter which beneficios to update
     * 
    **/
    where?: beneficiosWhereInput
  }


  /**
   * beneficios upsert
   */
  export type beneficiosUpsertArgs = {
    /**
     * Select specific fields to fetch from the beneficios
     * 
    **/
    select?: beneficiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: beneficiosInclude | null
    /**
     * The filter to search for the beneficios to update in case it exists.
     * 
    **/
    where: beneficiosWhereUniqueInput
    /**
     * In case the beneficios found by the `where` argument doesn't exist, create a new beneficios with this data.
     * 
    **/
    create: XOR<beneficiosCreateInput, beneficiosUncheckedCreateInput>
    /**
     * In case the beneficios was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<beneficiosUpdateInput, beneficiosUncheckedUpdateInput>
  }


  /**
   * beneficios delete
   */
  export type beneficiosDeleteArgs = {
    /**
     * Select specific fields to fetch from the beneficios
     * 
    **/
    select?: beneficiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: beneficiosInclude | null
    /**
     * Filter which beneficios to delete.
     * 
    **/
    where: beneficiosWhereUniqueInput
  }


  /**
   * beneficios deleteMany
   */
  export type beneficiosDeleteManyArgs = {
    /**
     * Filter which beneficios to delete
     * 
    **/
    where?: beneficiosWhereInput
  }


  /**
   * beneficios without action
   */
  export type beneficiosArgs = {
    /**
     * Select specific fields to fetch from the beneficios
     * 
    **/
    select?: beneficiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: beneficiosInclude | null
  }



  /**
   * Model credenciales
   */


  export type AggregateCredenciales = {
    _count: CredencialesCountAggregateOutputType | null
    _min: CredencialesMinAggregateOutputType | null
    _max: CredencialesMaxAggregateOutputType | null
  }

  export type CredencialesMinAggregateOutputType = {
    email: string | null
    contrasenna: string | null
    verificado: boolean | null
  }

  export type CredencialesMaxAggregateOutputType = {
    email: string | null
    contrasenna: string | null
    verificado: boolean | null
  }

  export type CredencialesCountAggregateOutputType = {
    email: number
    contrasenna: number
    verificado: number
    _all: number
  }


  export type CredencialesMinAggregateInputType = {
    email?: true
    contrasenna?: true
    verificado?: true
  }

  export type CredencialesMaxAggregateInputType = {
    email?: true
    contrasenna?: true
    verificado?: true
  }

  export type CredencialesCountAggregateInputType = {
    email?: true
    contrasenna?: true
    verificado?: true
    _all?: true
  }

  export type CredencialesAggregateArgs = {
    /**
     * Filter which credenciales to aggregate.
     * 
    **/
    where?: credencialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credenciales to fetch.
     * 
    **/
    orderBy?: Enumerable<credencialesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: credencialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credenciales from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credenciales.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credenciales
    **/
    _count?: true | CredencialesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredencialesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredencialesMaxAggregateInputType
  }

  export type GetCredencialesAggregateType<T extends CredencialesAggregateArgs> = {
        [P in keyof T & keyof AggregateCredenciales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredenciales[P]>
      : GetScalarType<T[P], AggregateCredenciales[P]>
  }




  export type CredencialesGroupByArgs = {
    where?: credencialesWhereInput
    orderBy?: Enumerable<credencialesOrderByWithAggregationInput>
    by: Array<CredencialesScalarFieldEnum>
    having?: credencialesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredencialesCountAggregateInputType | true
    _min?: CredencialesMinAggregateInputType
    _max?: CredencialesMaxAggregateInputType
  }


  export type CredencialesGroupByOutputType = {
    email: string
    contrasenna: string | null
    verificado: boolean | null
    _count: CredencialesCountAggregateOutputType | null
    _min: CredencialesMinAggregateOutputType | null
    _max: CredencialesMaxAggregateOutputType | null
  }

  type GetCredencialesGroupByPayload<T extends CredencialesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CredencialesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredencialesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredencialesGroupByOutputType[P]>
            : GetScalarType<T[P], CredencialesGroupByOutputType[P]>
        }
      >
    >


  export type credencialesSelect = {
    email?: boolean
    contrasenna?: boolean
    verificado?: boolean
    hace_uso?: boolean | hace_usoFindManyArgs
    _count?: boolean | CredencialesCountOutputTypeArgs
  }

  export type credencialesInclude = {
    hace_uso?: boolean | hace_usoFindManyArgs
    _count?: boolean | CredencialesCountOutputTypeArgs
  }

  export type credencialesGetPayload<
    S extends boolean | null | undefined | credencialesArgs,
    U = keyof S
      > = S extends true
        ? credenciales
    : S extends undefined
    ? never
    : S extends credencialesArgs | credencialesFindManyArgs
    ?'include' extends U
    ? credenciales  & {
    [P in TrueKeys<S['include']>]:
        P extends 'hace_uso' ? Array < hace_usoGetPayload<S['include'][P]>>  :
        P extends '_count' ? CredencialesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'hace_uso' ? Array < hace_usoGetPayload<S['select'][P]>>  :
        P extends '_count' ? CredencialesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof credenciales ? credenciales[P] : never
  } 
    : credenciales
  : credenciales


  type credencialesCountArgs = Merge<
    Omit<credencialesFindManyArgs, 'select' | 'include'> & {
      select?: CredencialesCountAggregateInputType | true
    }
  >

  export interface credencialesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Credenciales that matches the filter.
     * @param {credencialesFindUniqueArgs} args - Arguments to find a Credenciales
     * @example
     * // Get one Credenciales
     * const credenciales = await prisma.credenciales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends credencialesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, credencialesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'credenciales'> extends True ? CheckSelect<T, Prisma__credencialesClient<credenciales>, Prisma__credencialesClient<credencialesGetPayload<T>>> : CheckSelect<T, Prisma__credencialesClient<credenciales | null >, Prisma__credencialesClient<credencialesGetPayload<T> | null >>

    /**
     * Find the first Credenciales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credencialesFindFirstArgs} args - Arguments to find a Credenciales
     * @example
     * // Get one Credenciales
     * const credenciales = await prisma.credenciales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends credencialesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, credencialesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'credenciales'> extends True ? CheckSelect<T, Prisma__credencialesClient<credenciales>, Prisma__credencialesClient<credencialesGetPayload<T>>> : CheckSelect<T, Prisma__credencialesClient<credenciales | null >, Prisma__credencialesClient<credencialesGetPayload<T> | null >>

    /**
     * Find zero or more Credenciales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credencialesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credenciales
     * const credenciales = await prisma.credenciales.findMany()
     * 
     * // Get first 10 Credenciales
     * const credenciales = await prisma.credenciales.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const credencialesWithEmailOnly = await prisma.credenciales.findMany({ select: { email: true } })
     * 
    **/
    findMany<T extends credencialesFindManyArgs>(
      args?: SelectSubset<T, credencialesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<credenciales>>, PrismaPromise<Array<credencialesGetPayload<T>>>>

    /**
     * Create a Credenciales.
     * @param {credencialesCreateArgs} args - Arguments to create a Credenciales.
     * @example
     * // Create one Credenciales
     * const Credenciales = await prisma.credenciales.create({
     *   data: {
     *     // ... data to create a Credenciales
     *   }
     * })
     * 
    **/
    create<T extends credencialesCreateArgs>(
      args: SelectSubset<T, credencialesCreateArgs>
    ): CheckSelect<T, Prisma__credencialesClient<credenciales>, Prisma__credencialesClient<credencialesGetPayload<T>>>

    /**
     * Create many Credenciales.
     *     @param {credencialesCreateManyArgs} args - Arguments to create many Credenciales.
     *     @example
     *     // Create many Credenciales
     *     const credenciales = await prisma.credenciales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends credencialesCreateManyArgs>(
      args?: SelectSubset<T, credencialesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Credenciales.
     * @param {credencialesDeleteArgs} args - Arguments to delete one Credenciales.
     * @example
     * // Delete one Credenciales
     * const Credenciales = await prisma.credenciales.delete({
     *   where: {
     *     // ... filter to delete one Credenciales
     *   }
     * })
     * 
    **/
    delete<T extends credencialesDeleteArgs>(
      args: SelectSubset<T, credencialesDeleteArgs>
    ): CheckSelect<T, Prisma__credencialesClient<credenciales>, Prisma__credencialesClient<credencialesGetPayload<T>>>

    /**
     * Update one Credenciales.
     * @param {credencialesUpdateArgs} args - Arguments to update one Credenciales.
     * @example
     * // Update one Credenciales
     * const credenciales = await prisma.credenciales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends credencialesUpdateArgs>(
      args: SelectSubset<T, credencialesUpdateArgs>
    ): CheckSelect<T, Prisma__credencialesClient<credenciales>, Prisma__credencialesClient<credencialesGetPayload<T>>>

    /**
     * Delete zero or more Credenciales.
     * @param {credencialesDeleteManyArgs} args - Arguments to filter Credenciales to delete.
     * @example
     * // Delete a few Credenciales
     * const { count } = await prisma.credenciales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends credencialesDeleteManyArgs>(
      args?: SelectSubset<T, credencialesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credenciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credencialesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credenciales
     * const credenciales = await prisma.credenciales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends credencialesUpdateManyArgs>(
      args: SelectSubset<T, credencialesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Credenciales.
     * @param {credencialesUpsertArgs} args - Arguments to update or create a Credenciales.
     * @example
     * // Update or create a Credenciales
     * const credenciales = await prisma.credenciales.upsert({
     *   create: {
     *     // ... data to create a Credenciales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credenciales we want to update
     *   }
     * })
    **/
    upsert<T extends credencialesUpsertArgs>(
      args: SelectSubset<T, credencialesUpsertArgs>
    ): CheckSelect<T, Prisma__credencialesClient<credenciales>, Prisma__credencialesClient<credencialesGetPayload<T>>>

    /**
     * Count the number of Credenciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credencialesCountArgs} args - Arguments to filter Credenciales to count.
     * @example
     * // Count the number of Credenciales
     * const count = await prisma.credenciales.count({
     *   where: {
     *     // ... the filter for the Credenciales we want to count
     *   }
     * })
    **/
    count<T extends credencialesCountArgs>(
      args?: Subset<T, credencialesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredencialesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credenciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredencialesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredencialesAggregateArgs>(args: Subset<T, CredencialesAggregateArgs>): PrismaPromise<GetCredencialesAggregateType<T>>

    /**
     * Group by Credenciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredencialesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredencialesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredencialesGroupByArgs['orderBy'] }
        : { orderBy?: CredencialesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredencialesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredencialesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for credenciales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__credencialesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    hace_uso<T extends hace_usoFindManyArgs = {}>(args?: Subset<T, hace_usoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<hace_uso>>, PrismaPromise<Array<hace_usoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * credenciales findUnique
   */
  export type credencialesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     * 
    **/
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: credencialesInclude | null
    /**
     * Throw an Error if a credenciales can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which credenciales to fetch.
     * 
    **/
    where: credencialesWhereUniqueInput
  }


  /**
   * credenciales findFirst
   */
  export type credencialesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     * 
    **/
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: credencialesInclude | null
    /**
     * Throw an Error if a credenciales can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which credenciales to fetch.
     * 
    **/
    where?: credencialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credenciales to fetch.
     * 
    **/
    orderBy?: Enumerable<credencialesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credenciales.
     * 
    **/
    cursor?: credencialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credenciales from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credenciales.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credenciales.
     * 
    **/
    distinct?: Enumerable<CredencialesScalarFieldEnum>
  }


  /**
   * credenciales findMany
   */
  export type credencialesFindManyArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     * 
    **/
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: credencialesInclude | null
    /**
     * Filter, which credenciales to fetch.
     * 
    **/
    where?: credencialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credenciales to fetch.
     * 
    **/
    orderBy?: Enumerable<credencialesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credenciales.
     * 
    **/
    cursor?: credencialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credenciales from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credenciales.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CredencialesScalarFieldEnum>
  }


  /**
   * credenciales create
   */
  export type credencialesCreateArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     * 
    **/
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: credencialesInclude | null
    /**
     * The data needed to create a credenciales.
     * 
    **/
    data: XOR<credencialesCreateInput, credencialesUncheckedCreateInput>
  }


  /**
   * credenciales createMany
   */
  export type credencialesCreateManyArgs = {
    /**
     * The data used to create many credenciales.
     * 
    **/
    data: Enumerable<credencialesCreateManyInput>
  }


  /**
   * credenciales update
   */
  export type credencialesUpdateArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     * 
    **/
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: credencialesInclude | null
    /**
     * The data needed to update a credenciales.
     * 
    **/
    data: XOR<credencialesUpdateInput, credencialesUncheckedUpdateInput>
    /**
     * Choose, which credenciales to update.
     * 
    **/
    where: credencialesWhereUniqueInput
  }


  /**
   * credenciales updateMany
   */
  export type credencialesUpdateManyArgs = {
    /**
     * The data used to update credenciales.
     * 
    **/
    data: XOR<credencialesUpdateManyMutationInput, credencialesUncheckedUpdateManyInput>
    /**
     * Filter which credenciales to update
     * 
    **/
    where?: credencialesWhereInput
  }


  /**
   * credenciales upsert
   */
  export type credencialesUpsertArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     * 
    **/
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: credencialesInclude | null
    /**
     * The filter to search for the credenciales to update in case it exists.
     * 
    **/
    where: credencialesWhereUniqueInput
    /**
     * In case the credenciales found by the `where` argument doesn't exist, create a new credenciales with this data.
     * 
    **/
    create: XOR<credencialesCreateInput, credencialesUncheckedCreateInput>
    /**
     * In case the credenciales was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<credencialesUpdateInput, credencialesUncheckedUpdateInput>
  }


  /**
   * credenciales delete
   */
  export type credencialesDeleteArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     * 
    **/
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: credencialesInclude | null
    /**
     * Filter which credenciales to delete.
     * 
    **/
    where: credencialesWhereUniqueInput
  }


  /**
   * credenciales deleteMany
   */
  export type credencialesDeleteManyArgs = {
    /**
     * Filter which credenciales to delete
     * 
    **/
    where?: credencialesWhereInput
  }


  /**
   * credenciales without action
   */
  export type credencialesArgs = {
    /**
     * Select specific fields to fetch from the credenciales
     * 
    **/
    select?: credencialesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: credencialesInclude | null
  }



  /**
   * Model deduccionObligatoria
   */


  export type AggregateDeduccionObligatoria = {
    _count: DeduccionObligatoriaCountAggregateOutputType | null
    _avg: DeduccionObligatoriaAvgAggregateOutputType | null
    _sum: DeduccionObligatoriaSumAggregateOutputType | null
    _min: DeduccionObligatoriaMinAggregateOutputType | null
    _max: DeduccionObligatoriaMaxAggregateOutputType | null
  }

  export type DeduccionObligatoriaAvgAggregateOutputType = {
    porcentaje: number | null
  }

  export type DeduccionObligatoriaSumAggregateOutputType = {
    porcentaje: number | null
  }

  export type DeduccionObligatoriaMinAggregateOutputType = {
    nombre: string | null
    porcentaje: number | null
  }

  export type DeduccionObligatoriaMaxAggregateOutputType = {
    nombre: string | null
    porcentaje: number | null
  }

  export type DeduccionObligatoriaCountAggregateOutputType = {
    nombre: number
    porcentaje: number
    _all: number
  }


  export type DeduccionObligatoriaAvgAggregateInputType = {
    porcentaje?: true
  }

  export type DeduccionObligatoriaSumAggregateInputType = {
    porcentaje?: true
  }

  export type DeduccionObligatoriaMinAggregateInputType = {
    nombre?: true
    porcentaje?: true
  }

  export type DeduccionObligatoriaMaxAggregateInputType = {
    nombre?: true
    porcentaje?: true
  }

  export type DeduccionObligatoriaCountAggregateInputType = {
    nombre?: true
    porcentaje?: true
    _all?: true
  }

  export type DeduccionObligatoriaAggregateArgs = {
    /**
     * Filter which deduccionObligatoria to aggregate.
     * 
    **/
    where?: deduccionObligatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deduccionObligatorias to fetch.
     * 
    **/
    orderBy?: Enumerable<deduccionObligatoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: deduccionObligatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deduccionObligatorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deduccionObligatorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deduccionObligatorias
    **/
    _count?: true | DeduccionObligatoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeduccionObligatoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeduccionObligatoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeduccionObligatoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeduccionObligatoriaMaxAggregateInputType
  }

  export type GetDeduccionObligatoriaAggregateType<T extends DeduccionObligatoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateDeduccionObligatoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeduccionObligatoria[P]>
      : GetScalarType<T[P], AggregateDeduccionObligatoria[P]>
  }




  export type DeduccionObligatoriaGroupByArgs = {
    where?: deduccionObligatoriaWhereInput
    orderBy?: Enumerable<deduccionObligatoriaOrderByWithAggregationInput>
    by: Array<DeduccionObligatoriaScalarFieldEnum>
    having?: deduccionObligatoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeduccionObligatoriaCountAggregateInputType | true
    _avg?: DeduccionObligatoriaAvgAggregateInputType
    _sum?: DeduccionObligatoriaSumAggregateInputType
    _min?: DeduccionObligatoriaMinAggregateInputType
    _max?: DeduccionObligatoriaMaxAggregateInputType
  }


  export type DeduccionObligatoriaGroupByOutputType = {
    nombre: string
    porcentaje: number | null
    _count: DeduccionObligatoriaCountAggregateOutputType | null
    _avg: DeduccionObligatoriaAvgAggregateOutputType | null
    _sum: DeduccionObligatoriaSumAggregateOutputType | null
    _min: DeduccionObligatoriaMinAggregateOutputType | null
    _max: DeduccionObligatoriaMaxAggregateOutputType | null
  }

  type GetDeduccionObligatoriaGroupByPayload<T extends DeduccionObligatoriaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeduccionObligatoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeduccionObligatoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeduccionObligatoriaGroupByOutputType[P]>
            : GetScalarType<T[P], DeduccionObligatoriaGroupByOutputType[P]>
        }
      >
    >


  export type deduccionObligatoriaSelect = {
    nombre?: boolean
    porcentaje?: boolean
    aplica_do?: boolean | aplica_doFindManyArgs
    _count?: boolean | DeduccionObligatoriaCountOutputTypeArgs
  }

  export type deduccionObligatoriaInclude = {
    aplica_do?: boolean | aplica_doFindManyArgs
    _count?: boolean | DeduccionObligatoriaCountOutputTypeArgs
  }

  export type deduccionObligatoriaGetPayload<
    S extends boolean | null | undefined | deduccionObligatoriaArgs,
    U = keyof S
      > = S extends true
        ? deduccionObligatoria
    : S extends undefined
    ? never
    : S extends deduccionObligatoriaArgs | deduccionObligatoriaFindManyArgs
    ?'include' extends U
    ? deduccionObligatoria  & {
    [P in TrueKeys<S['include']>]:
        P extends 'aplica_do' ? Array < aplica_doGetPayload<S['include'][P]>>  :
        P extends '_count' ? DeduccionObligatoriaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'aplica_do' ? Array < aplica_doGetPayload<S['select'][P]>>  :
        P extends '_count' ? DeduccionObligatoriaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof deduccionObligatoria ? deduccionObligatoria[P] : never
  } 
    : deduccionObligatoria
  : deduccionObligatoria


  type deduccionObligatoriaCountArgs = Merge<
    Omit<deduccionObligatoriaFindManyArgs, 'select' | 'include'> & {
      select?: DeduccionObligatoriaCountAggregateInputType | true
    }
  >

  export interface deduccionObligatoriaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DeduccionObligatoria that matches the filter.
     * @param {deduccionObligatoriaFindUniqueArgs} args - Arguments to find a DeduccionObligatoria
     * @example
     * // Get one DeduccionObligatoria
     * const deduccionObligatoria = await prisma.deduccionObligatoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends deduccionObligatoriaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, deduccionObligatoriaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'deduccionObligatoria'> extends True ? CheckSelect<T, Prisma__deduccionObligatoriaClient<deduccionObligatoria>, Prisma__deduccionObligatoriaClient<deduccionObligatoriaGetPayload<T>>> : CheckSelect<T, Prisma__deduccionObligatoriaClient<deduccionObligatoria | null >, Prisma__deduccionObligatoriaClient<deduccionObligatoriaGetPayload<T> | null >>

    /**
     * Find the first DeduccionObligatoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deduccionObligatoriaFindFirstArgs} args - Arguments to find a DeduccionObligatoria
     * @example
     * // Get one DeduccionObligatoria
     * const deduccionObligatoria = await prisma.deduccionObligatoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends deduccionObligatoriaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, deduccionObligatoriaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'deduccionObligatoria'> extends True ? CheckSelect<T, Prisma__deduccionObligatoriaClient<deduccionObligatoria>, Prisma__deduccionObligatoriaClient<deduccionObligatoriaGetPayload<T>>> : CheckSelect<T, Prisma__deduccionObligatoriaClient<deduccionObligatoria | null >, Prisma__deduccionObligatoriaClient<deduccionObligatoriaGetPayload<T> | null >>

    /**
     * Find zero or more DeduccionObligatorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deduccionObligatoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeduccionObligatorias
     * const deduccionObligatorias = await prisma.deduccionObligatoria.findMany()
     * 
     * // Get first 10 DeduccionObligatorias
     * const deduccionObligatorias = await prisma.deduccionObligatoria.findMany({ take: 10 })
     * 
     * // Only select the `nombre`
     * const deduccionObligatoriaWithNombreOnly = await prisma.deduccionObligatoria.findMany({ select: { nombre: true } })
     * 
    **/
    findMany<T extends deduccionObligatoriaFindManyArgs>(
      args?: SelectSubset<T, deduccionObligatoriaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<deduccionObligatoria>>, PrismaPromise<Array<deduccionObligatoriaGetPayload<T>>>>

    /**
     * Create a DeduccionObligatoria.
     * @param {deduccionObligatoriaCreateArgs} args - Arguments to create a DeduccionObligatoria.
     * @example
     * // Create one DeduccionObligatoria
     * const DeduccionObligatoria = await prisma.deduccionObligatoria.create({
     *   data: {
     *     // ... data to create a DeduccionObligatoria
     *   }
     * })
     * 
    **/
    create<T extends deduccionObligatoriaCreateArgs>(
      args: SelectSubset<T, deduccionObligatoriaCreateArgs>
    ): CheckSelect<T, Prisma__deduccionObligatoriaClient<deduccionObligatoria>, Prisma__deduccionObligatoriaClient<deduccionObligatoriaGetPayload<T>>>

    /**
     * Create many DeduccionObligatorias.
     *     @param {deduccionObligatoriaCreateManyArgs} args - Arguments to create many DeduccionObligatorias.
     *     @example
     *     // Create many DeduccionObligatorias
     *     const deduccionObligatoria = await prisma.deduccionObligatoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends deduccionObligatoriaCreateManyArgs>(
      args?: SelectSubset<T, deduccionObligatoriaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DeduccionObligatoria.
     * @param {deduccionObligatoriaDeleteArgs} args - Arguments to delete one DeduccionObligatoria.
     * @example
     * // Delete one DeduccionObligatoria
     * const DeduccionObligatoria = await prisma.deduccionObligatoria.delete({
     *   where: {
     *     // ... filter to delete one DeduccionObligatoria
     *   }
     * })
     * 
    **/
    delete<T extends deduccionObligatoriaDeleteArgs>(
      args: SelectSubset<T, deduccionObligatoriaDeleteArgs>
    ): CheckSelect<T, Prisma__deduccionObligatoriaClient<deduccionObligatoria>, Prisma__deduccionObligatoriaClient<deduccionObligatoriaGetPayload<T>>>

    /**
     * Update one DeduccionObligatoria.
     * @param {deduccionObligatoriaUpdateArgs} args - Arguments to update one DeduccionObligatoria.
     * @example
     * // Update one DeduccionObligatoria
     * const deduccionObligatoria = await prisma.deduccionObligatoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends deduccionObligatoriaUpdateArgs>(
      args: SelectSubset<T, deduccionObligatoriaUpdateArgs>
    ): CheckSelect<T, Prisma__deduccionObligatoriaClient<deduccionObligatoria>, Prisma__deduccionObligatoriaClient<deduccionObligatoriaGetPayload<T>>>

    /**
     * Delete zero or more DeduccionObligatorias.
     * @param {deduccionObligatoriaDeleteManyArgs} args - Arguments to filter DeduccionObligatorias to delete.
     * @example
     * // Delete a few DeduccionObligatorias
     * const { count } = await prisma.deduccionObligatoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends deduccionObligatoriaDeleteManyArgs>(
      args?: SelectSubset<T, deduccionObligatoriaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeduccionObligatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deduccionObligatoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeduccionObligatorias
     * const deduccionObligatoria = await prisma.deduccionObligatoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends deduccionObligatoriaUpdateManyArgs>(
      args: SelectSubset<T, deduccionObligatoriaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DeduccionObligatoria.
     * @param {deduccionObligatoriaUpsertArgs} args - Arguments to update or create a DeduccionObligatoria.
     * @example
     * // Update or create a DeduccionObligatoria
     * const deduccionObligatoria = await prisma.deduccionObligatoria.upsert({
     *   create: {
     *     // ... data to create a DeduccionObligatoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeduccionObligatoria we want to update
     *   }
     * })
    **/
    upsert<T extends deduccionObligatoriaUpsertArgs>(
      args: SelectSubset<T, deduccionObligatoriaUpsertArgs>
    ): CheckSelect<T, Prisma__deduccionObligatoriaClient<deduccionObligatoria>, Prisma__deduccionObligatoriaClient<deduccionObligatoriaGetPayload<T>>>

    /**
     * Count the number of DeduccionObligatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deduccionObligatoriaCountArgs} args - Arguments to filter DeduccionObligatorias to count.
     * @example
     * // Count the number of DeduccionObligatorias
     * const count = await prisma.deduccionObligatoria.count({
     *   where: {
     *     // ... the filter for the DeduccionObligatorias we want to count
     *   }
     * })
    **/
    count<T extends deduccionObligatoriaCountArgs>(
      args?: Subset<T, deduccionObligatoriaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeduccionObligatoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeduccionObligatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeduccionObligatoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeduccionObligatoriaAggregateArgs>(args: Subset<T, DeduccionObligatoriaAggregateArgs>): PrismaPromise<GetDeduccionObligatoriaAggregateType<T>>

    /**
     * Group by DeduccionObligatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeduccionObligatoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeduccionObligatoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeduccionObligatoriaGroupByArgs['orderBy'] }
        : { orderBy?: DeduccionObligatoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeduccionObligatoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeduccionObligatoriaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for deduccionObligatoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__deduccionObligatoriaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    aplica_do<T extends aplica_doFindManyArgs = {}>(args?: Subset<T, aplica_doFindManyArgs>): CheckSelect<T, PrismaPromise<Array<aplica_do>>, PrismaPromise<Array<aplica_doGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * deduccionObligatoria findUnique
   */
  export type deduccionObligatoriaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the deduccionObligatoria
     * 
    **/
    select?: deduccionObligatoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionObligatoriaInclude | null
    /**
     * Throw an Error if a deduccionObligatoria can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which deduccionObligatoria to fetch.
     * 
    **/
    where: deduccionObligatoriaWhereUniqueInput
  }


  /**
   * deduccionObligatoria findFirst
   */
  export type deduccionObligatoriaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the deduccionObligatoria
     * 
    **/
    select?: deduccionObligatoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionObligatoriaInclude | null
    /**
     * Throw an Error if a deduccionObligatoria can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which deduccionObligatoria to fetch.
     * 
    **/
    where?: deduccionObligatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deduccionObligatorias to fetch.
     * 
    **/
    orderBy?: Enumerable<deduccionObligatoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deduccionObligatorias.
     * 
    **/
    cursor?: deduccionObligatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deduccionObligatorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deduccionObligatorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deduccionObligatorias.
     * 
    **/
    distinct?: Enumerable<DeduccionObligatoriaScalarFieldEnum>
  }


  /**
   * deduccionObligatoria findMany
   */
  export type deduccionObligatoriaFindManyArgs = {
    /**
     * Select specific fields to fetch from the deduccionObligatoria
     * 
    **/
    select?: deduccionObligatoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionObligatoriaInclude | null
    /**
     * Filter, which deduccionObligatorias to fetch.
     * 
    **/
    where?: deduccionObligatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deduccionObligatorias to fetch.
     * 
    **/
    orderBy?: Enumerable<deduccionObligatoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deduccionObligatorias.
     * 
    **/
    cursor?: deduccionObligatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deduccionObligatorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deduccionObligatorias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeduccionObligatoriaScalarFieldEnum>
  }


  /**
   * deduccionObligatoria create
   */
  export type deduccionObligatoriaCreateArgs = {
    /**
     * Select specific fields to fetch from the deduccionObligatoria
     * 
    **/
    select?: deduccionObligatoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionObligatoriaInclude | null
    /**
     * The data needed to create a deduccionObligatoria.
     * 
    **/
    data: XOR<deduccionObligatoriaCreateInput, deduccionObligatoriaUncheckedCreateInput>
  }


  /**
   * deduccionObligatoria createMany
   */
  export type deduccionObligatoriaCreateManyArgs = {
    /**
     * The data used to create many deduccionObligatorias.
     * 
    **/
    data: Enumerable<deduccionObligatoriaCreateManyInput>
  }


  /**
   * deduccionObligatoria update
   */
  export type deduccionObligatoriaUpdateArgs = {
    /**
     * Select specific fields to fetch from the deduccionObligatoria
     * 
    **/
    select?: deduccionObligatoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionObligatoriaInclude | null
    /**
     * The data needed to update a deduccionObligatoria.
     * 
    **/
    data: XOR<deduccionObligatoriaUpdateInput, deduccionObligatoriaUncheckedUpdateInput>
    /**
     * Choose, which deduccionObligatoria to update.
     * 
    **/
    where: deduccionObligatoriaWhereUniqueInput
  }


  /**
   * deduccionObligatoria updateMany
   */
  export type deduccionObligatoriaUpdateManyArgs = {
    /**
     * The data used to update deduccionObligatorias.
     * 
    **/
    data: XOR<deduccionObligatoriaUpdateManyMutationInput, deduccionObligatoriaUncheckedUpdateManyInput>
    /**
     * Filter which deduccionObligatorias to update
     * 
    **/
    where?: deduccionObligatoriaWhereInput
  }


  /**
   * deduccionObligatoria upsert
   */
  export type deduccionObligatoriaUpsertArgs = {
    /**
     * Select specific fields to fetch from the deduccionObligatoria
     * 
    **/
    select?: deduccionObligatoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionObligatoriaInclude | null
    /**
     * The filter to search for the deduccionObligatoria to update in case it exists.
     * 
    **/
    where: deduccionObligatoriaWhereUniqueInput
    /**
     * In case the deduccionObligatoria found by the `where` argument doesn't exist, create a new deduccionObligatoria with this data.
     * 
    **/
    create: XOR<deduccionObligatoriaCreateInput, deduccionObligatoriaUncheckedCreateInput>
    /**
     * In case the deduccionObligatoria was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<deduccionObligatoriaUpdateInput, deduccionObligatoriaUncheckedUpdateInput>
  }


  /**
   * deduccionObligatoria delete
   */
  export type deduccionObligatoriaDeleteArgs = {
    /**
     * Select specific fields to fetch from the deduccionObligatoria
     * 
    **/
    select?: deduccionObligatoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionObligatoriaInclude | null
    /**
     * Filter which deduccionObligatoria to delete.
     * 
    **/
    where: deduccionObligatoriaWhereUniqueInput
  }


  /**
   * deduccionObligatoria deleteMany
   */
  export type deduccionObligatoriaDeleteManyArgs = {
    /**
     * Filter which deduccionObligatorias to delete
     * 
    **/
    where?: deduccionObligatoriaWhereInput
  }


  /**
   * deduccionObligatoria without action
   */
  export type deduccionObligatoriaArgs = {
    /**
     * Select specific fields to fetch from the deduccionObligatoria
     * 
    **/
    select?: deduccionObligatoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionObligatoriaInclude | null
  }



  /**
   * Model deduccionVoluntaria
   */


  export type AggregateDeduccionVoluntaria = {
    _count: DeduccionVoluntariaCountAggregateOutputType | null
    _avg: DeduccionVoluntariaAvgAggregateOutputType | null
    _sum: DeduccionVoluntariaSumAggregateOutputType | null
    _min: DeduccionVoluntariaMinAggregateOutputType | null
    _max: DeduccionVoluntariaMaxAggregateOutputType | null
  }

  export type DeduccionVoluntariaAvgAggregateOutputType = {
    monto: number | null
  }

  export type DeduccionVoluntariaSumAggregateOutputType = {
    monto: number | null
  }

  export type DeduccionVoluntariaMinAggregateOutputType = {
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreDeduccion: string | null
    descripcion: string | null
    monto: number | null
    habilitado: boolean | null
  }

  export type DeduccionVoluntariaMaxAggregateOutputType = {
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreDeduccion: string | null
    descripcion: string | null
    monto: number | null
    habilitado: boolean | null
  }

  export type DeduccionVoluntariaCountAggregateOutputType = {
    cedulaJuridica: number
    nombreProyecto: number
    nombreDeduccion: number
    descripcion: number
    monto: number
    habilitado: number
    _all: number
  }


  export type DeduccionVoluntariaAvgAggregateInputType = {
    monto?: true
  }

  export type DeduccionVoluntariaSumAggregateInputType = {
    monto?: true
  }

  export type DeduccionVoluntariaMinAggregateInputType = {
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreDeduccion?: true
    descripcion?: true
    monto?: true
    habilitado?: true
  }

  export type DeduccionVoluntariaMaxAggregateInputType = {
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreDeduccion?: true
    descripcion?: true
    monto?: true
    habilitado?: true
  }

  export type DeduccionVoluntariaCountAggregateInputType = {
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreDeduccion?: true
    descripcion?: true
    monto?: true
    habilitado?: true
    _all?: true
  }

  export type DeduccionVoluntariaAggregateArgs = {
    /**
     * Filter which deduccionVoluntaria to aggregate.
     * 
    **/
    where?: deduccionVoluntariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deduccionVoluntarias to fetch.
     * 
    **/
    orderBy?: Enumerable<deduccionVoluntariaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: deduccionVoluntariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deduccionVoluntarias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deduccionVoluntarias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deduccionVoluntarias
    **/
    _count?: true | DeduccionVoluntariaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeduccionVoluntariaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeduccionVoluntariaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeduccionVoluntariaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeduccionVoluntariaMaxAggregateInputType
  }

  export type GetDeduccionVoluntariaAggregateType<T extends DeduccionVoluntariaAggregateArgs> = {
        [P in keyof T & keyof AggregateDeduccionVoluntaria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeduccionVoluntaria[P]>
      : GetScalarType<T[P], AggregateDeduccionVoluntaria[P]>
  }




  export type DeduccionVoluntariaGroupByArgs = {
    where?: deduccionVoluntariaWhereInput
    orderBy?: Enumerable<deduccionVoluntariaOrderByWithAggregationInput>
    by: Array<DeduccionVoluntariaScalarFieldEnum>
    having?: deduccionVoluntariaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeduccionVoluntariaCountAggregateInputType | true
    _avg?: DeduccionVoluntariaAvgAggregateInputType
    _sum?: DeduccionVoluntariaSumAggregateInputType
    _min?: DeduccionVoluntariaMinAggregateInputType
    _max?: DeduccionVoluntariaMaxAggregateInputType
  }


  export type DeduccionVoluntariaGroupByOutputType = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    descripcion: string | null
    monto: number | null
    habilitado: boolean | null
    _count: DeduccionVoluntariaCountAggregateOutputType | null
    _avg: DeduccionVoluntariaAvgAggregateOutputType | null
    _sum: DeduccionVoluntariaSumAggregateOutputType | null
    _min: DeduccionVoluntariaMinAggregateOutputType | null
    _max: DeduccionVoluntariaMaxAggregateOutputType | null
  }

  type GetDeduccionVoluntariaGroupByPayload<T extends DeduccionVoluntariaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeduccionVoluntariaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeduccionVoluntariaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeduccionVoluntariaGroupByOutputType[P]>
            : GetScalarType<T[P], DeduccionVoluntariaGroupByOutputType[P]>
        }
      >
    >


  export type deduccionVoluntariaSelect = {
    cedulaJuridica?: boolean
    nombreProyecto?: boolean
    nombreDeduccion?: boolean
    descripcion?: boolean
    monto?: boolean
    habilitado?: boolean
    proyecto?: boolean | proyectoArgs
    aplica_dv?: boolean | aplica_dvFindManyArgs
    escoge?: boolean | escogeFindManyArgs
    _count?: boolean | DeduccionVoluntariaCountOutputTypeArgs
  }

  export type deduccionVoluntariaInclude = {
    proyecto?: boolean | proyectoArgs
    aplica_dv?: boolean | aplica_dvFindManyArgs
    escoge?: boolean | escogeFindManyArgs
    _count?: boolean | DeduccionVoluntariaCountOutputTypeArgs
  }

  export type deduccionVoluntariaGetPayload<
    S extends boolean | null | undefined | deduccionVoluntariaArgs,
    U = keyof S
      > = S extends true
        ? deduccionVoluntaria
    : S extends undefined
    ? never
    : S extends deduccionVoluntariaArgs | deduccionVoluntariaFindManyArgs
    ?'include' extends U
    ? deduccionVoluntaria  & {
    [P in TrueKeys<S['include']>]:
        P extends 'proyecto' ? proyectoGetPayload<S['include'][P]> :
        P extends 'aplica_dv' ? Array < aplica_dvGetPayload<S['include'][P]>>  :
        P extends 'escoge' ? Array < escogeGetPayload<S['include'][P]>>  :
        P extends '_count' ? DeduccionVoluntariaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'proyecto' ? proyectoGetPayload<S['select'][P]> :
        P extends 'aplica_dv' ? Array < aplica_dvGetPayload<S['select'][P]>>  :
        P extends 'escoge' ? Array < escogeGetPayload<S['select'][P]>>  :
        P extends '_count' ? DeduccionVoluntariaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof deduccionVoluntaria ? deduccionVoluntaria[P] : never
  } 
    : deduccionVoluntaria
  : deduccionVoluntaria


  type deduccionVoluntariaCountArgs = Merge<
    Omit<deduccionVoluntariaFindManyArgs, 'select' | 'include'> & {
      select?: DeduccionVoluntariaCountAggregateInputType | true
    }
  >

  export interface deduccionVoluntariaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DeduccionVoluntaria that matches the filter.
     * @param {deduccionVoluntariaFindUniqueArgs} args - Arguments to find a DeduccionVoluntaria
     * @example
     * // Get one DeduccionVoluntaria
     * const deduccionVoluntaria = await prisma.deduccionVoluntaria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends deduccionVoluntariaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, deduccionVoluntariaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'deduccionVoluntaria'> extends True ? CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria>, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T>>> : CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria | null >, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T> | null >>

    /**
     * Find the first DeduccionVoluntaria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deduccionVoluntariaFindFirstArgs} args - Arguments to find a DeduccionVoluntaria
     * @example
     * // Get one DeduccionVoluntaria
     * const deduccionVoluntaria = await prisma.deduccionVoluntaria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends deduccionVoluntariaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, deduccionVoluntariaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'deduccionVoluntaria'> extends True ? CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria>, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T>>> : CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria | null >, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T> | null >>

    /**
     * Find zero or more DeduccionVoluntarias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deduccionVoluntariaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeduccionVoluntarias
     * const deduccionVoluntarias = await prisma.deduccionVoluntaria.findMany()
     * 
     * // Get first 10 DeduccionVoluntarias
     * const deduccionVoluntarias = await prisma.deduccionVoluntaria.findMany({ take: 10 })
     * 
     * // Only select the `cedulaJuridica`
     * const deduccionVoluntariaWithCedulaJuridicaOnly = await prisma.deduccionVoluntaria.findMany({ select: { cedulaJuridica: true } })
     * 
    **/
    findMany<T extends deduccionVoluntariaFindManyArgs>(
      args?: SelectSubset<T, deduccionVoluntariaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<deduccionVoluntaria>>, PrismaPromise<Array<deduccionVoluntariaGetPayload<T>>>>

    /**
     * Create a DeduccionVoluntaria.
     * @param {deduccionVoluntariaCreateArgs} args - Arguments to create a DeduccionVoluntaria.
     * @example
     * // Create one DeduccionVoluntaria
     * const DeduccionVoluntaria = await prisma.deduccionVoluntaria.create({
     *   data: {
     *     // ... data to create a DeduccionVoluntaria
     *   }
     * })
     * 
    **/
    create<T extends deduccionVoluntariaCreateArgs>(
      args: SelectSubset<T, deduccionVoluntariaCreateArgs>
    ): CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria>, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T>>>

    /**
     * Create many DeduccionVoluntarias.
     *     @param {deduccionVoluntariaCreateManyArgs} args - Arguments to create many DeduccionVoluntarias.
     *     @example
     *     // Create many DeduccionVoluntarias
     *     const deduccionVoluntaria = await prisma.deduccionVoluntaria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends deduccionVoluntariaCreateManyArgs>(
      args?: SelectSubset<T, deduccionVoluntariaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DeduccionVoluntaria.
     * @param {deduccionVoluntariaDeleteArgs} args - Arguments to delete one DeduccionVoluntaria.
     * @example
     * // Delete one DeduccionVoluntaria
     * const DeduccionVoluntaria = await prisma.deduccionVoluntaria.delete({
     *   where: {
     *     // ... filter to delete one DeduccionVoluntaria
     *   }
     * })
     * 
    **/
    delete<T extends deduccionVoluntariaDeleteArgs>(
      args: SelectSubset<T, deduccionVoluntariaDeleteArgs>
    ): CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria>, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T>>>

    /**
     * Update one DeduccionVoluntaria.
     * @param {deduccionVoluntariaUpdateArgs} args - Arguments to update one DeduccionVoluntaria.
     * @example
     * // Update one DeduccionVoluntaria
     * const deduccionVoluntaria = await prisma.deduccionVoluntaria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends deduccionVoluntariaUpdateArgs>(
      args: SelectSubset<T, deduccionVoluntariaUpdateArgs>
    ): CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria>, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T>>>

    /**
     * Delete zero or more DeduccionVoluntarias.
     * @param {deduccionVoluntariaDeleteManyArgs} args - Arguments to filter DeduccionVoluntarias to delete.
     * @example
     * // Delete a few DeduccionVoluntarias
     * const { count } = await prisma.deduccionVoluntaria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends deduccionVoluntariaDeleteManyArgs>(
      args?: SelectSubset<T, deduccionVoluntariaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeduccionVoluntarias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deduccionVoluntariaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeduccionVoluntarias
     * const deduccionVoluntaria = await prisma.deduccionVoluntaria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends deduccionVoluntariaUpdateManyArgs>(
      args: SelectSubset<T, deduccionVoluntariaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DeduccionVoluntaria.
     * @param {deduccionVoluntariaUpsertArgs} args - Arguments to update or create a DeduccionVoluntaria.
     * @example
     * // Update or create a DeduccionVoluntaria
     * const deduccionVoluntaria = await prisma.deduccionVoluntaria.upsert({
     *   create: {
     *     // ... data to create a DeduccionVoluntaria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeduccionVoluntaria we want to update
     *   }
     * })
    **/
    upsert<T extends deduccionVoluntariaUpsertArgs>(
      args: SelectSubset<T, deduccionVoluntariaUpsertArgs>
    ): CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria>, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T>>>

    /**
     * Count the number of DeduccionVoluntarias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deduccionVoluntariaCountArgs} args - Arguments to filter DeduccionVoluntarias to count.
     * @example
     * // Count the number of DeduccionVoluntarias
     * const count = await prisma.deduccionVoluntaria.count({
     *   where: {
     *     // ... the filter for the DeduccionVoluntarias we want to count
     *   }
     * })
    **/
    count<T extends deduccionVoluntariaCountArgs>(
      args?: Subset<T, deduccionVoluntariaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeduccionVoluntariaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeduccionVoluntaria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeduccionVoluntariaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeduccionVoluntariaAggregateArgs>(args: Subset<T, DeduccionVoluntariaAggregateArgs>): PrismaPromise<GetDeduccionVoluntariaAggregateType<T>>

    /**
     * Group by DeduccionVoluntaria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeduccionVoluntariaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeduccionVoluntariaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeduccionVoluntariaGroupByArgs['orderBy'] }
        : { orderBy?: DeduccionVoluntariaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeduccionVoluntariaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeduccionVoluntariaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for deduccionVoluntaria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__deduccionVoluntariaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    proyecto<T extends proyectoArgs = {}>(args?: Subset<T, proyectoArgs>): CheckSelect<T, Prisma__proyectoClient<proyecto | null >, Prisma__proyectoClient<proyectoGetPayload<T> | null >>;

    aplica_dv<T extends aplica_dvFindManyArgs = {}>(args?: Subset<T, aplica_dvFindManyArgs>): CheckSelect<T, PrismaPromise<Array<aplica_dv>>, PrismaPromise<Array<aplica_dvGetPayload<T>>>>;

    escoge<T extends escogeFindManyArgs = {}>(args?: Subset<T, escogeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<escoge>>, PrismaPromise<Array<escogeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * deduccionVoluntaria findUnique
   */
  export type deduccionVoluntariaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the deduccionVoluntaria
     * 
    **/
    select?: deduccionVoluntariaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionVoluntariaInclude | null
    /**
     * Throw an Error if a deduccionVoluntaria can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which deduccionVoluntaria to fetch.
     * 
    **/
    where: deduccionVoluntariaWhereUniqueInput
  }


  /**
   * deduccionVoluntaria findFirst
   */
  export type deduccionVoluntariaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the deduccionVoluntaria
     * 
    **/
    select?: deduccionVoluntariaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionVoluntariaInclude | null
    /**
     * Throw an Error if a deduccionVoluntaria can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which deduccionVoluntaria to fetch.
     * 
    **/
    where?: deduccionVoluntariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deduccionVoluntarias to fetch.
     * 
    **/
    orderBy?: Enumerable<deduccionVoluntariaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deduccionVoluntarias.
     * 
    **/
    cursor?: deduccionVoluntariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deduccionVoluntarias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deduccionVoluntarias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deduccionVoluntarias.
     * 
    **/
    distinct?: Enumerable<DeduccionVoluntariaScalarFieldEnum>
  }


  /**
   * deduccionVoluntaria findMany
   */
  export type deduccionVoluntariaFindManyArgs = {
    /**
     * Select specific fields to fetch from the deduccionVoluntaria
     * 
    **/
    select?: deduccionVoluntariaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionVoluntariaInclude | null
    /**
     * Filter, which deduccionVoluntarias to fetch.
     * 
    **/
    where?: deduccionVoluntariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deduccionVoluntarias to fetch.
     * 
    **/
    orderBy?: Enumerable<deduccionVoluntariaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deduccionVoluntarias.
     * 
    **/
    cursor?: deduccionVoluntariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deduccionVoluntarias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deduccionVoluntarias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeduccionVoluntariaScalarFieldEnum>
  }


  /**
   * deduccionVoluntaria create
   */
  export type deduccionVoluntariaCreateArgs = {
    /**
     * Select specific fields to fetch from the deduccionVoluntaria
     * 
    **/
    select?: deduccionVoluntariaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionVoluntariaInclude | null
    /**
     * The data needed to create a deduccionVoluntaria.
     * 
    **/
    data: XOR<deduccionVoluntariaCreateInput, deduccionVoluntariaUncheckedCreateInput>
  }


  /**
   * deduccionVoluntaria createMany
   */
  export type deduccionVoluntariaCreateManyArgs = {
    /**
     * The data used to create many deduccionVoluntarias.
     * 
    **/
    data: Enumerable<deduccionVoluntariaCreateManyInput>
  }


  /**
   * deduccionVoluntaria update
   */
  export type deduccionVoluntariaUpdateArgs = {
    /**
     * Select specific fields to fetch from the deduccionVoluntaria
     * 
    **/
    select?: deduccionVoluntariaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionVoluntariaInclude | null
    /**
     * The data needed to update a deduccionVoluntaria.
     * 
    **/
    data: XOR<deduccionVoluntariaUpdateInput, deduccionVoluntariaUncheckedUpdateInput>
    /**
     * Choose, which deduccionVoluntaria to update.
     * 
    **/
    where: deduccionVoluntariaWhereUniqueInput
  }


  /**
   * deduccionVoluntaria updateMany
   */
  export type deduccionVoluntariaUpdateManyArgs = {
    /**
     * The data used to update deduccionVoluntarias.
     * 
    **/
    data: XOR<deduccionVoluntariaUpdateManyMutationInput, deduccionVoluntariaUncheckedUpdateManyInput>
    /**
     * Filter which deduccionVoluntarias to update
     * 
    **/
    where?: deduccionVoluntariaWhereInput
  }


  /**
   * deduccionVoluntaria upsert
   */
  export type deduccionVoluntariaUpsertArgs = {
    /**
     * Select specific fields to fetch from the deduccionVoluntaria
     * 
    **/
    select?: deduccionVoluntariaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionVoluntariaInclude | null
    /**
     * The filter to search for the deduccionVoluntaria to update in case it exists.
     * 
    **/
    where: deduccionVoluntariaWhereUniqueInput
    /**
     * In case the deduccionVoluntaria found by the `where` argument doesn't exist, create a new deduccionVoluntaria with this data.
     * 
    **/
    create: XOR<deduccionVoluntariaCreateInput, deduccionVoluntariaUncheckedCreateInput>
    /**
     * In case the deduccionVoluntaria was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<deduccionVoluntariaUpdateInput, deduccionVoluntariaUncheckedUpdateInput>
  }


  /**
   * deduccionVoluntaria delete
   */
  export type deduccionVoluntariaDeleteArgs = {
    /**
     * Select specific fields to fetch from the deduccionVoluntaria
     * 
    **/
    select?: deduccionVoluntariaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionVoluntariaInclude | null
    /**
     * Filter which deduccionVoluntaria to delete.
     * 
    **/
    where: deduccionVoluntariaWhereUniqueInput
  }


  /**
   * deduccionVoluntaria deleteMany
   */
  export type deduccionVoluntariaDeleteManyArgs = {
    /**
     * Filter which deduccionVoluntarias to delete
     * 
    **/
    where?: deduccionVoluntariaWhereInput
  }


  /**
   * deduccionVoluntaria without action
   */
  export type deduccionVoluntariaArgs = {
    /**
     * Select specific fields to fetch from the deduccionVoluntaria
     * 
    **/
    select?: deduccionVoluntariaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deduccionVoluntariaInclude | null
  }



  /**
   * Model empleado
   */


  export type AggregateEmpleado = {
    _count: EmpleadoCountAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  export type EmpleadoMinAggregateOutputType = {
    cedula: string | null
    cedulaJuridica: string | null
  }

  export type EmpleadoMaxAggregateOutputType = {
    cedula: string | null
    cedulaJuridica: string | null
  }

  export type EmpleadoCountAggregateOutputType = {
    cedula: number
    cedulaJuridica: number
    _all: number
  }


  export type EmpleadoMinAggregateInputType = {
    cedula?: true
    cedulaJuridica?: true
  }

  export type EmpleadoMaxAggregateInputType = {
    cedula?: true
    cedulaJuridica?: true
  }

  export type EmpleadoCountAggregateInputType = {
    cedula?: true
    cedulaJuridica?: true
    _all?: true
  }

  export type EmpleadoAggregateArgs = {
    /**
     * Filter which empleado to aggregate.
     * 
    **/
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     * 
    **/
    orderBy?: Enumerable<empleadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empleados
    **/
    _count?: true | EmpleadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadoMaxAggregateInputType
  }

  export type GetEmpleadoAggregateType<T extends EmpleadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleado[P]>
      : GetScalarType<T[P], AggregateEmpleado[P]>
  }




  export type EmpleadoGroupByArgs = {
    where?: empleadoWhereInput
    orderBy?: Enumerable<empleadoOrderByWithAggregationInput>
    by: Array<EmpleadoScalarFieldEnum>
    having?: empleadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadoCountAggregateInputType | true
    _min?: EmpleadoMinAggregateInputType
    _max?: EmpleadoMaxAggregateInputType
  }


  export type EmpleadoGroupByOutputType = {
    cedula: string
    cedulaJuridica: string | null
    _count: EmpleadoCountAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  type GetEmpleadoGroupByPayload<T extends EmpleadoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EmpleadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
        }
      >
    >


  export type empleadoSelect = {
    cedula?: boolean
    cedulaJuridica?: boolean
    persona?: boolean | personaArgs
    empresa?: boolean | empresaArgs
    escoge?: boolean | escogeFindManyArgs
    esContratado?: boolean | esContratadoFindManyArgs
    pago?: boolean | pagoFindManyArgs
    reporteHoras?: boolean | reporteHorasFindManyArgs
    selecciona?: boolean | seleccionaFindManyArgs
    _count?: boolean | EmpleadoCountOutputTypeArgs
  }

  export type empleadoInclude = {
    persona?: boolean | personaArgs
    empresa?: boolean | empresaArgs
    escoge?: boolean | escogeFindManyArgs
    esContratado?: boolean | esContratadoFindManyArgs
    pago?: boolean | pagoFindManyArgs
    reporteHoras?: boolean | reporteHorasFindManyArgs
    selecciona?: boolean | seleccionaFindManyArgs
    _count?: boolean | EmpleadoCountOutputTypeArgs
  }

  export type empleadoGetPayload<
    S extends boolean | null | undefined | empleadoArgs,
    U = keyof S
      > = S extends true
        ? empleado
    : S extends undefined
    ? never
    : S extends empleadoArgs | empleadoFindManyArgs
    ?'include' extends U
    ? empleado  & {
    [P in TrueKeys<S['include']>]:
        P extends 'persona' ? personaGetPayload<S['include'][P]> :
        P extends 'empresa' ? empresaGetPayload<S['include'][P]> | null :
        P extends 'escoge' ? Array < escogeGetPayload<S['include'][P]>>  :
        P extends 'esContratado' ? Array < esContratadoGetPayload<S['include'][P]>>  :
        P extends 'pago' ? Array < pagoGetPayload<S['include'][P]>>  :
        P extends 'reporteHoras' ? Array < reporteHorasGetPayload<S['include'][P]>>  :
        P extends 'selecciona' ? Array < seleccionaGetPayload<S['include'][P]>>  :
        P extends '_count' ? EmpleadoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'persona' ? personaGetPayload<S['select'][P]> :
        P extends 'empresa' ? empresaGetPayload<S['select'][P]> | null :
        P extends 'escoge' ? Array < escogeGetPayload<S['select'][P]>>  :
        P extends 'esContratado' ? Array < esContratadoGetPayload<S['select'][P]>>  :
        P extends 'pago' ? Array < pagoGetPayload<S['select'][P]>>  :
        P extends 'reporteHoras' ? Array < reporteHorasGetPayload<S['select'][P]>>  :
        P extends 'selecciona' ? Array < seleccionaGetPayload<S['select'][P]>>  :
        P extends '_count' ? EmpleadoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof empleado ? empleado[P] : never
  } 
    : empleado
  : empleado


  type empleadoCountArgs = Merge<
    Omit<empleadoFindManyArgs, 'select' | 'include'> & {
      select?: EmpleadoCountAggregateInputType | true
    }
  >

  export interface empleadoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Empleado that matches the filter.
     * @param {empleadoFindUniqueArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends empleadoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, empleadoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'empleado'> extends True ? CheckSelect<T, Prisma__empleadoClient<empleado>, Prisma__empleadoClient<empleadoGetPayload<T>>> : CheckSelect<T, Prisma__empleadoClient<empleado | null >, Prisma__empleadoClient<empleadoGetPayload<T> | null >>

    /**
     * Find the first Empleado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoFindFirstArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends empleadoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, empleadoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'empleado'> extends True ? CheckSelect<T, Prisma__empleadoClient<empleado>, Prisma__empleadoClient<empleadoGetPayload<T>>> : CheckSelect<T, Prisma__empleadoClient<empleado | null >, Prisma__empleadoClient<empleadoGetPayload<T> | null >>

    /**
     * Find zero or more Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleados
     * const empleados = await prisma.empleado.findMany()
     * 
     * // Get first 10 Empleados
     * const empleados = await prisma.empleado.findMany({ take: 10 })
     * 
     * // Only select the `cedula`
     * const empleadoWithCedulaOnly = await prisma.empleado.findMany({ select: { cedula: true } })
     * 
    **/
    findMany<T extends empleadoFindManyArgs>(
      args?: SelectSubset<T, empleadoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<empleado>>, PrismaPromise<Array<empleadoGetPayload<T>>>>

    /**
     * Create a Empleado.
     * @param {empleadoCreateArgs} args - Arguments to create a Empleado.
     * @example
     * // Create one Empleado
     * const Empleado = await prisma.empleado.create({
     *   data: {
     *     // ... data to create a Empleado
     *   }
     * })
     * 
    **/
    create<T extends empleadoCreateArgs>(
      args: SelectSubset<T, empleadoCreateArgs>
    ): CheckSelect<T, Prisma__empleadoClient<empleado>, Prisma__empleadoClient<empleadoGetPayload<T>>>

    /**
     * Create many Empleados.
     *     @param {empleadoCreateManyArgs} args - Arguments to create many Empleados.
     *     @example
     *     // Create many Empleados
     *     const empleado = await prisma.empleado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends empleadoCreateManyArgs>(
      args?: SelectSubset<T, empleadoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Empleado.
     * @param {empleadoDeleteArgs} args - Arguments to delete one Empleado.
     * @example
     * // Delete one Empleado
     * const Empleado = await prisma.empleado.delete({
     *   where: {
     *     // ... filter to delete one Empleado
     *   }
     * })
     * 
    **/
    delete<T extends empleadoDeleteArgs>(
      args: SelectSubset<T, empleadoDeleteArgs>
    ): CheckSelect<T, Prisma__empleadoClient<empleado>, Prisma__empleadoClient<empleadoGetPayload<T>>>

    /**
     * Update one Empleado.
     * @param {empleadoUpdateArgs} args - Arguments to update one Empleado.
     * @example
     * // Update one Empleado
     * const empleado = await prisma.empleado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends empleadoUpdateArgs>(
      args: SelectSubset<T, empleadoUpdateArgs>
    ): CheckSelect<T, Prisma__empleadoClient<empleado>, Prisma__empleadoClient<empleadoGetPayload<T>>>

    /**
     * Delete zero or more Empleados.
     * @param {empleadoDeleteManyArgs} args - Arguments to filter Empleados to delete.
     * @example
     * // Delete a few Empleados
     * const { count } = await prisma.empleado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends empleadoDeleteManyArgs>(
      args?: SelectSubset<T, empleadoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleados
     * const empleado = await prisma.empleado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends empleadoUpdateManyArgs>(
      args: SelectSubset<T, empleadoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleado.
     * @param {empleadoUpsertArgs} args - Arguments to update or create a Empleado.
     * @example
     * // Update or create a Empleado
     * const empleado = await prisma.empleado.upsert({
     *   create: {
     *     // ... data to create a Empleado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleado we want to update
     *   }
     * })
    **/
    upsert<T extends empleadoUpsertArgs>(
      args: SelectSubset<T, empleadoUpsertArgs>
    ): CheckSelect<T, Prisma__empleadoClient<empleado>, Prisma__empleadoClient<empleadoGetPayload<T>>>

    /**
     * Count the number of Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoCountArgs} args - Arguments to filter Empleados to count.
     * @example
     * // Count the number of Empleados
     * const count = await prisma.empleado.count({
     *   where: {
     *     // ... the filter for the Empleados we want to count
     *   }
     * })
    **/
    count<T extends empleadoCountArgs>(
      args?: Subset<T, empleadoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadoAggregateArgs>(args: Subset<T, EmpleadoAggregateArgs>): PrismaPromise<GetEmpleadoAggregateType<T>>

    /**
     * Group by Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpleadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpleadoGroupByArgs['orderBy'] }
        : { orderBy?: EmpleadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpleadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for empleado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__empleadoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    persona<T extends personaArgs = {}>(args?: Subset<T, personaArgs>): CheckSelect<T, Prisma__personaClient<persona | null >, Prisma__personaClient<personaGetPayload<T> | null >>;

    empresa<T extends empresaArgs = {}>(args?: Subset<T, empresaArgs>): CheckSelect<T, Prisma__empresaClient<empresa | null >, Prisma__empresaClient<empresaGetPayload<T> | null >>;

    escoge<T extends escogeFindManyArgs = {}>(args?: Subset<T, escogeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<escoge>>, PrismaPromise<Array<escogeGetPayload<T>>>>;

    esContratado<T extends esContratadoFindManyArgs = {}>(args?: Subset<T, esContratadoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<esContratado>>, PrismaPromise<Array<esContratadoGetPayload<T>>>>;

    pago<T extends pagoFindManyArgs = {}>(args?: Subset<T, pagoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<pago>>, PrismaPromise<Array<pagoGetPayload<T>>>>;

    reporteHoras<T extends reporteHorasFindManyArgs = {}>(args?: Subset<T, reporteHorasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reporteHoras>>, PrismaPromise<Array<reporteHorasGetPayload<T>>>>;

    selecciona<T extends seleccionaFindManyArgs = {}>(args?: Subset<T, seleccionaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<selecciona>>, PrismaPromise<Array<seleccionaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * empleado findUnique
   */
  export type empleadoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the empleado
     * 
    **/
    select?: empleadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadoInclude | null
    /**
     * Throw an Error if a empleado can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which empleado to fetch.
     * 
    **/
    where: empleadoWhereUniqueInput
  }


  /**
   * empleado findFirst
   */
  export type empleadoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the empleado
     * 
    **/
    select?: empleadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadoInclude | null
    /**
     * Throw an Error if a empleado can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which empleado to fetch.
     * 
    **/
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     * 
    **/
    orderBy?: Enumerable<empleadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleados.
     * 
    **/
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleados.
     * 
    **/
    distinct?: Enumerable<EmpleadoScalarFieldEnum>
  }


  /**
   * empleado findMany
   */
  export type empleadoFindManyArgs = {
    /**
     * Select specific fields to fetch from the empleado
     * 
    **/
    select?: empleadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadoInclude | null
    /**
     * Filter, which empleados to fetch.
     * 
    **/
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     * 
    **/
    orderBy?: Enumerable<empleadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empleados.
     * 
    **/
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmpleadoScalarFieldEnum>
  }


  /**
   * empleado create
   */
  export type empleadoCreateArgs = {
    /**
     * Select specific fields to fetch from the empleado
     * 
    **/
    select?: empleadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadoInclude | null
    /**
     * The data needed to create a empleado.
     * 
    **/
    data: XOR<empleadoCreateInput, empleadoUncheckedCreateInput>
  }


  /**
   * empleado createMany
   */
  export type empleadoCreateManyArgs = {
    /**
     * The data used to create many empleados.
     * 
    **/
    data: Enumerable<empleadoCreateManyInput>
  }


  /**
   * empleado update
   */
  export type empleadoUpdateArgs = {
    /**
     * Select specific fields to fetch from the empleado
     * 
    **/
    select?: empleadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadoInclude | null
    /**
     * The data needed to update a empleado.
     * 
    **/
    data: XOR<empleadoUpdateInput, empleadoUncheckedUpdateInput>
    /**
     * Choose, which empleado to update.
     * 
    **/
    where: empleadoWhereUniqueInput
  }


  /**
   * empleado updateMany
   */
  export type empleadoUpdateManyArgs = {
    /**
     * The data used to update empleados.
     * 
    **/
    data: XOR<empleadoUpdateManyMutationInput, empleadoUncheckedUpdateManyInput>
    /**
     * Filter which empleados to update
     * 
    **/
    where?: empleadoWhereInput
  }


  /**
   * empleado upsert
   */
  export type empleadoUpsertArgs = {
    /**
     * Select specific fields to fetch from the empleado
     * 
    **/
    select?: empleadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadoInclude | null
    /**
     * The filter to search for the empleado to update in case it exists.
     * 
    **/
    where: empleadoWhereUniqueInput
    /**
     * In case the empleado found by the `where` argument doesn't exist, create a new empleado with this data.
     * 
    **/
    create: XOR<empleadoCreateInput, empleadoUncheckedCreateInput>
    /**
     * In case the empleado was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<empleadoUpdateInput, empleadoUncheckedUpdateInput>
  }


  /**
   * empleado delete
   */
  export type empleadoDeleteArgs = {
    /**
     * Select specific fields to fetch from the empleado
     * 
    **/
    select?: empleadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadoInclude | null
    /**
     * Filter which empleado to delete.
     * 
    **/
    where: empleadoWhereUniqueInput
  }


  /**
   * empleado deleteMany
   */
  export type empleadoDeleteManyArgs = {
    /**
     * Filter which empleados to delete
     * 
    **/
    where?: empleadoWhereInput
  }


  /**
   * empleado without action
   */
  export type empleadoArgs = {
    /**
     * Select specific fields to fetch from the empleado
     * 
    **/
    select?: empleadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadoInclude | null
  }



  /**
   * Model empleador
   */


  export type AggregateEmpleador = {
    _count: EmpleadorCountAggregateOutputType | null
    _min: EmpleadorMinAggregateOutputType | null
    _max: EmpleadorMaxAggregateOutputType | null
  }

  export type EmpleadorMinAggregateOutputType = {
    cedula: string | null
  }

  export type EmpleadorMaxAggregateOutputType = {
    cedula: string | null
  }

  export type EmpleadorCountAggregateOutputType = {
    cedula: number
    _all: number
  }


  export type EmpleadorMinAggregateInputType = {
    cedula?: true
  }

  export type EmpleadorMaxAggregateInputType = {
    cedula?: true
  }

  export type EmpleadorCountAggregateInputType = {
    cedula?: true
    _all?: true
  }

  export type EmpleadorAggregateArgs = {
    /**
     * Filter which empleador to aggregate.
     * 
    **/
    where?: empleadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleadors to fetch.
     * 
    **/
    orderBy?: Enumerable<empleadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: empleadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleadors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleadors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empleadors
    **/
    _count?: true | EmpleadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadorMaxAggregateInputType
  }

  export type GetEmpleadorAggregateType<T extends EmpleadorAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleador[P]>
      : GetScalarType<T[P], AggregateEmpleador[P]>
  }




  export type EmpleadorGroupByArgs = {
    where?: empleadorWhereInput
    orderBy?: Enumerable<empleadorOrderByWithAggregationInput>
    by: Array<EmpleadorScalarFieldEnum>
    having?: empleadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadorCountAggregateInputType | true
    _min?: EmpleadorMinAggregateInputType
    _max?: EmpleadorMaxAggregateInputType
  }


  export type EmpleadorGroupByOutputType = {
    cedula: string
    _count: EmpleadorCountAggregateOutputType | null
    _min: EmpleadorMinAggregateOutputType | null
    _max: EmpleadorMaxAggregateOutputType | null
  }

  type GetEmpleadorGroupByPayload<T extends EmpleadorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EmpleadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadorGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadorGroupByOutputType[P]>
        }
      >
    >


  export type empleadorSelect = {
    cedula?: boolean
    persona?: boolean | personaArgs
    empresa?: boolean | empresaFindManyArgs
    reporteHoras?: boolean | reporteHorasFindManyArgs
    _count?: boolean | EmpleadorCountOutputTypeArgs
  }

  export type empleadorInclude = {
    persona?: boolean | personaArgs
    empresa?: boolean | empresaFindManyArgs
    reporteHoras?: boolean | reporteHorasFindManyArgs
    _count?: boolean | EmpleadorCountOutputTypeArgs
  }

  export type empleadorGetPayload<
    S extends boolean | null | undefined | empleadorArgs,
    U = keyof S
      > = S extends true
        ? empleador
    : S extends undefined
    ? never
    : S extends empleadorArgs | empleadorFindManyArgs
    ?'include' extends U
    ? empleador  & {
    [P in TrueKeys<S['include']>]:
        P extends 'persona' ? personaGetPayload<S['include'][P]> :
        P extends 'empresa' ? Array < empresaGetPayload<S['include'][P]>>  :
        P extends 'reporteHoras' ? Array < reporteHorasGetPayload<S['include'][P]>>  :
        P extends '_count' ? EmpleadorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'persona' ? personaGetPayload<S['select'][P]> :
        P extends 'empresa' ? Array < empresaGetPayload<S['select'][P]>>  :
        P extends 'reporteHoras' ? Array < reporteHorasGetPayload<S['select'][P]>>  :
        P extends '_count' ? EmpleadorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof empleador ? empleador[P] : never
  } 
    : empleador
  : empleador


  type empleadorCountArgs = Merge<
    Omit<empleadorFindManyArgs, 'select' | 'include'> & {
      select?: EmpleadorCountAggregateInputType | true
    }
  >

  export interface empleadorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Empleador that matches the filter.
     * @param {empleadorFindUniqueArgs} args - Arguments to find a Empleador
     * @example
     * // Get one Empleador
     * const empleador = await prisma.empleador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends empleadorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, empleadorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'empleador'> extends True ? CheckSelect<T, Prisma__empleadorClient<empleador>, Prisma__empleadorClient<empleadorGetPayload<T>>> : CheckSelect<T, Prisma__empleadorClient<empleador | null >, Prisma__empleadorClient<empleadorGetPayload<T> | null >>

    /**
     * Find the first Empleador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadorFindFirstArgs} args - Arguments to find a Empleador
     * @example
     * // Get one Empleador
     * const empleador = await prisma.empleador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends empleadorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, empleadorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'empleador'> extends True ? CheckSelect<T, Prisma__empleadorClient<empleador>, Prisma__empleadorClient<empleadorGetPayload<T>>> : CheckSelect<T, Prisma__empleadorClient<empleador | null >, Prisma__empleadorClient<empleadorGetPayload<T> | null >>

    /**
     * Find zero or more Empleadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleadors
     * const empleadors = await prisma.empleador.findMany()
     * 
     * // Get first 10 Empleadors
     * const empleadors = await prisma.empleador.findMany({ take: 10 })
     * 
     * // Only select the `cedula`
     * const empleadorWithCedulaOnly = await prisma.empleador.findMany({ select: { cedula: true } })
     * 
    **/
    findMany<T extends empleadorFindManyArgs>(
      args?: SelectSubset<T, empleadorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<empleador>>, PrismaPromise<Array<empleadorGetPayload<T>>>>

    /**
     * Create a Empleador.
     * @param {empleadorCreateArgs} args - Arguments to create a Empleador.
     * @example
     * // Create one Empleador
     * const Empleador = await prisma.empleador.create({
     *   data: {
     *     // ... data to create a Empleador
     *   }
     * })
     * 
    **/
    create<T extends empleadorCreateArgs>(
      args: SelectSubset<T, empleadorCreateArgs>
    ): CheckSelect<T, Prisma__empleadorClient<empleador>, Prisma__empleadorClient<empleadorGetPayload<T>>>

    /**
     * Create many Empleadors.
     *     @param {empleadorCreateManyArgs} args - Arguments to create many Empleadors.
     *     @example
     *     // Create many Empleadors
     *     const empleador = await prisma.empleador.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends empleadorCreateManyArgs>(
      args?: SelectSubset<T, empleadorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Empleador.
     * @param {empleadorDeleteArgs} args - Arguments to delete one Empleador.
     * @example
     * // Delete one Empleador
     * const Empleador = await prisma.empleador.delete({
     *   where: {
     *     // ... filter to delete one Empleador
     *   }
     * })
     * 
    **/
    delete<T extends empleadorDeleteArgs>(
      args: SelectSubset<T, empleadorDeleteArgs>
    ): CheckSelect<T, Prisma__empleadorClient<empleador>, Prisma__empleadorClient<empleadorGetPayload<T>>>

    /**
     * Update one Empleador.
     * @param {empleadorUpdateArgs} args - Arguments to update one Empleador.
     * @example
     * // Update one Empleador
     * const empleador = await prisma.empleador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends empleadorUpdateArgs>(
      args: SelectSubset<T, empleadorUpdateArgs>
    ): CheckSelect<T, Prisma__empleadorClient<empleador>, Prisma__empleadorClient<empleadorGetPayload<T>>>

    /**
     * Delete zero or more Empleadors.
     * @param {empleadorDeleteManyArgs} args - Arguments to filter Empleadors to delete.
     * @example
     * // Delete a few Empleadors
     * const { count } = await prisma.empleador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends empleadorDeleteManyArgs>(
      args?: SelectSubset<T, empleadorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleadors
     * const empleador = await prisma.empleador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends empleadorUpdateManyArgs>(
      args: SelectSubset<T, empleadorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleador.
     * @param {empleadorUpsertArgs} args - Arguments to update or create a Empleador.
     * @example
     * // Update or create a Empleador
     * const empleador = await prisma.empleador.upsert({
     *   create: {
     *     // ... data to create a Empleador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleador we want to update
     *   }
     * })
    **/
    upsert<T extends empleadorUpsertArgs>(
      args: SelectSubset<T, empleadorUpsertArgs>
    ): CheckSelect<T, Prisma__empleadorClient<empleador>, Prisma__empleadorClient<empleadorGetPayload<T>>>

    /**
     * Count the number of Empleadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadorCountArgs} args - Arguments to filter Empleadors to count.
     * @example
     * // Count the number of Empleadors
     * const count = await prisma.empleador.count({
     *   where: {
     *     // ... the filter for the Empleadors we want to count
     *   }
     * })
    **/
    count<T extends empleadorCountArgs>(
      args?: Subset<T, empleadorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadorAggregateArgs>(args: Subset<T, EmpleadorAggregateArgs>): PrismaPromise<GetEmpleadorAggregateType<T>>

    /**
     * Group by Empleador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpleadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpleadorGroupByArgs['orderBy'] }
        : { orderBy?: EmpleadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpleadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadorGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for empleador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__empleadorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    persona<T extends personaArgs = {}>(args?: Subset<T, personaArgs>): CheckSelect<T, Prisma__personaClient<persona | null >, Prisma__personaClient<personaGetPayload<T> | null >>;

    empresa<T extends empresaFindManyArgs = {}>(args?: Subset<T, empresaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<empresa>>, PrismaPromise<Array<empresaGetPayload<T>>>>;

    reporteHoras<T extends reporteHorasFindManyArgs = {}>(args?: Subset<T, reporteHorasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reporteHoras>>, PrismaPromise<Array<reporteHorasGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * empleador findUnique
   */
  export type empleadorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the empleador
     * 
    **/
    select?: empleadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadorInclude | null
    /**
     * Throw an Error if a empleador can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which empleador to fetch.
     * 
    **/
    where: empleadorWhereUniqueInput
  }


  /**
   * empleador findFirst
   */
  export type empleadorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the empleador
     * 
    **/
    select?: empleadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadorInclude | null
    /**
     * Throw an Error if a empleador can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which empleador to fetch.
     * 
    **/
    where?: empleadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleadors to fetch.
     * 
    **/
    orderBy?: Enumerable<empleadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleadors.
     * 
    **/
    cursor?: empleadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleadors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleadors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleadors.
     * 
    **/
    distinct?: Enumerable<EmpleadorScalarFieldEnum>
  }


  /**
   * empleador findMany
   */
  export type empleadorFindManyArgs = {
    /**
     * Select specific fields to fetch from the empleador
     * 
    **/
    select?: empleadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadorInclude | null
    /**
     * Filter, which empleadors to fetch.
     * 
    **/
    where?: empleadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleadors to fetch.
     * 
    **/
    orderBy?: Enumerable<empleadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empleadors.
     * 
    **/
    cursor?: empleadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleadors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleadors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmpleadorScalarFieldEnum>
  }


  /**
   * empleador create
   */
  export type empleadorCreateArgs = {
    /**
     * Select specific fields to fetch from the empleador
     * 
    **/
    select?: empleadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadorInclude | null
    /**
     * The data needed to create a empleador.
     * 
    **/
    data: XOR<empleadorCreateInput, empleadorUncheckedCreateInput>
  }


  /**
   * empleador createMany
   */
  export type empleadorCreateManyArgs = {
    /**
     * The data used to create many empleadors.
     * 
    **/
    data: Enumerable<empleadorCreateManyInput>
  }


  /**
   * empleador update
   */
  export type empleadorUpdateArgs = {
    /**
     * Select specific fields to fetch from the empleador
     * 
    **/
    select?: empleadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadorInclude | null
    /**
     * The data needed to update a empleador.
     * 
    **/
    data: XOR<empleadorUpdateInput, empleadorUncheckedUpdateInput>
    /**
     * Choose, which empleador to update.
     * 
    **/
    where: empleadorWhereUniqueInput
  }


  /**
   * empleador updateMany
   */
  export type empleadorUpdateManyArgs = {
    /**
     * The data used to update empleadors.
     * 
    **/
    data: XOR<empleadorUpdateManyMutationInput, empleadorUncheckedUpdateManyInput>
    /**
     * Filter which empleadors to update
     * 
    **/
    where?: empleadorWhereInput
  }


  /**
   * empleador upsert
   */
  export type empleadorUpsertArgs = {
    /**
     * Select specific fields to fetch from the empleador
     * 
    **/
    select?: empleadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadorInclude | null
    /**
     * The filter to search for the empleador to update in case it exists.
     * 
    **/
    where: empleadorWhereUniqueInput
    /**
     * In case the empleador found by the `where` argument doesn't exist, create a new empleador with this data.
     * 
    **/
    create: XOR<empleadorCreateInput, empleadorUncheckedCreateInput>
    /**
     * In case the empleador was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<empleadorUpdateInput, empleadorUncheckedUpdateInput>
  }


  /**
   * empleador delete
   */
  export type empleadorDeleteArgs = {
    /**
     * Select specific fields to fetch from the empleador
     * 
    **/
    select?: empleadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadorInclude | null
    /**
     * Filter which empleador to delete.
     * 
    **/
    where: empleadorWhereUniqueInput
  }


  /**
   * empleador deleteMany
   */
  export type empleadorDeleteManyArgs = {
    /**
     * Filter which empleadors to delete
     * 
    **/
    where?: empleadorWhereInput
  }


  /**
   * empleador without action
   */
  export type empleadorArgs = {
    /**
     * Select specific fields to fetch from the empleador
     * 
    **/
    select?: empleadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadorInclude | null
  }



  /**
   * Model empresa
   */


  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaMinAggregateOutputType = {
    cedulaJuridica: string | null
    direccion: string | null
    razonSocial: string | null
    email: string | null
    habilitado: boolean | null
    cedulaEmpleador: string | null
    telefono: string | null
  }

  export type EmpresaMaxAggregateOutputType = {
    cedulaJuridica: string | null
    direccion: string | null
    razonSocial: string | null
    email: string | null
    habilitado: boolean | null
    cedulaEmpleador: string | null
    telefono: string | null
  }

  export type EmpresaCountAggregateOutputType = {
    cedulaJuridica: number
    direccion: number
    razonSocial: number
    email: number
    habilitado: number
    cedulaEmpleador: number
    telefono: number
    _all: number
  }


  export type EmpresaMinAggregateInputType = {
    cedulaJuridica?: true
    direccion?: true
    razonSocial?: true
    email?: true
    habilitado?: true
    cedulaEmpleador?: true
    telefono?: true
  }

  export type EmpresaMaxAggregateInputType = {
    cedulaJuridica?: true
    direccion?: true
    razonSocial?: true
    email?: true
    habilitado?: true
    cedulaEmpleador?: true
    telefono?: true
  }

  export type EmpresaCountAggregateInputType = {
    cedulaJuridica?: true
    direccion?: true
    razonSocial?: true
    email?: true
    habilitado?: true
    cedulaEmpleador?: true
    telefono?: true
    _all?: true
  }

  export type EmpresaAggregateArgs = {
    /**
     * Filter which empresa to aggregate.
     * 
    **/
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     * 
    **/
    orderBy?: Enumerable<empresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type EmpresaGroupByArgs = {
    where?: empresaWhereInput
    orderBy?: Enumerable<empresaOrderByWithAggregationInput>
    by: Array<EmpresaScalarFieldEnum>
    having?: empresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }


  export type EmpresaGroupByOutputType = {
    cedulaJuridica: string
    direccion: string | null
    razonSocial: string | null
    email: string | null
    habilitado: boolean | null
    cedulaEmpleador: string | null
    telefono: string | null
    _count: EmpresaCountAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends EmpresaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type empresaSelect = {
    cedulaJuridica?: boolean
    direccion?: boolean
    razonSocial?: boolean
    email?: boolean
    habilitado?: boolean
    cedulaEmpleador?: boolean
    telefono?: boolean
    empleador?: boolean | empleadorArgs
    empleado?: boolean | empleadoFindManyArgs
    proyecto?: boolean | proyectoFindManyArgs
    _count?: boolean | EmpresaCountOutputTypeArgs
  }

  export type empresaInclude = {
    empleador?: boolean | empleadorArgs
    empleado?: boolean | empleadoFindManyArgs
    proyecto?: boolean | proyectoFindManyArgs
    _count?: boolean | EmpresaCountOutputTypeArgs
  }

  export type empresaGetPayload<
    S extends boolean | null | undefined | empresaArgs,
    U = keyof S
      > = S extends true
        ? empresa
    : S extends undefined
    ? never
    : S extends empresaArgs | empresaFindManyArgs
    ?'include' extends U
    ? empresa  & {
    [P in TrueKeys<S['include']>]:
        P extends 'empleador' ? empleadorGetPayload<S['include'][P]> | null :
        P extends 'empleado' ? Array < empleadoGetPayload<S['include'][P]>>  :
        P extends 'proyecto' ? Array < proyectoGetPayload<S['include'][P]>>  :
        P extends '_count' ? EmpresaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'empleador' ? empleadorGetPayload<S['select'][P]> | null :
        P extends 'empleado' ? Array < empleadoGetPayload<S['select'][P]>>  :
        P extends 'proyecto' ? Array < proyectoGetPayload<S['select'][P]>>  :
        P extends '_count' ? EmpresaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof empresa ? empresa[P] : never
  } 
    : empresa
  : empresa


  type empresaCountArgs = Merge<
    Omit<empresaFindManyArgs, 'select' | 'include'> & {
      select?: EmpresaCountAggregateInputType | true
    }
  >

  export interface empresaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {empresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends empresaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, empresaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'empresa'> extends True ? CheckSelect<T, Prisma__empresaClient<empresa>, Prisma__empresaClient<empresaGetPayload<T>>> : CheckSelect<T, Prisma__empresaClient<empresa | null >, Prisma__empresaClient<empresaGetPayload<T> | null >>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends empresaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, empresaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'empresa'> extends True ? CheckSelect<T, Prisma__empresaClient<empresa>, Prisma__empresaClient<empresaGetPayload<T>>> : CheckSelect<T, Prisma__empresaClient<empresa | null >, Prisma__empresaClient<empresaGetPayload<T> | null >>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `cedulaJuridica`
     * const empresaWithCedulaJuridicaOnly = await prisma.empresa.findMany({ select: { cedulaJuridica: true } })
     * 
    **/
    findMany<T extends empresaFindManyArgs>(
      args?: SelectSubset<T, empresaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<empresa>>, PrismaPromise<Array<empresaGetPayload<T>>>>

    /**
     * Create a Empresa.
     * @param {empresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
    **/
    create<T extends empresaCreateArgs>(
      args: SelectSubset<T, empresaCreateArgs>
    ): CheckSelect<T, Prisma__empresaClient<empresa>, Prisma__empresaClient<empresaGetPayload<T>>>

    /**
     * Create many Empresas.
     *     @param {empresaCreateManyArgs} args - Arguments to create many Empresas.
     *     @example
     *     // Create many Empresas
     *     const empresa = await prisma.empresa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends empresaCreateManyArgs>(
      args?: SelectSubset<T, empresaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Empresa.
     * @param {empresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
    **/
    delete<T extends empresaDeleteArgs>(
      args: SelectSubset<T, empresaDeleteArgs>
    ): CheckSelect<T, Prisma__empresaClient<empresa>, Prisma__empresaClient<empresaGetPayload<T>>>

    /**
     * Update one Empresa.
     * @param {empresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends empresaUpdateArgs>(
      args: SelectSubset<T, empresaUpdateArgs>
    ): CheckSelect<T, Prisma__empresaClient<empresa>, Prisma__empresaClient<empresaGetPayload<T>>>

    /**
     * Delete zero or more Empresas.
     * @param {empresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends empresaDeleteManyArgs>(
      args?: SelectSubset<T, empresaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends empresaUpdateManyArgs>(
      args: SelectSubset<T, empresaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresa.
     * @param {empresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
    **/
    upsert<T extends empresaUpsertArgs>(
      args: SelectSubset<T, empresaUpsertArgs>
    ): CheckSelect<T, Prisma__empresaClient<empresa>, Prisma__empresaClient<empresaGetPayload<T>>>

    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends empresaCountArgs>(
      args?: Subset<T, empresaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__empresaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empleador<T extends empleadorArgs = {}>(args?: Subset<T, empleadorArgs>): CheckSelect<T, Prisma__empleadorClient<empleador | null >, Prisma__empleadorClient<empleadorGetPayload<T> | null >>;

    empleado<T extends empleadoFindManyArgs = {}>(args?: Subset<T, empleadoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<empleado>>, PrismaPromise<Array<empleadoGetPayload<T>>>>;

    proyecto<T extends proyectoFindManyArgs = {}>(args?: Subset<T, proyectoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<proyecto>>, PrismaPromise<Array<proyectoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * empresa findUnique
   */
  export type empresaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the empresa
     * 
    **/
    select?: empresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empresaInclude | null
    /**
     * Throw an Error if a empresa can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which empresa to fetch.
     * 
    **/
    where: empresaWhereUniqueInput
  }


  /**
   * empresa findFirst
   */
  export type empresaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the empresa
     * 
    **/
    select?: empresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empresaInclude | null
    /**
     * Throw an Error if a empresa can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which empresa to fetch.
     * 
    **/
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     * 
    **/
    orderBy?: Enumerable<empresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empresas.
     * 
    **/
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empresas.
     * 
    **/
    distinct?: Enumerable<EmpresaScalarFieldEnum>
  }


  /**
   * empresa findMany
   */
  export type empresaFindManyArgs = {
    /**
     * Select specific fields to fetch from the empresa
     * 
    **/
    select?: empresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empresaInclude | null
    /**
     * Filter, which empresas to fetch.
     * 
    **/
    where?: empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     * 
    **/
    orderBy?: Enumerable<empresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empresas.
     * 
    **/
    cursor?: empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmpresaScalarFieldEnum>
  }


  /**
   * empresa create
   */
  export type empresaCreateArgs = {
    /**
     * Select specific fields to fetch from the empresa
     * 
    **/
    select?: empresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empresaInclude | null
    /**
     * The data needed to create a empresa.
     * 
    **/
    data: XOR<empresaCreateInput, empresaUncheckedCreateInput>
  }


  /**
   * empresa createMany
   */
  export type empresaCreateManyArgs = {
    /**
     * The data used to create many empresas.
     * 
    **/
    data: Enumerable<empresaCreateManyInput>
  }


  /**
   * empresa update
   */
  export type empresaUpdateArgs = {
    /**
     * Select specific fields to fetch from the empresa
     * 
    **/
    select?: empresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empresaInclude | null
    /**
     * The data needed to update a empresa.
     * 
    **/
    data: XOR<empresaUpdateInput, empresaUncheckedUpdateInput>
    /**
     * Choose, which empresa to update.
     * 
    **/
    where: empresaWhereUniqueInput
  }


  /**
   * empresa updateMany
   */
  export type empresaUpdateManyArgs = {
    /**
     * The data used to update empresas.
     * 
    **/
    data: XOR<empresaUpdateManyMutationInput, empresaUncheckedUpdateManyInput>
    /**
     * Filter which empresas to update
     * 
    **/
    where?: empresaWhereInput
  }


  /**
   * empresa upsert
   */
  export type empresaUpsertArgs = {
    /**
     * Select specific fields to fetch from the empresa
     * 
    **/
    select?: empresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empresaInclude | null
    /**
     * The filter to search for the empresa to update in case it exists.
     * 
    **/
    where: empresaWhereUniqueInput
    /**
     * In case the empresa found by the `where` argument doesn't exist, create a new empresa with this data.
     * 
    **/
    create: XOR<empresaCreateInput, empresaUncheckedCreateInput>
    /**
     * In case the empresa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<empresaUpdateInput, empresaUncheckedUpdateInput>
  }


  /**
   * empresa delete
   */
  export type empresaDeleteArgs = {
    /**
     * Select specific fields to fetch from the empresa
     * 
    **/
    select?: empresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empresaInclude | null
    /**
     * Filter which empresa to delete.
     * 
    **/
    where: empresaWhereUniqueInput
  }


  /**
   * empresa deleteMany
   */
  export type empresaDeleteManyArgs = {
    /**
     * Filter which empresas to delete
     * 
    **/
    where?: empresaWhereInput
  }


  /**
   * empresa without action
   */
  export type empresaArgs = {
    /**
     * Select specific fields to fetch from the empresa
     * 
    **/
    select?: empresaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empresaInclude | null
  }



  /**
   * Model escoge
   */


  export type AggregateEscoge = {
    _count: EscogeCountAggregateOutputType | null
    _avg: EscogeAvgAggregateOutputType | null
    _sum: EscogeSumAggregateOutputType | null
    _min: EscogeMinAggregateOutputType | null
    _max: EscogeMaxAggregateOutputType | null
  }

  export type EscogeAvgAggregateOutputType = {
    aporte: number | null
  }

  export type EscogeSumAggregateOutputType = {
    aporte: number | null
  }

  export type EscogeMinAggregateOutputType = {
    cedulaEmpleado: string | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreDeduccion: string | null
    aporte: number | null
  }

  export type EscogeMaxAggregateOutputType = {
    cedulaEmpleado: string | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreDeduccion: string | null
    aporte: number | null
  }

  export type EscogeCountAggregateOutputType = {
    cedulaEmpleado: number
    cedulaJuridica: number
    nombreProyecto: number
    nombreDeduccion: number
    aporte: number
    _all: number
  }


  export type EscogeAvgAggregateInputType = {
    aporte?: true
  }

  export type EscogeSumAggregateInputType = {
    aporte?: true
  }

  export type EscogeMinAggregateInputType = {
    cedulaEmpleado?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreDeduccion?: true
    aporte?: true
  }

  export type EscogeMaxAggregateInputType = {
    cedulaEmpleado?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreDeduccion?: true
    aporte?: true
  }

  export type EscogeCountAggregateInputType = {
    cedulaEmpleado?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreDeduccion?: true
    aporte?: true
    _all?: true
  }

  export type EscogeAggregateArgs = {
    /**
     * Filter which escoge to aggregate.
     * 
    **/
    where?: escogeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escoges to fetch.
     * 
    **/
    orderBy?: Enumerable<escogeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: escogeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escoges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escoges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned escoges
    **/
    _count?: true | EscogeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscogeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscogeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscogeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscogeMaxAggregateInputType
  }

  export type GetEscogeAggregateType<T extends EscogeAggregateArgs> = {
        [P in keyof T & keyof AggregateEscoge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscoge[P]>
      : GetScalarType<T[P], AggregateEscoge[P]>
  }




  export type EscogeGroupByArgs = {
    where?: escogeWhereInput
    orderBy?: Enumerable<escogeOrderByWithAggregationInput>
    by: Array<EscogeScalarFieldEnum>
    having?: escogeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscogeCountAggregateInputType | true
    _avg?: EscogeAvgAggregateInputType
    _sum?: EscogeSumAggregateInputType
    _min?: EscogeMinAggregateInputType
    _max?: EscogeMaxAggregateInputType
  }


  export type EscogeGroupByOutputType = {
    cedulaEmpleado: string
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    aporte: number | null
    _count: EscogeCountAggregateOutputType | null
    _avg: EscogeAvgAggregateOutputType | null
    _sum: EscogeSumAggregateOutputType | null
    _min: EscogeMinAggregateOutputType | null
    _max: EscogeMaxAggregateOutputType | null
  }

  type GetEscogeGroupByPayload<T extends EscogeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EscogeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscogeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscogeGroupByOutputType[P]>
            : GetScalarType<T[P], EscogeGroupByOutputType[P]>
        }
      >
    >


  export type escogeSelect = {
    cedulaEmpleado?: boolean
    cedulaJuridica?: boolean
    nombreProyecto?: boolean
    nombreDeduccion?: boolean
    aporte?: boolean
    empleado?: boolean | empleadoArgs
    deduccionVoluntaria?: boolean | deduccionVoluntariaArgs
  }

  export type escogeInclude = {
    empleado?: boolean | empleadoArgs
    deduccionVoluntaria?: boolean | deduccionVoluntariaArgs
  }

  export type escogeGetPayload<
    S extends boolean | null | undefined | escogeArgs,
    U = keyof S
      > = S extends true
        ? escoge
    : S extends undefined
    ? never
    : S extends escogeArgs | escogeFindManyArgs
    ?'include' extends U
    ? escoge  & {
    [P in TrueKeys<S['include']>]:
        P extends 'empleado' ? empleadoGetPayload<S['include'][P]> :
        P extends 'deduccionVoluntaria' ? deduccionVoluntariaGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'empleado' ? empleadoGetPayload<S['select'][P]> :
        P extends 'deduccionVoluntaria' ? deduccionVoluntariaGetPayload<S['select'][P]> :  P extends keyof escoge ? escoge[P] : never
  } 
    : escoge
  : escoge


  type escogeCountArgs = Merge<
    Omit<escogeFindManyArgs, 'select' | 'include'> & {
      select?: EscogeCountAggregateInputType | true
    }
  >

  export interface escogeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Escoge that matches the filter.
     * @param {escogeFindUniqueArgs} args - Arguments to find a Escoge
     * @example
     * // Get one Escoge
     * const escoge = await prisma.escoge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends escogeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, escogeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'escoge'> extends True ? CheckSelect<T, Prisma__escogeClient<escoge>, Prisma__escogeClient<escogeGetPayload<T>>> : CheckSelect<T, Prisma__escogeClient<escoge | null >, Prisma__escogeClient<escogeGetPayload<T> | null >>

    /**
     * Find the first Escoge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escogeFindFirstArgs} args - Arguments to find a Escoge
     * @example
     * // Get one Escoge
     * const escoge = await prisma.escoge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends escogeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, escogeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'escoge'> extends True ? CheckSelect<T, Prisma__escogeClient<escoge>, Prisma__escogeClient<escogeGetPayload<T>>> : CheckSelect<T, Prisma__escogeClient<escoge | null >, Prisma__escogeClient<escogeGetPayload<T> | null >>

    /**
     * Find zero or more Escoges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escogeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escoges
     * const escoges = await prisma.escoge.findMany()
     * 
     * // Get first 10 Escoges
     * const escoges = await prisma.escoge.findMany({ take: 10 })
     * 
     * // Only select the `cedulaEmpleado`
     * const escogeWithCedulaEmpleadoOnly = await prisma.escoge.findMany({ select: { cedulaEmpleado: true } })
     * 
    **/
    findMany<T extends escogeFindManyArgs>(
      args?: SelectSubset<T, escogeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<escoge>>, PrismaPromise<Array<escogeGetPayload<T>>>>

    /**
     * Create a Escoge.
     * @param {escogeCreateArgs} args - Arguments to create a Escoge.
     * @example
     * // Create one Escoge
     * const Escoge = await prisma.escoge.create({
     *   data: {
     *     // ... data to create a Escoge
     *   }
     * })
     * 
    **/
    create<T extends escogeCreateArgs>(
      args: SelectSubset<T, escogeCreateArgs>
    ): CheckSelect<T, Prisma__escogeClient<escoge>, Prisma__escogeClient<escogeGetPayload<T>>>

    /**
     * Create many Escoges.
     *     @param {escogeCreateManyArgs} args - Arguments to create many Escoges.
     *     @example
     *     // Create many Escoges
     *     const escoge = await prisma.escoge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends escogeCreateManyArgs>(
      args?: SelectSubset<T, escogeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Escoge.
     * @param {escogeDeleteArgs} args - Arguments to delete one Escoge.
     * @example
     * // Delete one Escoge
     * const Escoge = await prisma.escoge.delete({
     *   where: {
     *     // ... filter to delete one Escoge
     *   }
     * })
     * 
    **/
    delete<T extends escogeDeleteArgs>(
      args: SelectSubset<T, escogeDeleteArgs>
    ): CheckSelect<T, Prisma__escogeClient<escoge>, Prisma__escogeClient<escogeGetPayload<T>>>

    /**
     * Update one Escoge.
     * @param {escogeUpdateArgs} args - Arguments to update one Escoge.
     * @example
     * // Update one Escoge
     * const escoge = await prisma.escoge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends escogeUpdateArgs>(
      args: SelectSubset<T, escogeUpdateArgs>
    ): CheckSelect<T, Prisma__escogeClient<escoge>, Prisma__escogeClient<escogeGetPayload<T>>>

    /**
     * Delete zero or more Escoges.
     * @param {escogeDeleteManyArgs} args - Arguments to filter Escoges to delete.
     * @example
     * // Delete a few Escoges
     * const { count } = await prisma.escoge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends escogeDeleteManyArgs>(
      args?: SelectSubset<T, escogeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escoges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escogeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escoges
     * const escoge = await prisma.escoge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends escogeUpdateManyArgs>(
      args: SelectSubset<T, escogeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Escoge.
     * @param {escogeUpsertArgs} args - Arguments to update or create a Escoge.
     * @example
     * // Update or create a Escoge
     * const escoge = await prisma.escoge.upsert({
     *   create: {
     *     // ... data to create a Escoge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escoge we want to update
     *   }
     * })
    **/
    upsert<T extends escogeUpsertArgs>(
      args: SelectSubset<T, escogeUpsertArgs>
    ): CheckSelect<T, Prisma__escogeClient<escoge>, Prisma__escogeClient<escogeGetPayload<T>>>

    /**
     * Count the number of Escoges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escogeCountArgs} args - Arguments to filter Escoges to count.
     * @example
     * // Count the number of Escoges
     * const count = await prisma.escoge.count({
     *   where: {
     *     // ... the filter for the Escoges we want to count
     *   }
     * })
    **/
    count<T extends escogeCountArgs>(
      args?: Subset<T, escogeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscogeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escoge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscogeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscogeAggregateArgs>(args: Subset<T, EscogeAggregateArgs>): PrismaPromise<GetEscogeAggregateType<T>>

    /**
     * Group by Escoge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscogeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscogeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscogeGroupByArgs['orderBy'] }
        : { orderBy?: EscogeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscogeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscogeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for escoge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__escogeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empleado<T extends empleadoArgs = {}>(args?: Subset<T, empleadoArgs>): CheckSelect<T, Prisma__empleadoClient<empleado | null >, Prisma__empleadoClient<empleadoGetPayload<T> | null >>;

    deduccionVoluntaria<T extends deduccionVoluntariaArgs = {}>(args?: Subset<T, deduccionVoluntariaArgs>): CheckSelect<T, Prisma__deduccionVoluntariaClient<deduccionVoluntaria | null >, Prisma__deduccionVoluntariaClient<deduccionVoluntariaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * escoge findUnique
   */
  export type escogeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the escoge
     * 
    **/
    select?: escogeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: escogeInclude | null
    /**
     * Throw an Error if a escoge can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which escoge to fetch.
     * 
    **/
    where: escogeWhereUniqueInput
  }


  /**
   * escoge findFirst
   */
  export type escogeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the escoge
     * 
    **/
    select?: escogeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: escogeInclude | null
    /**
     * Throw an Error if a escoge can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which escoge to fetch.
     * 
    **/
    where?: escogeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escoges to fetch.
     * 
    **/
    orderBy?: Enumerable<escogeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escoges.
     * 
    **/
    cursor?: escogeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escoges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escoges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escoges.
     * 
    **/
    distinct?: Enumerable<EscogeScalarFieldEnum>
  }


  /**
   * escoge findMany
   */
  export type escogeFindManyArgs = {
    /**
     * Select specific fields to fetch from the escoge
     * 
    **/
    select?: escogeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: escogeInclude | null
    /**
     * Filter, which escoges to fetch.
     * 
    **/
    where?: escogeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escoges to fetch.
     * 
    **/
    orderBy?: Enumerable<escogeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing escoges.
     * 
    **/
    cursor?: escogeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escoges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escoges.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EscogeScalarFieldEnum>
  }


  /**
   * escoge create
   */
  export type escogeCreateArgs = {
    /**
     * Select specific fields to fetch from the escoge
     * 
    **/
    select?: escogeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: escogeInclude | null
    /**
     * The data needed to create a escoge.
     * 
    **/
    data: XOR<escogeCreateInput, escogeUncheckedCreateInput>
  }


  /**
   * escoge createMany
   */
  export type escogeCreateManyArgs = {
    /**
     * The data used to create many escoges.
     * 
    **/
    data: Enumerable<escogeCreateManyInput>
  }


  /**
   * escoge update
   */
  export type escogeUpdateArgs = {
    /**
     * Select specific fields to fetch from the escoge
     * 
    **/
    select?: escogeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: escogeInclude | null
    /**
     * The data needed to update a escoge.
     * 
    **/
    data: XOR<escogeUpdateInput, escogeUncheckedUpdateInput>
    /**
     * Choose, which escoge to update.
     * 
    **/
    where: escogeWhereUniqueInput
  }


  /**
   * escoge updateMany
   */
  export type escogeUpdateManyArgs = {
    /**
     * The data used to update escoges.
     * 
    **/
    data: XOR<escogeUpdateManyMutationInput, escogeUncheckedUpdateManyInput>
    /**
     * Filter which escoges to update
     * 
    **/
    where?: escogeWhereInput
  }


  /**
   * escoge upsert
   */
  export type escogeUpsertArgs = {
    /**
     * Select specific fields to fetch from the escoge
     * 
    **/
    select?: escogeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: escogeInclude | null
    /**
     * The filter to search for the escoge to update in case it exists.
     * 
    **/
    where: escogeWhereUniqueInput
    /**
     * In case the escoge found by the `where` argument doesn't exist, create a new escoge with this data.
     * 
    **/
    create: XOR<escogeCreateInput, escogeUncheckedCreateInput>
    /**
     * In case the escoge was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<escogeUpdateInput, escogeUncheckedUpdateInput>
  }


  /**
   * escoge delete
   */
  export type escogeDeleteArgs = {
    /**
     * Select specific fields to fetch from the escoge
     * 
    **/
    select?: escogeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: escogeInclude | null
    /**
     * Filter which escoge to delete.
     * 
    **/
    where: escogeWhereUniqueInput
  }


  /**
   * escoge deleteMany
   */
  export type escogeDeleteManyArgs = {
    /**
     * Filter which escoges to delete
     * 
    **/
    where?: escogeWhereInput
  }


  /**
   * escoge without action
   */
  export type escogeArgs = {
    /**
     * Select specific fields to fetch from the escoge
     * 
    **/
    select?: escogeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: escogeInclude | null
  }



  /**
   * Model esContratado
   */


  export type AggregateEsContratado = {
    _count: EsContratadoCountAggregateOutputType | null
    _avg: EsContratadoAvgAggregateOutputType | null
    _sum: EsContratadoSumAggregateOutputType | null
    _min: EsContratadoMinAggregateOutputType | null
    _max: EsContratadoMaxAggregateOutputType | null
  }

  export type EsContratadoAvgAggregateOutputType = {
    salario: number | null
  }

  export type EsContratadoSumAggregateOutputType = {
    salario: number | null
  }

  export type EsContratadoMinAggregateOutputType = {
    cedulaJuridica: string | null
    nombreProyecto: string | null
    cedulaEmpleado: string | null
    tipoEmpleado: string | null
    puesto: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    jornada: string | null
    salario: number | null
  }

  export type EsContratadoMaxAggregateOutputType = {
    cedulaJuridica: string | null
    nombreProyecto: string | null
    cedulaEmpleado: string | null
    tipoEmpleado: string | null
    puesto: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    jornada: string | null
    salario: number | null
  }

  export type EsContratadoCountAggregateOutputType = {
    cedulaJuridica: number
    nombreProyecto: number
    cedulaEmpleado: number
    tipoEmpleado: number
    puesto: number
    fechaInicio: number
    fechaFin: number
    jornada: number
    salario: number
    _all: number
  }


  export type EsContratadoAvgAggregateInputType = {
    salario?: true
  }

  export type EsContratadoSumAggregateInputType = {
    salario?: true
  }

  export type EsContratadoMinAggregateInputType = {
    cedulaJuridica?: true
    nombreProyecto?: true
    cedulaEmpleado?: true
    tipoEmpleado?: true
    puesto?: true
    fechaInicio?: true
    fechaFin?: true
    jornada?: true
    salario?: true
  }

  export type EsContratadoMaxAggregateInputType = {
    cedulaJuridica?: true
    nombreProyecto?: true
    cedulaEmpleado?: true
    tipoEmpleado?: true
    puesto?: true
    fechaInicio?: true
    fechaFin?: true
    jornada?: true
    salario?: true
  }

  export type EsContratadoCountAggregateInputType = {
    cedulaJuridica?: true
    nombreProyecto?: true
    cedulaEmpleado?: true
    tipoEmpleado?: true
    puesto?: true
    fechaInicio?: true
    fechaFin?: true
    jornada?: true
    salario?: true
    _all?: true
  }

  export type EsContratadoAggregateArgs = {
    /**
     * Filter which esContratado to aggregate.
     * 
    **/
    where?: esContratadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of esContratados to fetch.
     * 
    **/
    orderBy?: Enumerable<esContratadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: esContratadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` esContratados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` esContratados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned esContratados
    **/
    _count?: true | EsContratadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EsContratadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EsContratadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EsContratadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EsContratadoMaxAggregateInputType
  }

  export type GetEsContratadoAggregateType<T extends EsContratadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEsContratado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEsContratado[P]>
      : GetScalarType<T[P], AggregateEsContratado[P]>
  }




  export type EsContratadoGroupByArgs = {
    where?: esContratadoWhereInput
    orderBy?: Enumerable<esContratadoOrderByWithAggregationInput>
    by: Array<EsContratadoScalarFieldEnum>
    having?: esContratadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EsContratadoCountAggregateInputType | true
    _avg?: EsContratadoAvgAggregateInputType
    _sum?: EsContratadoSumAggregateInputType
    _min?: EsContratadoMinAggregateInputType
    _max?: EsContratadoMaxAggregateInputType
  }


  export type EsContratadoGroupByOutputType = {
    cedulaJuridica: string
    nombreProyecto: string
    cedulaEmpleado: string
    tipoEmpleado: string | null
    puesto: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    jornada: string | null
    salario: number | null
    _count: EsContratadoCountAggregateOutputType | null
    _avg: EsContratadoAvgAggregateOutputType | null
    _sum: EsContratadoSumAggregateOutputType | null
    _min: EsContratadoMinAggregateOutputType | null
    _max: EsContratadoMaxAggregateOutputType | null
  }

  type GetEsContratadoGroupByPayload<T extends EsContratadoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EsContratadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EsContratadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EsContratadoGroupByOutputType[P]>
            : GetScalarType<T[P], EsContratadoGroupByOutputType[P]>
        }
      >
    >


  export type esContratadoSelect = {
    cedulaJuridica?: boolean
    nombreProyecto?: boolean
    cedulaEmpleado?: boolean
    tipoEmpleado?: boolean
    puesto?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    jornada?: boolean
    salario?: boolean
    empleado?: boolean | empleadoArgs
    proyecto?: boolean | proyectoArgs
  }

  export type esContratadoInclude = {
    empleado?: boolean | empleadoArgs
    proyecto?: boolean | proyectoArgs
  }

  export type esContratadoGetPayload<
    S extends boolean | null | undefined | esContratadoArgs,
    U = keyof S
      > = S extends true
        ? esContratado
    : S extends undefined
    ? never
    : S extends esContratadoArgs | esContratadoFindManyArgs
    ?'include' extends U
    ? esContratado  & {
    [P in TrueKeys<S['include']>]:
        P extends 'empleado' ? empleadoGetPayload<S['include'][P]> :
        P extends 'proyecto' ? proyectoGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'empleado' ? empleadoGetPayload<S['select'][P]> :
        P extends 'proyecto' ? proyectoGetPayload<S['select'][P]> :  P extends keyof esContratado ? esContratado[P] : never
  } 
    : esContratado
  : esContratado


  type esContratadoCountArgs = Merge<
    Omit<esContratadoFindManyArgs, 'select' | 'include'> & {
      select?: EsContratadoCountAggregateInputType | true
    }
  >

  export interface esContratadoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one EsContratado that matches the filter.
     * @param {esContratadoFindUniqueArgs} args - Arguments to find a EsContratado
     * @example
     * // Get one EsContratado
     * const esContratado = await prisma.esContratado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends esContratadoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, esContratadoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'esContratado'> extends True ? CheckSelect<T, Prisma__esContratadoClient<esContratado>, Prisma__esContratadoClient<esContratadoGetPayload<T>>> : CheckSelect<T, Prisma__esContratadoClient<esContratado | null >, Prisma__esContratadoClient<esContratadoGetPayload<T> | null >>

    /**
     * Find the first EsContratado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {esContratadoFindFirstArgs} args - Arguments to find a EsContratado
     * @example
     * // Get one EsContratado
     * const esContratado = await prisma.esContratado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends esContratadoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, esContratadoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'esContratado'> extends True ? CheckSelect<T, Prisma__esContratadoClient<esContratado>, Prisma__esContratadoClient<esContratadoGetPayload<T>>> : CheckSelect<T, Prisma__esContratadoClient<esContratado | null >, Prisma__esContratadoClient<esContratadoGetPayload<T> | null >>

    /**
     * Find zero or more EsContratados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {esContratadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EsContratados
     * const esContratados = await prisma.esContratado.findMany()
     * 
     * // Get first 10 EsContratados
     * const esContratados = await prisma.esContratado.findMany({ take: 10 })
     * 
     * // Only select the `cedulaJuridica`
     * const esContratadoWithCedulaJuridicaOnly = await prisma.esContratado.findMany({ select: { cedulaJuridica: true } })
     * 
    **/
    findMany<T extends esContratadoFindManyArgs>(
      args?: SelectSubset<T, esContratadoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<esContratado>>, PrismaPromise<Array<esContratadoGetPayload<T>>>>

    /**
     * Create a EsContratado.
     * @param {esContratadoCreateArgs} args - Arguments to create a EsContratado.
     * @example
     * // Create one EsContratado
     * const EsContratado = await prisma.esContratado.create({
     *   data: {
     *     // ... data to create a EsContratado
     *   }
     * })
     * 
    **/
    create<T extends esContratadoCreateArgs>(
      args: SelectSubset<T, esContratadoCreateArgs>
    ): CheckSelect<T, Prisma__esContratadoClient<esContratado>, Prisma__esContratadoClient<esContratadoGetPayload<T>>>

    /**
     * Create many EsContratados.
     *     @param {esContratadoCreateManyArgs} args - Arguments to create many EsContratados.
     *     @example
     *     // Create many EsContratados
     *     const esContratado = await prisma.esContratado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends esContratadoCreateManyArgs>(
      args?: SelectSubset<T, esContratadoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EsContratado.
     * @param {esContratadoDeleteArgs} args - Arguments to delete one EsContratado.
     * @example
     * // Delete one EsContratado
     * const EsContratado = await prisma.esContratado.delete({
     *   where: {
     *     // ... filter to delete one EsContratado
     *   }
     * })
     * 
    **/
    delete<T extends esContratadoDeleteArgs>(
      args: SelectSubset<T, esContratadoDeleteArgs>
    ): CheckSelect<T, Prisma__esContratadoClient<esContratado>, Prisma__esContratadoClient<esContratadoGetPayload<T>>>

    /**
     * Update one EsContratado.
     * @param {esContratadoUpdateArgs} args - Arguments to update one EsContratado.
     * @example
     * // Update one EsContratado
     * const esContratado = await prisma.esContratado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends esContratadoUpdateArgs>(
      args: SelectSubset<T, esContratadoUpdateArgs>
    ): CheckSelect<T, Prisma__esContratadoClient<esContratado>, Prisma__esContratadoClient<esContratadoGetPayload<T>>>

    /**
     * Delete zero or more EsContratados.
     * @param {esContratadoDeleteManyArgs} args - Arguments to filter EsContratados to delete.
     * @example
     * // Delete a few EsContratados
     * const { count } = await prisma.esContratado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends esContratadoDeleteManyArgs>(
      args?: SelectSubset<T, esContratadoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EsContratados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {esContratadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EsContratados
     * const esContratado = await prisma.esContratado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends esContratadoUpdateManyArgs>(
      args: SelectSubset<T, esContratadoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EsContratado.
     * @param {esContratadoUpsertArgs} args - Arguments to update or create a EsContratado.
     * @example
     * // Update or create a EsContratado
     * const esContratado = await prisma.esContratado.upsert({
     *   create: {
     *     // ... data to create a EsContratado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EsContratado we want to update
     *   }
     * })
    **/
    upsert<T extends esContratadoUpsertArgs>(
      args: SelectSubset<T, esContratadoUpsertArgs>
    ): CheckSelect<T, Prisma__esContratadoClient<esContratado>, Prisma__esContratadoClient<esContratadoGetPayload<T>>>

    /**
     * Count the number of EsContratados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {esContratadoCountArgs} args - Arguments to filter EsContratados to count.
     * @example
     * // Count the number of EsContratados
     * const count = await prisma.esContratado.count({
     *   where: {
     *     // ... the filter for the EsContratados we want to count
     *   }
     * })
    **/
    count<T extends esContratadoCountArgs>(
      args?: Subset<T, esContratadoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EsContratadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EsContratado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EsContratadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EsContratadoAggregateArgs>(args: Subset<T, EsContratadoAggregateArgs>): PrismaPromise<GetEsContratadoAggregateType<T>>

    /**
     * Group by EsContratado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EsContratadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EsContratadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EsContratadoGroupByArgs['orderBy'] }
        : { orderBy?: EsContratadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EsContratadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEsContratadoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for esContratado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__esContratadoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empleado<T extends empleadoArgs = {}>(args?: Subset<T, empleadoArgs>): CheckSelect<T, Prisma__empleadoClient<empleado | null >, Prisma__empleadoClient<empleadoGetPayload<T> | null >>;

    proyecto<T extends proyectoArgs = {}>(args?: Subset<T, proyectoArgs>): CheckSelect<T, Prisma__proyectoClient<proyecto | null >, Prisma__proyectoClient<proyectoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * esContratado findUnique
   */
  export type esContratadoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the esContratado
     * 
    **/
    select?: esContratadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: esContratadoInclude | null
    /**
     * Throw an Error if a esContratado can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which esContratado to fetch.
     * 
    **/
    where: esContratadoWhereUniqueInput
  }


  /**
   * esContratado findFirst
   */
  export type esContratadoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the esContratado
     * 
    **/
    select?: esContratadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: esContratadoInclude | null
    /**
     * Throw an Error if a esContratado can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which esContratado to fetch.
     * 
    **/
    where?: esContratadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of esContratados to fetch.
     * 
    **/
    orderBy?: Enumerable<esContratadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for esContratados.
     * 
    **/
    cursor?: esContratadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` esContratados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` esContratados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of esContratados.
     * 
    **/
    distinct?: Enumerable<EsContratadoScalarFieldEnum>
  }


  /**
   * esContratado findMany
   */
  export type esContratadoFindManyArgs = {
    /**
     * Select specific fields to fetch from the esContratado
     * 
    **/
    select?: esContratadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: esContratadoInclude | null
    /**
     * Filter, which esContratados to fetch.
     * 
    **/
    where?: esContratadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of esContratados to fetch.
     * 
    **/
    orderBy?: Enumerable<esContratadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing esContratados.
     * 
    **/
    cursor?: esContratadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` esContratados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` esContratados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EsContratadoScalarFieldEnum>
  }


  /**
   * esContratado create
   */
  export type esContratadoCreateArgs = {
    /**
     * Select specific fields to fetch from the esContratado
     * 
    **/
    select?: esContratadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: esContratadoInclude | null
    /**
     * The data needed to create a esContratado.
     * 
    **/
    data: XOR<esContratadoCreateInput, esContratadoUncheckedCreateInput>
  }


  /**
   * esContratado createMany
   */
  export type esContratadoCreateManyArgs = {
    /**
     * The data used to create many esContratados.
     * 
    **/
    data: Enumerable<esContratadoCreateManyInput>
  }


  /**
   * esContratado update
   */
  export type esContratadoUpdateArgs = {
    /**
     * Select specific fields to fetch from the esContratado
     * 
    **/
    select?: esContratadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: esContratadoInclude | null
    /**
     * The data needed to update a esContratado.
     * 
    **/
    data: XOR<esContratadoUpdateInput, esContratadoUncheckedUpdateInput>
    /**
     * Choose, which esContratado to update.
     * 
    **/
    where: esContratadoWhereUniqueInput
  }


  /**
   * esContratado updateMany
   */
  export type esContratadoUpdateManyArgs = {
    /**
     * The data used to update esContratados.
     * 
    **/
    data: XOR<esContratadoUpdateManyMutationInput, esContratadoUncheckedUpdateManyInput>
    /**
     * Filter which esContratados to update
     * 
    **/
    where?: esContratadoWhereInput
  }


  /**
   * esContratado upsert
   */
  export type esContratadoUpsertArgs = {
    /**
     * Select specific fields to fetch from the esContratado
     * 
    **/
    select?: esContratadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: esContratadoInclude | null
    /**
     * The filter to search for the esContratado to update in case it exists.
     * 
    **/
    where: esContratadoWhereUniqueInput
    /**
     * In case the esContratado found by the `where` argument doesn't exist, create a new esContratado with this data.
     * 
    **/
    create: XOR<esContratadoCreateInput, esContratadoUncheckedCreateInput>
    /**
     * In case the esContratado was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<esContratadoUpdateInput, esContratadoUncheckedUpdateInput>
  }


  /**
   * esContratado delete
   */
  export type esContratadoDeleteArgs = {
    /**
     * Select specific fields to fetch from the esContratado
     * 
    **/
    select?: esContratadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: esContratadoInclude | null
    /**
     * Filter which esContratado to delete.
     * 
    **/
    where: esContratadoWhereUniqueInput
  }


  /**
   * esContratado deleteMany
   */
  export type esContratadoDeleteManyArgs = {
    /**
     * Filter which esContratados to delete
     * 
    **/
    where?: esContratadoWhereInput
  }


  /**
   * esContratado without action
   */
  export type esContratadoArgs = {
    /**
     * Select specific fields to fetch from the esContratado
     * 
    **/
    select?: esContratadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: esContratadoInclude | null
  }



  /**
   * Model genera
   */


  export type AggregateGenera = {
    _count: GeneraCountAggregateOutputType | null
    _min: GeneraMinAggregateOutputType | null
    _max: GeneraMaxAggregateOutputType | null
  }

  export type GeneraMinAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
  }

  export type GeneraMaxAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
  }

  export type GeneraCountAggregateOutputType = {
    cedulaEmpleado: number
    fechaHora: number
    cedulaJuridica: number
    nombreProyecto: number
    _all: number
  }


  export type GeneraMinAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    cedulaJuridica?: true
    nombreProyecto?: true
  }

  export type GeneraMaxAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    cedulaJuridica?: true
    nombreProyecto?: true
  }

  export type GeneraCountAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    _all?: true
  }

  export type GeneraAggregateArgs = {
    /**
     * Filter which genera to aggregate.
     * 
    **/
    where?: generaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genera to fetch.
     * 
    **/
    orderBy?: Enumerable<generaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: generaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genera from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genera.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned genera
    **/
    _count?: true | GeneraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneraMaxAggregateInputType
  }

  export type GetGeneraAggregateType<T extends GeneraAggregateArgs> = {
        [P in keyof T & keyof AggregateGenera]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenera[P]>
      : GetScalarType<T[P], AggregateGenera[P]>
  }




  export type GeneraGroupByArgs = {
    where?: generaWhereInput
    orderBy?: Enumerable<generaOrderByWithAggregationInput>
    by: Array<GeneraScalarFieldEnum>
    having?: generaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneraCountAggregateInputType | true
    _min?: GeneraMinAggregateInputType
    _max?: GeneraMaxAggregateInputType
  }


  export type GeneraGroupByOutputType = {
    cedulaEmpleado: string
    fechaHora: Date
    cedulaJuridica: string
    nombreProyecto: string
    _count: GeneraCountAggregateOutputType | null
    _min: GeneraMinAggregateOutputType | null
    _max: GeneraMaxAggregateOutputType | null
  }

  type GetGeneraGroupByPayload<T extends GeneraGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GeneraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneraGroupByOutputType[P]>
            : GetScalarType<T[P], GeneraGroupByOutputType[P]>
        }
      >
    >


  export type generaSelect = {
    cedulaEmpleado?: boolean
    fechaHora?: boolean
    cedulaJuridica?: boolean
    nombreProyecto?: boolean
    pago?: boolean | pagoArgs
    proyecto?: boolean | proyectoArgs
  }

  export type generaInclude = {
    pago?: boolean | pagoArgs
    proyecto?: boolean | proyectoArgs
  }

  export type generaGetPayload<
    S extends boolean | null | undefined | generaArgs,
    U = keyof S
      > = S extends true
        ? genera
    : S extends undefined
    ? never
    : S extends generaArgs | generaFindManyArgs
    ?'include' extends U
    ? genera  & {
    [P in TrueKeys<S['include']>]:
        P extends 'pago' ? pagoGetPayload<S['include'][P]> :
        P extends 'proyecto' ? proyectoGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'pago' ? pagoGetPayload<S['select'][P]> :
        P extends 'proyecto' ? proyectoGetPayload<S['select'][P]> :  P extends keyof genera ? genera[P] : never
  } 
    : genera
  : genera


  type generaCountArgs = Merge<
    Omit<generaFindManyArgs, 'select' | 'include'> & {
      select?: GeneraCountAggregateInputType | true
    }
  >

  export interface generaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Genera that matches the filter.
     * @param {generaFindUniqueArgs} args - Arguments to find a Genera
     * @example
     * // Get one Genera
     * const genera = await prisma.genera.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends generaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, generaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'genera'> extends True ? CheckSelect<T, Prisma__generaClient<genera>, Prisma__generaClient<generaGetPayload<T>>> : CheckSelect<T, Prisma__generaClient<genera | null >, Prisma__generaClient<generaGetPayload<T> | null >>

    /**
     * Find the first Genera that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaFindFirstArgs} args - Arguments to find a Genera
     * @example
     * // Get one Genera
     * const genera = await prisma.genera.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends generaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, generaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'genera'> extends True ? CheckSelect<T, Prisma__generaClient<genera>, Prisma__generaClient<generaGetPayload<T>>> : CheckSelect<T, Prisma__generaClient<genera | null >, Prisma__generaClient<generaGetPayload<T> | null >>

    /**
     * Find zero or more Genera that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genera
     * const genera = await prisma.genera.findMany()
     * 
     * // Get first 10 Genera
     * const genera = await prisma.genera.findMany({ take: 10 })
     * 
     * // Only select the `cedulaEmpleado`
     * const generaWithCedulaEmpleadoOnly = await prisma.genera.findMany({ select: { cedulaEmpleado: true } })
     * 
    **/
    findMany<T extends generaFindManyArgs>(
      args?: SelectSubset<T, generaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<genera>>, PrismaPromise<Array<generaGetPayload<T>>>>

    /**
     * Create a Genera.
     * @param {generaCreateArgs} args - Arguments to create a Genera.
     * @example
     * // Create one Genera
     * const Genera = await prisma.genera.create({
     *   data: {
     *     // ... data to create a Genera
     *   }
     * })
     * 
    **/
    create<T extends generaCreateArgs>(
      args: SelectSubset<T, generaCreateArgs>
    ): CheckSelect<T, Prisma__generaClient<genera>, Prisma__generaClient<generaGetPayload<T>>>

    /**
     * Create many Genera.
     *     @param {generaCreateManyArgs} args - Arguments to create many Genera.
     *     @example
     *     // Create many Genera
     *     const genera = await prisma.genera.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends generaCreateManyArgs>(
      args?: SelectSubset<T, generaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Genera.
     * @param {generaDeleteArgs} args - Arguments to delete one Genera.
     * @example
     * // Delete one Genera
     * const Genera = await prisma.genera.delete({
     *   where: {
     *     // ... filter to delete one Genera
     *   }
     * })
     * 
    **/
    delete<T extends generaDeleteArgs>(
      args: SelectSubset<T, generaDeleteArgs>
    ): CheckSelect<T, Prisma__generaClient<genera>, Prisma__generaClient<generaGetPayload<T>>>

    /**
     * Update one Genera.
     * @param {generaUpdateArgs} args - Arguments to update one Genera.
     * @example
     * // Update one Genera
     * const genera = await prisma.genera.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends generaUpdateArgs>(
      args: SelectSubset<T, generaUpdateArgs>
    ): CheckSelect<T, Prisma__generaClient<genera>, Prisma__generaClient<generaGetPayload<T>>>

    /**
     * Delete zero or more Genera.
     * @param {generaDeleteManyArgs} args - Arguments to filter Genera to delete.
     * @example
     * // Delete a few Genera
     * const { count } = await prisma.genera.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends generaDeleteManyArgs>(
      args?: SelectSubset<T, generaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genera
     * const genera = await prisma.genera.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends generaUpdateManyArgs>(
      args: SelectSubset<T, generaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Genera.
     * @param {generaUpsertArgs} args - Arguments to update or create a Genera.
     * @example
     * // Update or create a Genera
     * const genera = await prisma.genera.upsert({
     *   create: {
     *     // ... data to create a Genera
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genera we want to update
     *   }
     * })
    **/
    upsert<T extends generaUpsertArgs>(
      args: SelectSubset<T, generaUpsertArgs>
    ): CheckSelect<T, Prisma__generaClient<genera>, Prisma__generaClient<generaGetPayload<T>>>

    /**
     * Count the number of Genera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generaCountArgs} args - Arguments to filter Genera to count.
     * @example
     * // Count the number of Genera
     * const count = await prisma.genera.count({
     *   where: {
     *     // ... the filter for the Genera we want to count
     *   }
     * })
    **/
    count<T extends generaCountArgs>(
      args?: Subset<T, generaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneraAggregateArgs>(args: Subset<T, GeneraAggregateArgs>): PrismaPromise<GetGeneraAggregateType<T>>

    /**
     * Group by Genera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneraGroupByArgs['orderBy'] }
        : { orderBy?: GeneraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneraGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for genera.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__generaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pago<T extends pagoArgs = {}>(args?: Subset<T, pagoArgs>): CheckSelect<T, Prisma__pagoClient<pago | null >, Prisma__pagoClient<pagoGetPayload<T> | null >>;

    proyecto<T extends proyectoArgs = {}>(args?: Subset<T, proyectoArgs>): CheckSelect<T, Prisma__proyectoClient<proyecto | null >, Prisma__proyectoClient<proyectoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * genera findUnique
   */
  export type generaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the genera
     * 
    **/
    select?: generaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: generaInclude | null
    /**
     * Throw an Error if a genera can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which genera to fetch.
     * 
    **/
    where: generaWhereUniqueInput
  }


  /**
   * genera findFirst
   */
  export type generaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the genera
     * 
    **/
    select?: generaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: generaInclude | null
    /**
     * Throw an Error if a genera can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which genera to fetch.
     * 
    **/
    where?: generaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genera to fetch.
     * 
    **/
    orderBy?: Enumerable<generaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genera.
     * 
    **/
    cursor?: generaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genera from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genera.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genera.
     * 
    **/
    distinct?: Enumerable<GeneraScalarFieldEnum>
  }


  /**
   * genera findMany
   */
  export type generaFindManyArgs = {
    /**
     * Select specific fields to fetch from the genera
     * 
    **/
    select?: generaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: generaInclude | null
    /**
     * Filter, which genera to fetch.
     * 
    **/
    where?: generaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genera to fetch.
     * 
    **/
    orderBy?: Enumerable<generaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing genera.
     * 
    **/
    cursor?: generaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genera from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genera.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GeneraScalarFieldEnum>
  }


  /**
   * genera create
   */
  export type generaCreateArgs = {
    /**
     * Select specific fields to fetch from the genera
     * 
    **/
    select?: generaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: generaInclude | null
    /**
     * The data needed to create a genera.
     * 
    **/
    data: XOR<generaCreateInput, generaUncheckedCreateInput>
  }


  /**
   * genera createMany
   */
  export type generaCreateManyArgs = {
    /**
     * The data used to create many genera.
     * 
    **/
    data: Enumerable<generaCreateManyInput>
  }


  /**
   * genera update
   */
  export type generaUpdateArgs = {
    /**
     * Select specific fields to fetch from the genera
     * 
    **/
    select?: generaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: generaInclude | null
    /**
     * The data needed to update a genera.
     * 
    **/
    data: XOR<generaUpdateInput, generaUncheckedUpdateInput>
    /**
     * Choose, which genera to update.
     * 
    **/
    where: generaWhereUniqueInput
  }


  /**
   * genera updateMany
   */
  export type generaUpdateManyArgs = {
    /**
     * The data used to update genera.
     * 
    **/
    data: XOR<generaUpdateManyMutationInput, generaUncheckedUpdateManyInput>
    /**
     * Filter which genera to update
     * 
    **/
    where?: generaWhereInput
  }


  /**
   * genera upsert
   */
  export type generaUpsertArgs = {
    /**
     * Select specific fields to fetch from the genera
     * 
    **/
    select?: generaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: generaInclude | null
    /**
     * The filter to search for the genera to update in case it exists.
     * 
    **/
    where: generaWhereUniqueInput
    /**
     * In case the genera found by the `where` argument doesn't exist, create a new genera with this data.
     * 
    **/
    create: XOR<generaCreateInput, generaUncheckedCreateInput>
    /**
     * In case the genera was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<generaUpdateInput, generaUncheckedUpdateInput>
  }


  /**
   * genera delete
   */
  export type generaDeleteArgs = {
    /**
     * Select specific fields to fetch from the genera
     * 
    **/
    select?: generaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: generaInclude | null
    /**
     * Filter which genera to delete.
     * 
    **/
    where: generaWhereUniqueInput
  }


  /**
   * genera deleteMany
   */
  export type generaDeleteManyArgs = {
    /**
     * Filter which genera to delete
     * 
    **/
    where?: generaWhereInput
  }


  /**
   * genera without action
   */
  export type generaArgs = {
    /**
     * Select specific fields to fetch from the genera
     * 
    **/
    select?: generaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: generaInclude | null
  }



  /**
   * Model hace_uso
   */


  export type AggregateHace_uso = {
    _count: Hace_usoCountAggregateOutputType | null
    _min: Hace_usoMinAggregateOutputType | null
    _max: Hace_usoMaxAggregateOutputType | null
  }

  export type Hace_usoMinAggregateOutputType = {
    cedula: string | null
    email: string | null
  }

  export type Hace_usoMaxAggregateOutputType = {
    cedula: string | null
    email: string | null
  }

  export type Hace_usoCountAggregateOutputType = {
    cedula: number
    email: number
    _all: number
  }


  export type Hace_usoMinAggregateInputType = {
    cedula?: true
    email?: true
  }

  export type Hace_usoMaxAggregateInputType = {
    cedula?: true
    email?: true
  }

  export type Hace_usoCountAggregateInputType = {
    cedula?: true
    email?: true
    _all?: true
  }

  export type Hace_usoAggregateArgs = {
    /**
     * Filter which hace_uso to aggregate.
     * 
    **/
    where?: hace_usoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hace_usos to fetch.
     * 
    **/
    orderBy?: Enumerable<hace_usoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: hace_usoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hace_usos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hace_usos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hace_usos
    **/
    _count?: true | Hace_usoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hace_usoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hace_usoMaxAggregateInputType
  }

  export type GetHace_usoAggregateType<T extends Hace_usoAggregateArgs> = {
        [P in keyof T & keyof AggregateHace_uso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHace_uso[P]>
      : GetScalarType<T[P], AggregateHace_uso[P]>
  }




  export type Hace_usoGroupByArgs = {
    where?: hace_usoWhereInput
    orderBy?: Enumerable<hace_usoOrderByWithAggregationInput>
    by: Array<Hace_usoScalarFieldEnum>
    having?: hace_usoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hace_usoCountAggregateInputType | true
    _min?: Hace_usoMinAggregateInputType
    _max?: Hace_usoMaxAggregateInputType
  }


  export type Hace_usoGroupByOutputType = {
    cedula: string
    email: string
    _count: Hace_usoCountAggregateOutputType | null
    _min: Hace_usoMinAggregateOutputType | null
    _max: Hace_usoMaxAggregateOutputType | null
  }

  type GetHace_usoGroupByPayload<T extends Hace_usoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Hace_usoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hace_usoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hace_usoGroupByOutputType[P]>
            : GetScalarType<T[P], Hace_usoGroupByOutputType[P]>
        }
      >
    >


  export type hace_usoSelect = {
    cedula?: boolean
    email?: boolean
    persona?: boolean | personaArgs
    credenciales?: boolean | credencialesArgs
  }

  export type hace_usoInclude = {
    persona?: boolean | personaArgs
    credenciales?: boolean | credencialesArgs
  }

  export type hace_usoGetPayload<
    S extends boolean | null | undefined | hace_usoArgs,
    U = keyof S
      > = S extends true
        ? hace_uso
    : S extends undefined
    ? never
    : S extends hace_usoArgs | hace_usoFindManyArgs
    ?'include' extends U
    ? hace_uso  & {
    [P in TrueKeys<S['include']>]:
        P extends 'persona' ? personaGetPayload<S['include'][P]> :
        P extends 'credenciales' ? credencialesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'persona' ? personaGetPayload<S['select'][P]> :
        P extends 'credenciales' ? credencialesGetPayload<S['select'][P]> :  P extends keyof hace_uso ? hace_uso[P] : never
  } 
    : hace_uso
  : hace_uso


  type hace_usoCountArgs = Merge<
    Omit<hace_usoFindManyArgs, 'select' | 'include'> & {
      select?: Hace_usoCountAggregateInputType | true
    }
  >

  export interface hace_usoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Hace_uso that matches the filter.
     * @param {hace_usoFindUniqueArgs} args - Arguments to find a Hace_uso
     * @example
     * // Get one Hace_uso
     * const hace_uso = await prisma.hace_uso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends hace_usoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, hace_usoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'hace_uso'> extends True ? CheckSelect<T, Prisma__hace_usoClient<hace_uso>, Prisma__hace_usoClient<hace_usoGetPayload<T>>> : CheckSelect<T, Prisma__hace_usoClient<hace_uso | null >, Prisma__hace_usoClient<hace_usoGetPayload<T> | null >>

    /**
     * Find the first Hace_uso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hace_usoFindFirstArgs} args - Arguments to find a Hace_uso
     * @example
     * // Get one Hace_uso
     * const hace_uso = await prisma.hace_uso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends hace_usoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, hace_usoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'hace_uso'> extends True ? CheckSelect<T, Prisma__hace_usoClient<hace_uso>, Prisma__hace_usoClient<hace_usoGetPayload<T>>> : CheckSelect<T, Prisma__hace_usoClient<hace_uso | null >, Prisma__hace_usoClient<hace_usoGetPayload<T> | null >>

    /**
     * Find zero or more Hace_usos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hace_usoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hace_usos
     * const hace_usos = await prisma.hace_uso.findMany()
     * 
     * // Get first 10 Hace_usos
     * const hace_usos = await prisma.hace_uso.findMany({ take: 10 })
     * 
     * // Only select the `cedula`
     * const hace_usoWithCedulaOnly = await prisma.hace_uso.findMany({ select: { cedula: true } })
     * 
    **/
    findMany<T extends hace_usoFindManyArgs>(
      args?: SelectSubset<T, hace_usoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<hace_uso>>, PrismaPromise<Array<hace_usoGetPayload<T>>>>

    /**
     * Create a Hace_uso.
     * @param {hace_usoCreateArgs} args - Arguments to create a Hace_uso.
     * @example
     * // Create one Hace_uso
     * const Hace_uso = await prisma.hace_uso.create({
     *   data: {
     *     // ... data to create a Hace_uso
     *   }
     * })
     * 
    **/
    create<T extends hace_usoCreateArgs>(
      args: SelectSubset<T, hace_usoCreateArgs>
    ): CheckSelect<T, Prisma__hace_usoClient<hace_uso>, Prisma__hace_usoClient<hace_usoGetPayload<T>>>

    /**
     * Create many Hace_usos.
     *     @param {hace_usoCreateManyArgs} args - Arguments to create many Hace_usos.
     *     @example
     *     // Create many Hace_usos
     *     const hace_uso = await prisma.hace_uso.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends hace_usoCreateManyArgs>(
      args?: SelectSubset<T, hace_usoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Hace_uso.
     * @param {hace_usoDeleteArgs} args - Arguments to delete one Hace_uso.
     * @example
     * // Delete one Hace_uso
     * const Hace_uso = await prisma.hace_uso.delete({
     *   where: {
     *     // ... filter to delete one Hace_uso
     *   }
     * })
     * 
    **/
    delete<T extends hace_usoDeleteArgs>(
      args: SelectSubset<T, hace_usoDeleteArgs>
    ): CheckSelect<T, Prisma__hace_usoClient<hace_uso>, Prisma__hace_usoClient<hace_usoGetPayload<T>>>

    /**
     * Update one Hace_uso.
     * @param {hace_usoUpdateArgs} args - Arguments to update one Hace_uso.
     * @example
     * // Update one Hace_uso
     * const hace_uso = await prisma.hace_uso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends hace_usoUpdateArgs>(
      args: SelectSubset<T, hace_usoUpdateArgs>
    ): CheckSelect<T, Prisma__hace_usoClient<hace_uso>, Prisma__hace_usoClient<hace_usoGetPayload<T>>>

    /**
     * Delete zero or more Hace_usos.
     * @param {hace_usoDeleteManyArgs} args - Arguments to filter Hace_usos to delete.
     * @example
     * // Delete a few Hace_usos
     * const { count } = await prisma.hace_uso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends hace_usoDeleteManyArgs>(
      args?: SelectSubset<T, hace_usoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hace_usos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hace_usoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hace_usos
     * const hace_uso = await prisma.hace_uso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends hace_usoUpdateManyArgs>(
      args: SelectSubset<T, hace_usoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Hace_uso.
     * @param {hace_usoUpsertArgs} args - Arguments to update or create a Hace_uso.
     * @example
     * // Update or create a Hace_uso
     * const hace_uso = await prisma.hace_uso.upsert({
     *   create: {
     *     // ... data to create a Hace_uso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hace_uso we want to update
     *   }
     * })
    **/
    upsert<T extends hace_usoUpsertArgs>(
      args: SelectSubset<T, hace_usoUpsertArgs>
    ): CheckSelect<T, Prisma__hace_usoClient<hace_uso>, Prisma__hace_usoClient<hace_usoGetPayload<T>>>

    /**
     * Count the number of Hace_usos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hace_usoCountArgs} args - Arguments to filter Hace_usos to count.
     * @example
     * // Count the number of Hace_usos
     * const count = await prisma.hace_uso.count({
     *   where: {
     *     // ... the filter for the Hace_usos we want to count
     *   }
     * })
    **/
    count<T extends hace_usoCountArgs>(
      args?: Subset<T, hace_usoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hace_usoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hace_uso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hace_usoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hace_usoAggregateArgs>(args: Subset<T, Hace_usoAggregateArgs>): PrismaPromise<GetHace_usoAggregateType<T>>

    /**
     * Group by Hace_uso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hace_usoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Hace_usoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Hace_usoGroupByArgs['orderBy'] }
        : { orderBy?: Hace_usoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Hace_usoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHace_usoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for hace_uso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__hace_usoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    persona<T extends personaArgs = {}>(args?: Subset<T, personaArgs>): CheckSelect<T, Prisma__personaClient<persona | null >, Prisma__personaClient<personaGetPayload<T> | null >>;

    credenciales<T extends credencialesArgs = {}>(args?: Subset<T, credencialesArgs>): CheckSelect<T, Prisma__credencialesClient<credenciales | null >, Prisma__credencialesClient<credencialesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * hace_uso findUnique
   */
  export type hace_usoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the hace_uso
     * 
    **/
    select?: hace_usoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: hace_usoInclude | null
    /**
     * Throw an Error if a hace_uso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which hace_uso to fetch.
     * 
    **/
    where: hace_usoWhereUniqueInput
  }


  /**
   * hace_uso findFirst
   */
  export type hace_usoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the hace_uso
     * 
    **/
    select?: hace_usoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: hace_usoInclude | null
    /**
     * Throw an Error if a hace_uso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which hace_uso to fetch.
     * 
    **/
    where?: hace_usoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hace_usos to fetch.
     * 
    **/
    orderBy?: Enumerable<hace_usoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hace_usos.
     * 
    **/
    cursor?: hace_usoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hace_usos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hace_usos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hace_usos.
     * 
    **/
    distinct?: Enumerable<Hace_usoScalarFieldEnum>
  }


  /**
   * hace_uso findMany
   */
  export type hace_usoFindManyArgs = {
    /**
     * Select specific fields to fetch from the hace_uso
     * 
    **/
    select?: hace_usoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: hace_usoInclude | null
    /**
     * Filter, which hace_usos to fetch.
     * 
    **/
    where?: hace_usoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hace_usos to fetch.
     * 
    **/
    orderBy?: Enumerable<hace_usoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hace_usos.
     * 
    **/
    cursor?: hace_usoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hace_usos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hace_usos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Hace_usoScalarFieldEnum>
  }


  /**
   * hace_uso create
   */
  export type hace_usoCreateArgs = {
    /**
     * Select specific fields to fetch from the hace_uso
     * 
    **/
    select?: hace_usoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: hace_usoInclude | null
    /**
     * The data needed to create a hace_uso.
     * 
    **/
    data: XOR<hace_usoCreateInput, hace_usoUncheckedCreateInput>
  }


  /**
   * hace_uso createMany
   */
  export type hace_usoCreateManyArgs = {
    /**
     * The data used to create many hace_usos.
     * 
    **/
    data: Enumerable<hace_usoCreateManyInput>
  }


  /**
   * hace_uso update
   */
  export type hace_usoUpdateArgs = {
    /**
     * Select specific fields to fetch from the hace_uso
     * 
    **/
    select?: hace_usoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: hace_usoInclude | null
    /**
     * The data needed to update a hace_uso.
     * 
    **/
    data: XOR<hace_usoUpdateInput, hace_usoUncheckedUpdateInput>
    /**
     * Choose, which hace_uso to update.
     * 
    **/
    where: hace_usoWhereUniqueInput
  }


  /**
   * hace_uso updateMany
   */
  export type hace_usoUpdateManyArgs = {
    /**
     * The data used to update hace_usos.
     * 
    **/
    data: XOR<hace_usoUpdateManyMutationInput, hace_usoUncheckedUpdateManyInput>
    /**
     * Filter which hace_usos to update
     * 
    **/
    where?: hace_usoWhereInput
  }


  /**
   * hace_uso upsert
   */
  export type hace_usoUpsertArgs = {
    /**
     * Select specific fields to fetch from the hace_uso
     * 
    **/
    select?: hace_usoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: hace_usoInclude | null
    /**
     * The filter to search for the hace_uso to update in case it exists.
     * 
    **/
    where: hace_usoWhereUniqueInput
    /**
     * In case the hace_uso found by the `where` argument doesn't exist, create a new hace_uso with this data.
     * 
    **/
    create: XOR<hace_usoCreateInput, hace_usoUncheckedCreateInput>
    /**
     * In case the hace_uso was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<hace_usoUpdateInput, hace_usoUncheckedUpdateInput>
  }


  /**
   * hace_uso delete
   */
  export type hace_usoDeleteArgs = {
    /**
     * Select specific fields to fetch from the hace_uso
     * 
    **/
    select?: hace_usoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: hace_usoInclude | null
    /**
     * Filter which hace_uso to delete.
     * 
    **/
    where: hace_usoWhereUniqueInput
  }


  /**
   * hace_uso deleteMany
   */
  export type hace_usoDeleteManyArgs = {
    /**
     * Filter which hace_usos to delete
     * 
    **/
    where?: hace_usoWhereInput
  }


  /**
   * hace_uso without action
   */
  export type hace_usoArgs = {
    /**
     * Select specific fields to fetch from the hace_uso
     * 
    **/
    select?: hace_usoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: hace_usoInclude | null
  }



  /**
   * Model pago
   */


  export type AggregatePago = {
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  export type PagoAvgAggregateOutputType = {
    salarioBruto: number | null
    salarioNeto: number | null
  }

  export type PagoSumAggregateOutputType = {
    salarioBruto: number | null
    salarioNeto: number | null
  }

  export type PagoMinAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    deduccionesEmpleado: string | null
    deduccionesPatrono: string | null
    salarioBruto: number | null
    beneficios: string | null
    salarioNeto: number | null
    deduccionesVoluntarias: string | null
  }

  export type PagoMaxAggregateOutputType = {
    cedulaEmpleado: string | null
    fechaHora: Date | null
    deduccionesEmpleado: string | null
    deduccionesPatrono: string | null
    salarioBruto: number | null
    beneficios: string | null
    salarioNeto: number | null
    deduccionesVoluntarias: string | null
  }

  export type PagoCountAggregateOutputType = {
    cedulaEmpleado: number
    fechaHora: number
    deduccionesEmpleado: number
    deduccionesPatrono: number
    salarioBruto: number
    beneficios: number
    salarioNeto: number
    deduccionesVoluntarias: number
    _all: number
  }


  export type PagoAvgAggregateInputType = {
    salarioBruto?: true
    salarioNeto?: true
  }

  export type PagoSumAggregateInputType = {
    salarioBruto?: true
    salarioNeto?: true
  }

  export type PagoMinAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    deduccionesEmpleado?: true
    deduccionesPatrono?: true
    salarioBruto?: true
    beneficios?: true
    salarioNeto?: true
    deduccionesVoluntarias?: true
  }

  export type PagoMaxAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    deduccionesEmpleado?: true
    deduccionesPatrono?: true
    salarioBruto?: true
    beneficios?: true
    salarioNeto?: true
    deduccionesVoluntarias?: true
  }

  export type PagoCountAggregateInputType = {
    cedulaEmpleado?: true
    fechaHora?: true
    deduccionesEmpleado?: true
    deduccionesPatrono?: true
    salarioBruto?: true
    beneficios?: true
    salarioNeto?: true
    deduccionesVoluntarias?: true
    _all?: true
  }

  export type PagoAggregateArgs = {
    /**
     * Filter which pago to aggregate.
     * 
    **/
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     * 
    **/
    orderBy?: Enumerable<pagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pagos
    **/
    _count?: true | PagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoMaxAggregateInputType
  }

  export type GetPagoAggregateType<T extends PagoAggregateArgs> = {
        [P in keyof T & keyof AggregatePago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePago[P]>
      : GetScalarType<T[P], AggregatePago[P]>
  }




  export type PagoGroupByArgs = {
    where?: pagoWhereInput
    orderBy?: Enumerable<pagoOrderByWithAggregationInput>
    by: Array<PagoScalarFieldEnum>
    having?: pagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoCountAggregateInputType | true
    _avg?: PagoAvgAggregateInputType
    _sum?: PagoSumAggregateInputType
    _min?: PagoMinAggregateInputType
    _max?: PagoMaxAggregateInputType
  }


  export type PagoGroupByOutputType = {
    cedulaEmpleado: string
    fechaHora: Date
    deduccionesEmpleado: string | null
    deduccionesPatrono: string | null
    salarioBruto: number | null
    beneficios: string | null
    salarioNeto: number | null
    deduccionesVoluntarias: string | null
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  type GetPagoGroupByPayload<T extends PagoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoGroupByOutputType[P]>
            : GetScalarType<T[P], PagoGroupByOutputType[P]>
        }
      >
    >


  export type pagoSelect = {
    cedulaEmpleado?: boolean
    fechaHora?: boolean
    deduccionesEmpleado?: boolean
    deduccionesPatrono?: boolean
    salarioBruto?: boolean
    beneficios?: boolean
    salarioNeto?: boolean
    deduccionesVoluntarias?: boolean
    empleado?: boolean | empleadoArgs
    aplica_b?: boolean | aplica_bFindManyArgs
    aplica_do?: boolean | aplica_doFindManyArgs
    aplica_dv?: boolean | aplica_dvFindManyArgs
    genera?: boolean | generaFindManyArgs
    _count?: boolean | PagoCountOutputTypeArgs
  }

  export type pagoInclude = {
    empleado?: boolean | empleadoArgs
    aplica_b?: boolean | aplica_bFindManyArgs
    aplica_do?: boolean | aplica_doFindManyArgs
    aplica_dv?: boolean | aplica_dvFindManyArgs
    genera?: boolean | generaFindManyArgs
    _count?: boolean | PagoCountOutputTypeArgs
  }

  export type pagoGetPayload<
    S extends boolean | null | undefined | pagoArgs,
    U = keyof S
      > = S extends true
        ? pago
    : S extends undefined
    ? never
    : S extends pagoArgs | pagoFindManyArgs
    ?'include' extends U
    ? pago  & {
    [P in TrueKeys<S['include']>]:
        P extends 'empleado' ? empleadoGetPayload<S['include'][P]> :
        P extends 'aplica_b' ? Array < aplica_bGetPayload<S['include'][P]>>  :
        P extends 'aplica_do' ? Array < aplica_doGetPayload<S['include'][P]>>  :
        P extends 'aplica_dv' ? Array < aplica_dvGetPayload<S['include'][P]>>  :
        P extends 'genera' ? Array < generaGetPayload<S['include'][P]>>  :
        P extends '_count' ? PagoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'empleado' ? empleadoGetPayload<S['select'][P]> :
        P extends 'aplica_b' ? Array < aplica_bGetPayload<S['select'][P]>>  :
        P extends 'aplica_do' ? Array < aplica_doGetPayload<S['select'][P]>>  :
        P extends 'aplica_dv' ? Array < aplica_dvGetPayload<S['select'][P]>>  :
        P extends 'genera' ? Array < generaGetPayload<S['select'][P]>>  :
        P extends '_count' ? PagoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof pago ? pago[P] : never
  } 
    : pago
  : pago


  type pagoCountArgs = Merge<
    Omit<pagoFindManyArgs, 'select' | 'include'> & {
      select?: PagoCountAggregateInputType | true
    }
  >

  export interface pagoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Pago that matches the filter.
     * @param {pagoFindUniqueArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pagoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pagoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pago'> extends True ? CheckSelect<T, Prisma__pagoClient<pago>, Prisma__pagoClient<pagoGetPayload<T>>> : CheckSelect<T, Prisma__pagoClient<pago | null >, Prisma__pagoClient<pagoGetPayload<T> | null >>

    /**
     * Find the first Pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoFindFirstArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pagoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pagoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pago'> extends True ? CheckSelect<T, Prisma__pagoClient<pago>, Prisma__pagoClient<pagoGetPayload<T>>> : CheckSelect<T, Prisma__pagoClient<pago | null >, Prisma__pagoClient<pagoGetPayload<T> | null >>

    /**
     * Find zero or more Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagos
     * const pagos = await prisma.pago.findMany()
     * 
     * // Get first 10 Pagos
     * const pagos = await prisma.pago.findMany({ take: 10 })
     * 
     * // Only select the `cedulaEmpleado`
     * const pagoWithCedulaEmpleadoOnly = await prisma.pago.findMany({ select: { cedulaEmpleado: true } })
     * 
    **/
    findMany<T extends pagoFindManyArgs>(
      args?: SelectSubset<T, pagoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<pago>>, PrismaPromise<Array<pagoGetPayload<T>>>>

    /**
     * Create a Pago.
     * @param {pagoCreateArgs} args - Arguments to create a Pago.
     * @example
     * // Create one Pago
     * const Pago = await prisma.pago.create({
     *   data: {
     *     // ... data to create a Pago
     *   }
     * })
     * 
    **/
    create<T extends pagoCreateArgs>(
      args: SelectSubset<T, pagoCreateArgs>
    ): CheckSelect<T, Prisma__pagoClient<pago>, Prisma__pagoClient<pagoGetPayload<T>>>

    /**
     * Create many Pagos.
     *     @param {pagoCreateManyArgs} args - Arguments to create many Pagos.
     *     @example
     *     // Create many Pagos
     *     const pago = await prisma.pago.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pagoCreateManyArgs>(
      args?: SelectSubset<T, pagoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pago.
     * @param {pagoDeleteArgs} args - Arguments to delete one Pago.
     * @example
     * // Delete one Pago
     * const Pago = await prisma.pago.delete({
     *   where: {
     *     // ... filter to delete one Pago
     *   }
     * })
     * 
    **/
    delete<T extends pagoDeleteArgs>(
      args: SelectSubset<T, pagoDeleteArgs>
    ): CheckSelect<T, Prisma__pagoClient<pago>, Prisma__pagoClient<pagoGetPayload<T>>>

    /**
     * Update one Pago.
     * @param {pagoUpdateArgs} args - Arguments to update one Pago.
     * @example
     * // Update one Pago
     * const pago = await prisma.pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pagoUpdateArgs>(
      args: SelectSubset<T, pagoUpdateArgs>
    ): CheckSelect<T, Prisma__pagoClient<pago>, Prisma__pagoClient<pagoGetPayload<T>>>

    /**
     * Delete zero or more Pagos.
     * @param {pagoDeleteManyArgs} args - Arguments to filter Pagos to delete.
     * @example
     * // Delete a few Pagos
     * const { count } = await prisma.pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pagoDeleteManyArgs>(
      args?: SelectSubset<T, pagoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pagoUpdateManyArgs>(
      args: SelectSubset<T, pagoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pago.
     * @param {pagoUpsertArgs} args - Arguments to update or create a Pago.
     * @example
     * // Update or create a Pago
     * const pago = await prisma.pago.upsert({
     *   create: {
     *     // ... data to create a Pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pago we want to update
     *   }
     * })
    **/
    upsert<T extends pagoUpsertArgs>(
      args: SelectSubset<T, pagoUpsertArgs>
    ): CheckSelect<T, Prisma__pagoClient<pago>, Prisma__pagoClient<pagoGetPayload<T>>>

    /**
     * Count the number of Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagoCountArgs} args - Arguments to filter Pagos to count.
     * @example
     * // Count the number of Pagos
     * const count = await prisma.pago.count({
     *   where: {
     *     // ... the filter for the Pagos we want to count
     *   }
     * })
    **/
    count<T extends pagoCountArgs>(
      args?: Subset<T, pagoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoAggregateArgs>(args: Subset<T, PagoAggregateArgs>): PrismaPromise<GetPagoAggregateType<T>>

    /**
     * Group by Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagoGroupByArgs['orderBy'] }
        : { orderBy?: PagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pagoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empleado<T extends empleadoArgs = {}>(args?: Subset<T, empleadoArgs>): CheckSelect<T, Prisma__empleadoClient<empleado | null >, Prisma__empleadoClient<empleadoGetPayload<T> | null >>;

    aplica_b<T extends aplica_bFindManyArgs = {}>(args?: Subset<T, aplica_bFindManyArgs>): CheckSelect<T, PrismaPromise<Array<aplica_b>>, PrismaPromise<Array<aplica_bGetPayload<T>>>>;

    aplica_do<T extends aplica_doFindManyArgs = {}>(args?: Subset<T, aplica_doFindManyArgs>): CheckSelect<T, PrismaPromise<Array<aplica_do>>, PrismaPromise<Array<aplica_doGetPayload<T>>>>;

    aplica_dv<T extends aplica_dvFindManyArgs = {}>(args?: Subset<T, aplica_dvFindManyArgs>): CheckSelect<T, PrismaPromise<Array<aplica_dv>>, PrismaPromise<Array<aplica_dvGetPayload<T>>>>;

    genera<T extends generaFindManyArgs = {}>(args?: Subset<T, generaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<genera>>, PrismaPromise<Array<generaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * pago findUnique
   */
  export type pagoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the pago
     * 
    **/
    select?: pagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagoInclude | null
    /**
     * Throw an Error if a pago can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which pago to fetch.
     * 
    **/
    where: pagoWhereUniqueInput
  }


  /**
   * pago findFirst
   */
  export type pagoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the pago
     * 
    **/
    select?: pagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagoInclude | null
    /**
     * Throw an Error if a pago can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which pago to fetch.
     * 
    **/
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     * 
    **/
    orderBy?: Enumerable<pagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagos.
     * 
    **/
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagos.
     * 
    **/
    distinct?: Enumerable<PagoScalarFieldEnum>
  }


  /**
   * pago findMany
   */
  export type pagoFindManyArgs = {
    /**
     * Select specific fields to fetch from the pago
     * 
    **/
    select?: pagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagoInclude | null
    /**
     * Filter, which pagos to fetch.
     * 
    **/
    where?: pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     * 
    **/
    orderBy?: Enumerable<pagoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pagos.
     * 
    **/
    cursor?: pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PagoScalarFieldEnum>
  }


  /**
   * pago create
   */
  export type pagoCreateArgs = {
    /**
     * Select specific fields to fetch from the pago
     * 
    **/
    select?: pagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagoInclude | null
    /**
     * The data needed to create a pago.
     * 
    **/
    data: XOR<pagoCreateInput, pagoUncheckedCreateInput>
  }


  /**
   * pago createMany
   */
  export type pagoCreateManyArgs = {
    /**
     * The data used to create many pagos.
     * 
    **/
    data: Enumerable<pagoCreateManyInput>
  }


  /**
   * pago update
   */
  export type pagoUpdateArgs = {
    /**
     * Select specific fields to fetch from the pago
     * 
    **/
    select?: pagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagoInclude | null
    /**
     * The data needed to update a pago.
     * 
    **/
    data: XOR<pagoUpdateInput, pagoUncheckedUpdateInput>
    /**
     * Choose, which pago to update.
     * 
    **/
    where: pagoWhereUniqueInput
  }


  /**
   * pago updateMany
   */
  export type pagoUpdateManyArgs = {
    /**
     * The data used to update pagos.
     * 
    **/
    data: XOR<pagoUpdateManyMutationInput, pagoUncheckedUpdateManyInput>
    /**
     * Filter which pagos to update
     * 
    **/
    where?: pagoWhereInput
  }


  /**
   * pago upsert
   */
  export type pagoUpsertArgs = {
    /**
     * Select specific fields to fetch from the pago
     * 
    **/
    select?: pagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagoInclude | null
    /**
     * The filter to search for the pago to update in case it exists.
     * 
    **/
    where: pagoWhereUniqueInput
    /**
     * In case the pago found by the `where` argument doesn't exist, create a new pago with this data.
     * 
    **/
    create: XOR<pagoCreateInput, pagoUncheckedCreateInput>
    /**
     * In case the pago was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pagoUpdateInput, pagoUncheckedUpdateInput>
  }


  /**
   * pago delete
   */
  export type pagoDeleteArgs = {
    /**
     * Select specific fields to fetch from the pago
     * 
    **/
    select?: pagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagoInclude | null
    /**
     * Filter which pago to delete.
     * 
    **/
    where: pagoWhereUniqueInput
  }


  /**
   * pago deleteMany
   */
  export type pagoDeleteManyArgs = {
    /**
     * Filter which pagos to delete
     * 
    **/
    where?: pagoWhereInput
  }


  /**
   * pago without action
   */
  export type pagoArgs = {
    /**
     * Select specific fields to fetch from the pago
     * 
    **/
    select?: pagoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagoInclude | null
  }



  /**
   * Model persona
   */


  export type AggregatePersona = {
    _count: PersonaCountAggregateOutputType | null
    _min: PersonaMinAggregateOutputType | null
    _max: PersonaMaxAggregateOutputType | null
  }

  export type PersonaMinAggregateOutputType = {
    cedula: string | null
    nombre: string | null
    telefono: string | null
  }

  export type PersonaMaxAggregateOutputType = {
    cedula: string | null
    nombre: string | null
    telefono: string | null
  }

  export type PersonaCountAggregateOutputType = {
    cedula: number
    nombre: number
    telefono: number
    _all: number
  }


  export type PersonaMinAggregateInputType = {
    cedula?: true
    nombre?: true
    telefono?: true
  }

  export type PersonaMaxAggregateInputType = {
    cedula?: true
    nombre?: true
    telefono?: true
  }

  export type PersonaCountAggregateInputType = {
    cedula?: true
    nombre?: true
    telefono?: true
    _all?: true
  }

  export type PersonaAggregateArgs = {
    /**
     * Filter which persona to aggregate.
     * 
    **/
    where?: personaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personas to fetch.
     * 
    **/
    orderBy?: Enumerable<personaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: personaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personas
    **/
    _count?: true | PersonaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonaMaxAggregateInputType
  }

  export type GetPersonaAggregateType<T extends PersonaAggregateArgs> = {
        [P in keyof T & keyof AggregatePersona]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersona[P]>
      : GetScalarType<T[P], AggregatePersona[P]>
  }




  export type PersonaGroupByArgs = {
    where?: personaWhereInput
    orderBy?: Enumerable<personaOrderByWithAggregationInput>
    by: Array<PersonaScalarFieldEnum>
    having?: personaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonaCountAggregateInputType | true
    _min?: PersonaMinAggregateInputType
    _max?: PersonaMaxAggregateInputType
  }


  export type PersonaGroupByOutputType = {
    cedula: string
    nombre: string | null
    telefono: string | null
    _count: PersonaCountAggregateOutputType | null
    _min: PersonaMinAggregateOutputType | null
    _max: PersonaMaxAggregateOutputType | null
  }

  type GetPersonaGroupByPayload<T extends PersonaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PersonaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonaGroupByOutputType[P]>
            : GetScalarType<T[P], PersonaGroupByOutputType[P]>
        }
      >
    >


  export type personaSelect = {
    cedula?: boolean
    nombre?: boolean
    telefono?: boolean
    empleado?: boolean | empleadoArgs
    empleador?: boolean | empleadorArgs
    hace_uso?: boolean | hace_usoFindManyArgs
    _count?: boolean | PersonaCountOutputTypeArgs
  }

  export type personaInclude = {
    empleado?: boolean | empleadoArgs
    empleador?: boolean | empleadorArgs
    hace_uso?: boolean | hace_usoFindManyArgs
    _count?: boolean | PersonaCountOutputTypeArgs
  }

  export type personaGetPayload<
    S extends boolean | null | undefined | personaArgs,
    U = keyof S
      > = S extends true
        ? persona
    : S extends undefined
    ? never
    : S extends personaArgs | personaFindManyArgs
    ?'include' extends U
    ? persona  & {
    [P in TrueKeys<S['include']>]:
        P extends 'empleado' ? empleadoGetPayload<S['include'][P]> | null :
        P extends 'empleador' ? empleadorGetPayload<S['include'][P]> | null :
        P extends 'hace_uso' ? Array < hace_usoGetPayload<S['include'][P]>>  :
        P extends '_count' ? PersonaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'empleado' ? empleadoGetPayload<S['select'][P]> | null :
        P extends 'empleador' ? empleadorGetPayload<S['select'][P]> | null :
        P extends 'hace_uso' ? Array < hace_usoGetPayload<S['select'][P]>>  :
        P extends '_count' ? PersonaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof persona ? persona[P] : never
  } 
    : persona
  : persona


  type personaCountArgs = Merge<
    Omit<personaFindManyArgs, 'select' | 'include'> & {
      select?: PersonaCountAggregateInputType | true
    }
  >

  export interface personaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Persona that matches the filter.
     * @param {personaFindUniqueArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends personaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, personaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'persona'> extends True ? CheckSelect<T, Prisma__personaClient<persona>, Prisma__personaClient<personaGetPayload<T>>> : CheckSelect<T, Prisma__personaClient<persona | null >, Prisma__personaClient<personaGetPayload<T> | null >>

    /**
     * Find the first Persona that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaFindFirstArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends personaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, personaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'persona'> extends True ? CheckSelect<T, Prisma__personaClient<persona>, Prisma__personaClient<personaGetPayload<T>>> : CheckSelect<T, Prisma__personaClient<persona | null >, Prisma__personaClient<personaGetPayload<T> | null >>

    /**
     * Find zero or more Personas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personas
     * const personas = await prisma.persona.findMany()
     * 
     * // Get first 10 Personas
     * const personas = await prisma.persona.findMany({ take: 10 })
     * 
     * // Only select the `cedula`
     * const personaWithCedulaOnly = await prisma.persona.findMany({ select: { cedula: true } })
     * 
    **/
    findMany<T extends personaFindManyArgs>(
      args?: SelectSubset<T, personaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<persona>>, PrismaPromise<Array<personaGetPayload<T>>>>

    /**
     * Create a Persona.
     * @param {personaCreateArgs} args - Arguments to create a Persona.
     * @example
     * // Create one Persona
     * const Persona = await prisma.persona.create({
     *   data: {
     *     // ... data to create a Persona
     *   }
     * })
     * 
    **/
    create<T extends personaCreateArgs>(
      args: SelectSubset<T, personaCreateArgs>
    ): CheckSelect<T, Prisma__personaClient<persona>, Prisma__personaClient<personaGetPayload<T>>>

    /**
     * Create many Personas.
     *     @param {personaCreateManyArgs} args - Arguments to create many Personas.
     *     @example
     *     // Create many Personas
     *     const persona = await prisma.persona.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends personaCreateManyArgs>(
      args?: SelectSubset<T, personaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Persona.
     * @param {personaDeleteArgs} args - Arguments to delete one Persona.
     * @example
     * // Delete one Persona
     * const Persona = await prisma.persona.delete({
     *   where: {
     *     // ... filter to delete one Persona
     *   }
     * })
     * 
    **/
    delete<T extends personaDeleteArgs>(
      args: SelectSubset<T, personaDeleteArgs>
    ): CheckSelect<T, Prisma__personaClient<persona>, Prisma__personaClient<personaGetPayload<T>>>

    /**
     * Update one Persona.
     * @param {personaUpdateArgs} args - Arguments to update one Persona.
     * @example
     * // Update one Persona
     * const persona = await prisma.persona.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends personaUpdateArgs>(
      args: SelectSubset<T, personaUpdateArgs>
    ): CheckSelect<T, Prisma__personaClient<persona>, Prisma__personaClient<personaGetPayload<T>>>

    /**
     * Delete zero or more Personas.
     * @param {personaDeleteManyArgs} args - Arguments to filter Personas to delete.
     * @example
     * // Delete a few Personas
     * const { count } = await prisma.persona.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends personaDeleteManyArgs>(
      args?: SelectSubset<T, personaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personas
     * const persona = await prisma.persona.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends personaUpdateManyArgs>(
      args: SelectSubset<T, personaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Persona.
     * @param {personaUpsertArgs} args - Arguments to update or create a Persona.
     * @example
     * // Update or create a Persona
     * const persona = await prisma.persona.upsert({
     *   create: {
     *     // ... data to create a Persona
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Persona we want to update
     *   }
     * })
    **/
    upsert<T extends personaUpsertArgs>(
      args: SelectSubset<T, personaUpsertArgs>
    ): CheckSelect<T, Prisma__personaClient<persona>, Prisma__personaClient<personaGetPayload<T>>>

    /**
     * Count the number of Personas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaCountArgs} args - Arguments to filter Personas to count.
     * @example
     * // Count the number of Personas
     * const count = await prisma.persona.count({
     *   where: {
     *     // ... the filter for the Personas we want to count
     *   }
     * })
    **/
    count<T extends personaCountArgs>(
      args?: Subset<T, personaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Persona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonaAggregateArgs>(args: Subset<T, PersonaAggregateArgs>): PrismaPromise<GetPersonaAggregateType<T>>

    /**
     * Group by Persona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonaGroupByArgs['orderBy'] }
        : { orderBy?: PersonaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for persona.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__personaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empleado<T extends empleadoArgs = {}>(args?: Subset<T, empleadoArgs>): CheckSelect<T, Prisma__empleadoClient<empleado | null >, Prisma__empleadoClient<empleadoGetPayload<T> | null >>;

    empleador<T extends empleadorArgs = {}>(args?: Subset<T, empleadorArgs>): CheckSelect<T, Prisma__empleadorClient<empleador | null >, Prisma__empleadorClient<empleadorGetPayload<T> | null >>;

    hace_uso<T extends hace_usoFindManyArgs = {}>(args?: Subset<T, hace_usoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<hace_uso>>, PrismaPromise<Array<hace_usoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * persona findUnique
   */
  export type personaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the persona
     * 
    **/
    select?: personaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: personaInclude | null
    /**
     * Throw an Error if a persona can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which persona to fetch.
     * 
    **/
    where: personaWhereUniqueInput
  }


  /**
   * persona findFirst
   */
  export type personaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the persona
     * 
    **/
    select?: personaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: personaInclude | null
    /**
     * Throw an Error if a persona can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which persona to fetch.
     * 
    **/
    where?: personaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personas to fetch.
     * 
    **/
    orderBy?: Enumerable<personaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personas.
     * 
    **/
    cursor?: personaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personas.
     * 
    **/
    distinct?: Enumerable<PersonaScalarFieldEnum>
  }


  /**
   * persona findMany
   */
  export type personaFindManyArgs = {
    /**
     * Select specific fields to fetch from the persona
     * 
    **/
    select?: personaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: personaInclude | null
    /**
     * Filter, which personas to fetch.
     * 
    **/
    where?: personaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personas to fetch.
     * 
    **/
    orderBy?: Enumerable<personaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personas.
     * 
    **/
    cursor?: personaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PersonaScalarFieldEnum>
  }


  /**
   * persona create
   */
  export type personaCreateArgs = {
    /**
     * Select specific fields to fetch from the persona
     * 
    **/
    select?: personaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: personaInclude | null
    /**
     * The data needed to create a persona.
     * 
    **/
    data: XOR<personaCreateInput, personaUncheckedCreateInput>
  }


  /**
   * persona createMany
   */
  export type personaCreateManyArgs = {
    /**
     * The data used to create many personas.
     * 
    **/
    data: Enumerable<personaCreateManyInput>
  }


  /**
   * persona update
   */
  export type personaUpdateArgs = {
    /**
     * Select specific fields to fetch from the persona
     * 
    **/
    select?: personaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: personaInclude | null
    /**
     * The data needed to update a persona.
     * 
    **/
    data: XOR<personaUpdateInput, personaUncheckedUpdateInput>
    /**
     * Choose, which persona to update.
     * 
    **/
    where: personaWhereUniqueInput
  }


  /**
   * persona updateMany
   */
  export type personaUpdateManyArgs = {
    /**
     * The data used to update personas.
     * 
    **/
    data: XOR<personaUpdateManyMutationInput, personaUncheckedUpdateManyInput>
    /**
     * Filter which personas to update
     * 
    **/
    where?: personaWhereInput
  }


  /**
   * persona upsert
   */
  export type personaUpsertArgs = {
    /**
     * Select specific fields to fetch from the persona
     * 
    **/
    select?: personaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: personaInclude | null
    /**
     * The filter to search for the persona to update in case it exists.
     * 
    **/
    where: personaWhereUniqueInput
    /**
     * In case the persona found by the `where` argument doesn't exist, create a new persona with this data.
     * 
    **/
    create: XOR<personaCreateInput, personaUncheckedCreateInput>
    /**
     * In case the persona was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<personaUpdateInput, personaUncheckedUpdateInput>
  }


  /**
   * persona delete
   */
  export type personaDeleteArgs = {
    /**
     * Select specific fields to fetch from the persona
     * 
    **/
    select?: personaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: personaInclude | null
    /**
     * Filter which persona to delete.
     * 
    **/
    where: personaWhereUniqueInput
  }


  /**
   * persona deleteMany
   */
  export type personaDeleteManyArgs = {
    /**
     * Filter which personas to delete
     * 
    **/
    where?: personaWhereInput
  }


  /**
   * persona without action
   */
  export type personaArgs = {
    /**
     * Select specific fields to fetch from the persona
     * 
    **/
    select?: personaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: personaInclude | null
  }



  /**
   * Model proyecto
   */


  export type AggregateProyecto = {
    _count: ProyectoCountAggregateOutputType | null
    _avg: ProyectoAvgAggregateOutputType | null
    _sum: ProyectoSumAggregateOutputType | null
    _min: ProyectoMinAggregateOutputType | null
    _max: ProyectoMaxAggregateOutputType | null
  }

  export type ProyectoAvgAggregateOutputType = {
    cantidadMaximaBeneficios: number | null
    montoMaximoBeneficio: number | null
  }

  export type ProyectoSumAggregateOutputType = {
    cantidadMaximaBeneficios: number | null
    montoMaximoBeneficio: number | null
  }

  export type ProyectoMinAggregateOutputType = {
    cedulaJuridica: string | null
    nombre: string | null
    cantidadMaximaBeneficios: number | null
    montoMaximoBeneficio: number | null
    frecuenciaPago: string | null
    moneda: string | null
    fechaInicio: Date | null
    habilitado: boolean | null
    fechaFin: Date | null
    fechaUltimoPago: Date | null
  }

  export type ProyectoMaxAggregateOutputType = {
    cedulaJuridica: string | null
    nombre: string | null
    cantidadMaximaBeneficios: number | null
    montoMaximoBeneficio: number | null
    frecuenciaPago: string | null
    moneda: string | null
    fechaInicio: Date | null
    habilitado: boolean | null
    fechaFin: Date | null
    fechaUltimoPago: Date | null
  }

  export type ProyectoCountAggregateOutputType = {
    cedulaJuridica: number
    nombre: number
    cantidadMaximaBeneficios: number
    montoMaximoBeneficio: number
    frecuenciaPago: number
    moneda: number
    fechaInicio: number
    habilitado: number
    fechaFin: number
    fechaUltimoPago: number
    _all: number
  }


  export type ProyectoAvgAggregateInputType = {
    cantidadMaximaBeneficios?: true
    montoMaximoBeneficio?: true
  }

  export type ProyectoSumAggregateInputType = {
    cantidadMaximaBeneficios?: true
    montoMaximoBeneficio?: true
  }

  export type ProyectoMinAggregateInputType = {
    cedulaJuridica?: true
    nombre?: true
    cantidadMaximaBeneficios?: true
    montoMaximoBeneficio?: true
    frecuenciaPago?: true
    moneda?: true
    fechaInicio?: true
    habilitado?: true
    fechaFin?: true
    fechaUltimoPago?: true
  }

  export type ProyectoMaxAggregateInputType = {
    cedulaJuridica?: true
    nombre?: true
    cantidadMaximaBeneficios?: true
    montoMaximoBeneficio?: true
    frecuenciaPago?: true
    moneda?: true
    fechaInicio?: true
    habilitado?: true
    fechaFin?: true
    fechaUltimoPago?: true
  }

  export type ProyectoCountAggregateInputType = {
    cedulaJuridica?: true
    nombre?: true
    cantidadMaximaBeneficios?: true
    montoMaximoBeneficio?: true
    frecuenciaPago?: true
    moneda?: true
    fechaInicio?: true
    habilitado?: true
    fechaFin?: true
    fechaUltimoPago?: true
    _all?: true
  }

  export type ProyectoAggregateArgs = {
    /**
     * Filter which proyecto to aggregate.
     * 
    **/
    where?: proyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proyectos to fetch.
     * 
    **/
    orderBy?: Enumerable<proyectoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: proyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proyectos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proyectos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proyectos
    **/
    _count?: true | ProyectoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProyectoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProyectoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProyectoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProyectoMaxAggregateInputType
  }

  export type GetProyectoAggregateType<T extends ProyectoAggregateArgs> = {
        [P in keyof T & keyof AggregateProyecto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProyecto[P]>
      : GetScalarType<T[P], AggregateProyecto[P]>
  }




  export type ProyectoGroupByArgs = {
    where?: proyectoWhereInput
    orderBy?: Enumerable<proyectoOrderByWithAggregationInput>
    by: Array<ProyectoScalarFieldEnum>
    having?: proyectoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProyectoCountAggregateInputType | true
    _avg?: ProyectoAvgAggregateInputType
    _sum?: ProyectoSumAggregateInputType
    _min?: ProyectoMinAggregateInputType
    _max?: ProyectoMaxAggregateInputType
  }


  export type ProyectoGroupByOutputType = {
    cedulaJuridica: string
    nombre: string
    cantidadMaximaBeneficios: number | null
    montoMaximoBeneficio: number | null
    frecuenciaPago: string | null
    moneda: string | null
    fechaInicio: Date | null
    habilitado: boolean | null
    fechaFin: Date | null
    fechaUltimoPago: Date | null
    _count: ProyectoCountAggregateOutputType | null
    _avg: ProyectoAvgAggregateOutputType | null
    _sum: ProyectoSumAggregateOutputType | null
    _min: ProyectoMinAggregateOutputType | null
    _max: ProyectoMaxAggregateOutputType | null
  }

  type GetProyectoGroupByPayload<T extends ProyectoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProyectoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProyectoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProyectoGroupByOutputType[P]>
            : GetScalarType<T[P], ProyectoGroupByOutputType[P]>
        }
      >
    >


  export type proyectoSelect = {
    cedulaJuridica?: boolean
    nombre?: boolean
    cantidadMaximaBeneficios?: boolean
    montoMaximoBeneficio?: boolean
    frecuenciaPago?: boolean
    moneda?: boolean
    fechaInicio?: boolean
    habilitado?: boolean
    fechaFin?: boolean
    fechaUltimoPago?: boolean
    empresa?: boolean | empresaArgs
    beneficios?: boolean | beneficiosFindManyArgs
    deduccionVoluntaria?: boolean | deduccionVoluntariaFindManyArgs
    esContratado?: boolean | esContratadoFindManyArgs
    genera?: boolean | generaFindManyArgs
    reporteHoras?: boolean | reporteHorasFindManyArgs
    _count?: boolean | ProyectoCountOutputTypeArgs
  }

  export type proyectoInclude = {
    empresa?: boolean | empresaArgs
    beneficios?: boolean | beneficiosFindManyArgs
    deduccionVoluntaria?: boolean | deduccionVoluntariaFindManyArgs
    esContratado?: boolean | esContratadoFindManyArgs
    genera?: boolean | generaFindManyArgs
    reporteHoras?: boolean | reporteHorasFindManyArgs
    _count?: boolean | ProyectoCountOutputTypeArgs
  }

  export type proyectoGetPayload<
    S extends boolean | null | undefined | proyectoArgs,
    U = keyof S
      > = S extends true
        ? proyecto
    : S extends undefined
    ? never
    : S extends proyectoArgs | proyectoFindManyArgs
    ?'include' extends U
    ? proyecto  & {
    [P in TrueKeys<S['include']>]:
        P extends 'empresa' ? empresaGetPayload<S['include'][P]> :
        P extends 'beneficios' ? Array < beneficiosGetPayload<S['include'][P]>>  :
        P extends 'deduccionVoluntaria' ? Array < deduccionVoluntariaGetPayload<S['include'][P]>>  :
        P extends 'esContratado' ? Array < esContratadoGetPayload<S['include'][P]>>  :
        P extends 'genera' ? Array < generaGetPayload<S['include'][P]>>  :
        P extends 'reporteHoras' ? Array < reporteHorasGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProyectoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'empresa' ? empresaGetPayload<S['select'][P]> :
        P extends 'beneficios' ? Array < beneficiosGetPayload<S['select'][P]>>  :
        P extends 'deduccionVoluntaria' ? Array < deduccionVoluntariaGetPayload<S['select'][P]>>  :
        P extends 'esContratado' ? Array < esContratadoGetPayload<S['select'][P]>>  :
        P extends 'genera' ? Array < generaGetPayload<S['select'][P]>>  :
        P extends 'reporteHoras' ? Array < reporteHorasGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProyectoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof proyecto ? proyecto[P] : never
  } 
    : proyecto
  : proyecto


  type proyectoCountArgs = Merge<
    Omit<proyectoFindManyArgs, 'select' | 'include'> & {
      select?: ProyectoCountAggregateInputType | true
    }
  >

  export interface proyectoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Proyecto that matches the filter.
     * @param {proyectoFindUniqueArgs} args - Arguments to find a Proyecto
     * @example
     * // Get one Proyecto
     * const proyecto = await prisma.proyecto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends proyectoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, proyectoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'proyecto'> extends True ? CheckSelect<T, Prisma__proyectoClient<proyecto>, Prisma__proyectoClient<proyectoGetPayload<T>>> : CheckSelect<T, Prisma__proyectoClient<proyecto | null >, Prisma__proyectoClient<proyectoGetPayload<T> | null >>

    /**
     * Find the first Proyecto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proyectoFindFirstArgs} args - Arguments to find a Proyecto
     * @example
     * // Get one Proyecto
     * const proyecto = await prisma.proyecto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends proyectoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, proyectoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'proyecto'> extends True ? CheckSelect<T, Prisma__proyectoClient<proyecto>, Prisma__proyectoClient<proyectoGetPayload<T>>> : CheckSelect<T, Prisma__proyectoClient<proyecto | null >, Prisma__proyectoClient<proyectoGetPayload<T> | null >>

    /**
     * Find zero or more Proyectos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proyectoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proyectos
     * const proyectos = await prisma.proyecto.findMany()
     * 
     * // Get first 10 Proyectos
     * const proyectos = await prisma.proyecto.findMany({ take: 10 })
     * 
     * // Only select the `cedulaJuridica`
     * const proyectoWithCedulaJuridicaOnly = await prisma.proyecto.findMany({ select: { cedulaJuridica: true } })
     * 
    **/
    findMany<T extends proyectoFindManyArgs>(
      args?: SelectSubset<T, proyectoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<proyecto>>, PrismaPromise<Array<proyectoGetPayload<T>>>>

    /**
     * Create a Proyecto.
     * @param {proyectoCreateArgs} args - Arguments to create a Proyecto.
     * @example
     * // Create one Proyecto
     * const Proyecto = await prisma.proyecto.create({
     *   data: {
     *     // ... data to create a Proyecto
     *   }
     * })
     * 
    **/
    create<T extends proyectoCreateArgs>(
      args: SelectSubset<T, proyectoCreateArgs>
    ): CheckSelect<T, Prisma__proyectoClient<proyecto>, Prisma__proyectoClient<proyectoGetPayload<T>>>

    /**
     * Create many Proyectos.
     *     @param {proyectoCreateManyArgs} args - Arguments to create many Proyectos.
     *     @example
     *     // Create many Proyectos
     *     const proyecto = await prisma.proyecto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends proyectoCreateManyArgs>(
      args?: SelectSubset<T, proyectoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Proyecto.
     * @param {proyectoDeleteArgs} args - Arguments to delete one Proyecto.
     * @example
     * // Delete one Proyecto
     * const Proyecto = await prisma.proyecto.delete({
     *   where: {
     *     // ... filter to delete one Proyecto
     *   }
     * })
     * 
    **/
    delete<T extends proyectoDeleteArgs>(
      args: SelectSubset<T, proyectoDeleteArgs>
    ): CheckSelect<T, Prisma__proyectoClient<proyecto>, Prisma__proyectoClient<proyectoGetPayload<T>>>

    /**
     * Update one Proyecto.
     * @param {proyectoUpdateArgs} args - Arguments to update one Proyecto.
     * @example
     * // Update one Proyecto
     * const proyecto = await prisma.proyecto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends proyectoUpdateArgs>(
      args: SelectSubset<T, proyectoUpdateArgs>
    ): CheckSelect<T, Prisma__proyectoClient<proyecto>, Prisma__proyectoClient<proyectoGetPayload<T>>>

    /**
     * Delete zero or more Proyectos.
     * @param {proyectoDeleteManyArgs} args - Arguments to filter Proyectos to delete.
     * @example
     * // Delete a few Proyectos
     * const { count } = await prisma.proyecto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends proyectoDeleteManyArgs>(
      args?: SelectSubset<T, proyectoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proyectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proyectoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proyectos
     * const proyecto = await prisma.proyecto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends proyectoUpdateManyArgs>(
      args: SelectSubset<T, proyectoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Proyecto.
     * @param {proyectoUpsertArgs} args - Arguments to update or create a Proyecto.
     * @example
     * // Update or create a Proyecto
     * const proyecto = await prisma.proyecto.upsert({
     *   create: {
     *     // ... data to create a Proyecto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proyecto we want to update
     *   }
     * })
    **/
    upsert<T extends proyectoUpsertArgs>(
      args: SelectSubset<T, proyectoUpsertArgs>
    ): CheckSelect<T, Prisma__proyectoClient<proyecto>, Prisma__proyectoClient<proyectoGetPayload<T>>>

    /**
     * Count the number of Proyectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proyectoCountArgs} args - Arguments to filter Proyectos to count.
     * @example
     * // Count the number of Proyectos
     * const count = await prisma.proyecto.count({
     *   where: {
     *     // ... the filter for the Proyectos we want to count
     *   }
     * })
    **/
    count<T extends proyectoCountArgs>(
      args?: Subset<T, proyectoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProyectoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proyecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProyectoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProyectoAggregateArgs>(args: Subset<T, ProyectoAggregateArgs>): PrismaPromise<GetProyectoAggregateType<T>>

    /**
     * Group by Proyecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProyectoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProyectoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProyectoGroupByArgs['orderBy'] }
        : { orderBy?: ProyectoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProyectoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProyectoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for proyecto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__proyectoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empresa<T extends empresaArgs = {}>(args?: Subset<T, empresaArgs>): CheckSelect<T, Prisma__empresaClient<empresa | null >, Prisma__empresaClient<empresaGetPayload<T> | null >>;

    beneficios<T extends beneficiosFindManyArgs = {}>(args?: Subset<T, beneficiosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<beneficios>>, PrismaPromise<Array<beneficiosGetPayload<T>>>>;

    deduccionVoluntaria<T extends deduccionVoluntariaFindManyArgs = {}>(args?: Subset<T, deduccionVoluntariaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<deduccionVoluntaria>>, PrismaPromise<Array<deduccionVoluntariaGetPayload<T>>>>;

    esContratado<T extends esContratadoFindManyArgs = {}>(args?: Subset<T, esContratadoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<esContratado>>, PrismaPromise<Array<esContratadoGetPayload<T>>>>;

    genera<T extends generaFindManyArgs = {}>(args?: Subset<T, generaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<genera>>, PrismaPromise<Array<generaGetPayload<T>>>>;

    reporteHoras<T extends reporteHorasFindManyArgs = {}>(args?: Subset<T, reporteHorasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reporteHoras>>, PrismaPromise<Array<reporteHorasGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * proyecto findUnique
   */
  export type proyectoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the proyecto
     * 
    **/
    select?: proyectoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: proyectoInclude | null
    /**
     * Throw an Error if a proyecto can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which proyecto to fetch.
     * 
    **/
    where: proyectoWhereUniqueInput
  }


  /**
   * proyecto findFirst
   */
  export type proyectoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the proyecto
     * 
    **/
    select?: proyectoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: proyectoInclude | null
    /**
     * Throw an Error if a proyecto can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which proyecto to fetch.
     * 
    **/
    where?: proyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proyectos to fetch.
     * 
    **/
    orderBy?: Enumerable<proyectoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proyectos.
     * 
    **/
    cursor?: proyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proyectos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proyectos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proyectos.
     * 
    **/
    distinct?: Enumerable<ProyectoScalarFieldEnum>
  }


  /**
   * proyecto findMany
   */
  export type proyectoFindManyArgs = {
    /**
     * Select specific fields to fetch from the proyecto
     * 
    **/
    select?: proyectoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: proyectoInclude | null
    /**
     * Filter, which proyectos to fetch.
     * 
    **/
    where?: proyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proyectos to fetch.
     * 
    **/
    orderBy?: Enumerable<proyectoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proyectos.
     * 
    **/
    cursor?: proyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proyectos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proyectos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProyectoScalarFieldEnum>
  }


  /**
   * proyecto create
   */
  export type proyectoCreateArgs = {
    /**
     * Select specific fields to fetch from the proyecto
     * 
    **/
    select?: proyectoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: proyectoInclude | null
    /**
     * The data needed to create a proyecto.
     * 
    **/
    data: XOR<proyectoCreateInput, proyectoUncheckedCreateInput>
  }


  /**
   * proyecto createMany
   */
  export type proyectoCreateManyArgs = {
    /**
     * The data used to create many proyectos.
     * 
    **/
    data: Enumerable<proyectoCreateManyInput>
  }


  /**
   * proyecto update
   */
  export type proyectoUpdateArgs = {
    /**
     * Select specific fields to fetch from the proyecto
     * 
    **/
    select?: proyectoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: proyectoInclude | null
    /**
     * The data needed to update a proyecto.
     * 
    **/
    data: XOR<proyectoUpdateInput, proyectoUncheckedUpdateInput>
    /**
     * Choose, which proyecto to update.
     * 
    **/
    where: proyectoWhereUniqueInput
  }


  /**
   * proyecto updateMany
   */
  export type proyectoUpdateManyArgs = {
    /**
     * The data used to update proyectos.
     * 
    **/
    data: XOR<proyectoUpdateManyMutationInput, proyectoUncheckedUpdateManyInput>
    /**
     * Filter which proyectos to update
     * 
    **/
    where?: proyectoWhereInput
  }


  /**
   * proyecto upsert
   */
  export type proyectoUpsertArgs = {
    /**
     * Select specific fields to fetch from the proyecto
     * 
    **/
    select?: proyectoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: proyectoInclude | null
    /**
     * The filter to search for the proyecto to update in case it exists.
     * 
    **/
    where: proyectoWhereUniqueInput
    /**
     * In case the proyecto found by the `where` argument doesn't exist, create a new proyecto with this data.
     * 
    **/
    create: XOR<proyectoCreateInput, proyectoUncheckedCreateInput>
    /**
     * In case the proyecto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<proyectoUpdateInput, proyectoUncheckedUpdateInput>
  }


  /**
   * proyecto delete
   */
  export type proyectoDeleteArgs = {
    /**
     * Select specific fields to fetch from the proyecto
     * 
    **/
    select?: proyectoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: proyectoInclude | null
    /**
     * Filter which proyecto to delete.
     * 
    **/
    where: proyectoWhereUniqueInput
  }


  /**
   * proyecto deleteMany
   */
  export type proyectoDeleteManyArgs = {
    /**
     * Filter which proyectos to delete
     * 
    **/
    where?: proyectoWhereInput
  }


  /**
   * proyecto without action
   */
  export type proyectoArgs = {
    /**
     * Select specific fields to fetch from the proyecto
     * 
    **/
    select?: proyectoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: proyectoInclude | null
  }



  /**
   * Model reporteHoras
   */


  export type AggregateReporteHoras = {
    _count: ReporteHorasCountAggregateOutputType | null
    _avg: ReporteHorasAvgAggregateOutputType | null
    _sum: ReporteHorasSumAggregateOutputType | null
    _min: ReporteHorasMinAggregateOutputType | null
    _max: ReporteHorasMaxAggregateOutputType | null
  }

  export type ReporteHorasAvgAggregateOutputType = {
    horasTrabajadas: number | null
    estado: number | null
  }

  export type ReporteHorasSumAggregateOutputType = {
    horasTrabajadas: number | null
    estado: number | null
  }

  export type ReporteHorasMinAggregateOutputType = {
    cedulaEmpleado: string | null
    cedulaEmpleador: string | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    fechaHora: Date | null
    horasTrabajadas: number | null
    estado: number | null
  }

  export type ReporteHorasMaxAggregateOutputType = {
    cedulaEmpleado: string | null
    cedulaEmpleador: string | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    fechaHora: Date | null
    horasTrabajadas: number | null
    estado: number | null
  }

  export type ReporteHorasCountAggregateOutputType = {
    cedulaEmpleado: number
    cedulaEmpleador: number
    cedulaJuridica: number
    nombreProyecto: number
    fechaHora: number
    horasTrabajadas: number
    estado: number
    _all: number
  }


  export type ReporteHorasAvgAggregateInputType = {
    horasTrabajadas?: true
    estado?: true
  }

  export type ReporteHorasSumAggregateInputType = {
    horasTrabajadas?: true
    estado?: true
  }

  export type ReporteHorasMinAggregateInputType = {
    cedulaEmpleado?: true
    cedulaEmpleador?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    fechaHora?: true
    horasTrabajadas?: true
    estado?: true
  }

  export type ReporteHorasMaxAggregateInputType = {
    cedulaEmpleado?: true
    cedulaEmpleador?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    fechaHora?: true
    horasTrabajadas?: true
    estado?: true
  }

  export type ReporteHorasCountAggregateInputType = {
    cedulaEmpleado?: true
    cedulaEmpleador?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    fechaHora?: true
    horasTrabajadas?: true
    estado?: true
    _all?: true
  }

  export type ReporteHorasAggregateArgs = {
    /**
     * Filter which reporteHoras to aggregate.
     * 
    **/
    where?: reporteHorasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reporteHoras to fetch.
     * 
    **/
    orderBy?: Enumerable<reporteHorasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reporteHorasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reporteHoras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reporteHoras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reporteHoras
    **/
    _count?: true | ReporteHorasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReporteHorasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReporteHorasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReporteHorasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReporteHorasMaxAggregateInputType
  }

  export type GetReporteHorasAggregateType<T extends ReporteHorasAggregateArgs> = {
        [P in keyof T & keyof AggregateReporteHoras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReporteHoras[P]>
      : GetScalarType<T[P], AggregateReporteHoras[P]>
  }




  export type ReporteHorasGroupByArgs = {
    where?: reporteHorasWhereInput
    orderBy?: Enumerable<reporteHorasOrderByWithAggregationInput>
    by: Array<ReporteHorasScalarFieldEnum>
    having?: reporteHorasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReporteHorasCountAggregateInputType | true
    _avg?: ReporteHorasAvgAggregateInputType
    _sum?: ReporteHorasSumAggregateInputType
    _min?: ReporteHorasMinAggregateInputType
    _max?: ReporteHorasMaxAggregateInputType
  }


  export type ReporteHorasGroupByOutputType = {
    cedulaEmpleado: string
    cedulaEmpleador: string | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    fechaHora: Date
    horasTrabajadas: number | null
    estado: number | null
    _count: ReporteHorasCountAggregateOutputType | null
    _avg: ReporteHorasAvgAggregateOutputType | null
    _sum: ReporteHorasSumAggregateOutputType | null
    _min: ReporteHorasMinAggregateOutputType | null
    _max: ReporteHorasMaxAggregateOutputType | null
  }

  type GetReporteHorasGroupByPayload<T extends ReporteHorasGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReporteHorasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReporteHorasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReporteHorasGroupByOutputType[P]>
            : GetScalarType<T[P], ReporteHorasGroupByOutputType[P]>
        }
      >
    >


  export type reporteHorasSelect = {
    cedulaEmpleado?: boolean
    cedulaEmpleador?: boolean
    cedulaJuridica?: boolean
    nombreProyecto?: boolean
    fechaHora?: boolean
    horasTrabajadas?: boolean
    estado?: boolean
    empleado?: boolean | empleadoArgs
    empleador?: boolean | empleadorArgs
    proyecto?: boolean | proyectoArgs
  }

  export type reporteHorasInclude = {
    empleado?: boolean | empleadoArgs
    empleador?: boolean | empleadorArgs
    proyecto?: boolean | proyectoArgs
  }

  export type reporteHorasGetPayload<
    S extends boolean | null | undefined | reporteHorasArgs,
    U = keyof S
      > = S extends true
        ? reporteHoras
    : S extends undefined
    ? never
    : S extends reporteHorasArgs | reporteHorasFindManyArgs
    ?'include' extends U
    ? reporteHoras  & {
    [P in TrueKeys<S['include']>]:
        P extends 'empleado' ? empleadoGetPayload<S['include'][P]> :
        P extends 'empleador' ? empleadorGetPayload<S['include'][P]> | null :
        P extends 'proyecto' ? proyectoGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'empleado' ? empleadoGetPayload<S['select'][P]> :
        P extends 'empleador' ? empleadorGetPayload<S['select'][P]> | null :
        P extends 'proyecto' ? proyectoGetPayload<S['select'][P]> | null :  P extends keyof reporteHoras ? reporteHoras[P] : never
  } 
    : reporteHoras
  : reporteHoras


  type reporteHorasCountArgs = Merge<
    Omit<reporteHorasFindManyArgs, 'select' | 'include'> & {
      select?: ReporteHorasCountAggregateInputType | true
    }
  >

  export interface reporteHorasDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReporteHoras that matches the filter.
     * @param {reporteHorasFindUniqueArgs} args - Arguments to find a ReporteHoras
     * @example
     * // Get one ReporteHoras
     * const reporteHoras = await prisma.reporteHoras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reporteHorasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reporteHorasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reporteHoras'> extends True ? CheckSelect<T, Prisma__reporteHorasClient<reporteHoras>, Prisma__reporteHorasClient<reporteHorasGetPayload<T>>> : CheckSelect<T, Prisma__reporteHorasClient<reporteHoras | null >, Prisma__reporteHorasClient<reporteHorasGetPayload<T> | null >>

    /**
     * Find the first ReporteHoras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reporteHorasFindFirstArgs} args - Arguments to find a ReporteHoras
     * @example
     * // Get one ReporteHoras
     * const reporteHoras = await prisma.reporteHoras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reporteHorasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reporteHorasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reporteHoras'> extends True ? CheckSelect<T, Prisma__reporteHorasClient<reporteHoras>, Prisma__reporteHorasClient<reporteHorasGetPayload<T>>> : CheckSelect<T, Prisma__reporteHorasClient<reporteHoras | null >, Prisma__reporteHorasClient<reporteHorasGetPayload<T> | null >>

    /**
     * Find zero or more ReporteHoras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reporteHorasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReporteHoras
     * const reporteHoras = await prisma.reporteHoras.findMany()
     * 
     * // Get first 10 ReporteHoras
     * const reporteHoras = await prisma.reporteHoras.findMany({ take: 10 })
     * 
     * // Only select the `cedulaEmpleado`
     * const reporteHorasWithCedulaEmpleadoOnly = await prisma.reporteHoras.findMany({ select: { cedulaEmpleado: true } })
     * 
    **/
    findMany<T extends reporteHorasFindManyArgs>(
      args?: SelectSubset<T, reporteHorasFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<reporteHoras>>, PrismaPromise<Array<reporteHorasGetPayload<T>>>>

    /**
     * Create a ReporteHoras.
     * @param {reporteHorasCreateArgs} args - Arguments to create a ReporteHoras.
     * @example
     * // Create one ReporteHoras
     * const ReporteHoras = await prisma.reporteHoras.create({
     *   data: {
     *     // ... data to create a ReporteHoras
     *   }
     * })
     * 
    **/
    create<T extends reporteHorasCreateArgs>(
      args: SelectSubset<T, reporteHorasCreateArgs>
    ): CheckSelect<T, Prisma__reporteHorasClient<reporteHoras>, Prisma__reporteHorasClient<reporteHorasGetPayload<T>>>

    /**
     * Create many ReporteHoras.
     *     @param {reporteHorasCreateManyArgs} args - Arguments to create many ReporteHoras.
     *     @example
     *     // Create many ReporteHoras
     *     const reporteHoras = await prisma.reporteHoras.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reporteHorasCreateManyArgs>(
      args?: SelectSubset<T, reporteHorasCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReporteHoras.
     * @param {reporteHorasDeleteArgs} args - Arguments to delete one ReporteHoras.
     * @example
     * // Delete one ReporteHoras
     * const ReporteHoras = await prisma.reporteHoras.delete({
     *   where: {
     *     // ... filter to delete one ReporteHoras
     *   }
     * })
     * 
    **/
    delete<T extends reporteHorasDeleteArgs>(
      args: SelectSubset<T, reporteHorasDeleteArgs>
    ): CheckSelect<T, Prisma__reporteHorasClient<reporteHoras>, Prisma__reporteHorasClient<reporteHorasGetPayload<T>>>

    /**
     * Update one ReporteHoras.
     * @param {reporteHorasUpdateArgs} args - Arguments to update one ReporteHoras.
     * @example
     * // Update one ReporteHoras
     * const reporteHoras = await prisma.reporteHoras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reporteHorasUpdateArgs>(
      args: SelectSubset<T, reporteHorasUpdateArgs>
    ): CheckSelect<T, Prisma__reporteHorasClient<reporteHoras>, Prisma__reporteHorasClient<reporteHorasGetPayload<T>>>

    /**
     * Delete zero or more ReporteHoras.
     * @param {reporteHorasDeleteManyArgs} args - Arguments to filter ReporteHoras to delete.
     * @example
     * // Delete a few ReporteHoras
     * const { count } = await prisma.reporteHoras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reporteHorasDeleteManyArgs>(
      args?: SelectSubset<T, reporteHorasDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReporteHoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reporteHorasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReporteHoras
     * const reporteHoras = await prisma.reporteHoras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reporteHorasUpdateManyArgs>(
      args: SelectSubset<T, reporteHorasUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReporteHoras.
     * @param {reporteHorasUpsertArgs} args - Arguments to update or create a ReporteHoras.
     * @example
     * // Update or create a ReporteHoras
     * const reporteHoras = await prisma.reporteHoras.upsert({
     *   create: {
     *     // ... data to create a ReporteHoras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReporteHoras we want to update
     *   }
     * })
    **/
    upsert<T extends reporteHorasUpsertArgs>(
      args: SelectSubset<T, reporteHorasUpsertArgs>
    ): CheckSelect<T, Prisma__reporteHorasClient<reporteHoras>, Prisma__reporteHorasClient<reporteHorasGetPayload<T>>>

    /**
     * Count the number of ReporteHoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reporteHorasCountArgs} args - Arguments to filter ReporteHoras to count.
     * @example
     * // Count the number of ReporteHoras
     * const count = await prisma.reporteHoras.count({
     *   where: {
     *     // ... the filter for the ReporteHoras we want to count
     *   }
     * })
    **/
    count<T extends reporteHorasCountArgs>(
      args?: Subset<T, reporteHorasCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReporteHorasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReporteHoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteHorasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReporteHorasAggregateArgs>(args: Subset<T, ReporteHorasAggregateArgs>): PrismaPromise<GetReporteHorasAggregateType<T>>

    /**
     * Group by ReporteHoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteHorasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReporteHorasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReporteHorasGroupByArgs['orderBy'] }
        : { orderBy?: ReporteHorasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReporteHorasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReporteHorasGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for reporteHoras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reporteHorasClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empleado<T extends empleadoArgs = {}>(args?: Subset<T, empleadoArgs>): CheckSelect<T, Prisma__empleadoClient<empleado | null >, Prisma__empleadoClient<empleadoGetPayload<T> | null >>;

    empleador<T extends empleadorArgs = {}>(args?: Subset<T, empleadorArgs>): CheckSelect<T, Prisma__empleadorClient<empleador | null >, Prisma__empleadorClient<empleadorGetPayload<T> | null >>;

    proyecto<T extends proyectoArgs = {}>(args?: Subset<T, proyectoArgs>): CheckSelect<T, Prisma__proyectoClient<proyecto | null >, Prisma__proyectoClient<proyectoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * reporteHoras findUnique
   */
  export type reporteHorasFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the reporteHoras
     * 
    **/
    select?: reporteHorasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reporteHorasInclude | null
    /**
     * Throw an Error if a reporteHoras can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which reporteHoras to fetch.
     * 
    **/
    where: reporteHorasWhereUniqueInput
  }


  /**
   * reporteHoras findFirst
   */
  export type reporteHorasFindFirstArgs = {
    /**
     * Select specific fields to fetch from the reporteHoras
     * 
    **/
    select?: reporteHorasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reporteHorasInclude | null
    /**
     * Throw an Error if a reporteHoras can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which reporteHoras to fetch.
     * 
    **/
    where?: reporteHorasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reporteHoras to fetch.
     * 
    **/
    orderBy?: Enumerable<reporteHorasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reporteHoras.
     * 
    **/
    cursor?: reporteHorasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reporteHoras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reporteHoras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reporteHoras.
     * 
    **/
    distinct?: Enumerable<ReporteHorasScalarFieldEnum>
  }


  /**
   * reporteHoras findMany
   */
  export type reporteHorasFindManyArgs = {
    /**
     * Select specific fields to fetch from the reporteHoras
     * 
    **/
    select?: reporteHorasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reporteHorasInclude | null
    /**
     * Filter, which reporteHoras to fetch.
     * 
    **/
    where?: reporteHorasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reporteHoras to fetch.
     * 
    **/
    orderBy?: Enumerable<reporteHorasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reporteHoras.
     * 
    **/
    cursor?: reporteHorasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reporteHoras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reporteHoras.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReporteHorasScalarFieldEnum>
  }


  /**
   * reporteHoras create
   */
  export type reporteHorasCreateArgs = {
    /**
     * Select specific fields to fetch from the reporteHoras
     * 
    **/
    select?: reporteHorasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reporteHorasInclude | null
    /**
     * The data needed to create a reporteHoras.
     * 
    **/
    data: XOR<reporteHorasCreateInput, reporteHorasUncheckedCreateInput>
  }


  /**
   * reporteHoras createMany
   */
  export type reporteHorasCreateManyArgs = {
    /**
     * The data used to create many reporteHoras.
     * 
    **/
    data: Enumerable<reporteHorasCreateManyInput>
  }


  /**
   * reporteHoras update
   */
  export type reporteHorasUpdateArgs = {
    /**
     * Select specific fields to fetch from the reporteHoras
     * 
    **/
    select?: reporteHorasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reporteHorasInclude | null
    /**
     * The data needed to update a reporteHoras.
     * 
    **/
    data: XOR<reporteHorasUpdateInput, reporteHorasUncheckedUpdateInput>
    /**
     * Choose, which reporteHoras to update.
     * 
    **/
    where: reporteHorasWhereUniqueInput
  }


  /**
   * reporteHoras updateMany
   */
  export type reporteHorasUpdateManyArgs = {
    /**
     * The data used to update reporteHoras.
     * 
    **/
    data: XOR<reporteHorasUpdateManyMutationInput, reporteHorasUncheckedUpdateManyInput>
    /**
     * Filter which reporteHoras to update
     * 
    **/
    where?: reporteHorasWhereInput
  }


  /**
   * reporteHoras upsert
   */
  export type reporteHorasUpsertArgs = {
    /**
     * Select specific fields to fetch from the reporteHoras
     * 
    **/
    select?: reporteHorasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reporteHorasInclude | null
    /**
     * The filter to search for the reporteHoras to update in case it exists.
     * 
    **/
    where: reporteHorasWhereUniqueInput
    /**
     * In case the reporteHoras found by the `where` argument doesn't exist, create a new reporteHoras with this data.
     * 
    **/
    create: XOR<reporteHorasCreateInput, reporteHorasUncheckedCreateInput>
    /**
     * In case the reporteHoras was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reporteHorasUpdateInput, reporteHorasUncheckedUpdateInput>
  }


  /**
   * reporteHoras delete
   */
  export type reporteHorasDeleteArgs = {
    /**
     * Select specific fields to fetch from the reporteHoras
     * 
    **/
    select?: reporteHorasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reporteHorasInclude | null
    /**
     * Filter which reporteHoras to delete.
     * 
    **/
    where: reporteHorasWhereUniqueInput
  }


  /**
   * reporteHoras deleteMany
   */
  export type reporteHorasDeleteManyArgs = {
    /**
     * Filter which reporteHoras to delete
     * 
    **/
    where?: reporteHorasWhereInput
  }


  /**
   * reporteHoras without action
   */
  export type reporteHorasArgs = {
    /**
     * Select specific fields to fetch from the reporteHoras
     * 
    **/
    select?: reporteHorasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reporteHorasInclude | null
  }



  /**
   * Model selecciona
   */


  export type AggregateSelecciona = {
    _count: SeleccionaCountAggregateOutputType | null
    _min: SeleccionaMinAggregateOutputType | null
    _max: SeleccionaMaxAggregateOutputType | null
  }

  export type SeleccionaMinAggregateOutputType = {
    cedulaEmpleado: string | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreBeneficio: string | null
  }

  export type SeleccionaMaxAggregateOutputType = {
    cedulaEmpleado: string | null
    cedulaJuridica: string | null
    nombreProyecto: string | null
    nombreBeneficio: string | null
  }

  export type SeleccionaCountAggregateOutputType = {
    cedulaEmpleado: number
    cedulaJuridica: number
    nombreProyecto: number
    nombreBeneficio: number
    _all: number
  }


  export type SeleccionaMinAggregateInputType = {
    cedulaEmpleado?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreBeneficio?: true
  }

  export type SeleccionaMaxAggregateInputType = {
    cedulaEmpleado?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreBeneficio?: true
  }

  export type SeleccionaCountAggregateInputType = {
    cedulaEmpleado?: true
    cedulaJuridica?: true
    nombreProyecto?: true
    nombreBeneficio?: true
    _all?: true
  }

  export type SeleccionaAggregateArgs = {
    /**
     * Filter which selecciona to aggregate.
     * 
    **/
    where?: seleccionaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seleccionas to fetch.
     * 
    **/
    orderBy?: Enumerable<seleccionaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: seleccionaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seleccionas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seleccionas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seleccionas
    **/
    _count?: true | SeleccionaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeleccionaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeleccionaMaxAggregateInputType
  }

  export type GetSeleccionaAggregateType<T extends SeleccionaAggregateArgs> = {
        [P in keyof T & keyof AggregateSelecciona]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSelecciona[P]>
      : GetScalarType<T[P], AggregateSelecciona[P]>
  }




  export type SeleccionaGroupByArgs = {
    where?: seleccionaWhereInput
    orderBy?: Enumerable<seleccionaOrderByWithAggregationInput>
    by: Array<SeleccionaScalarFieldEnum>
    having?: seleccionaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeleccionaCountAggregateInputType | true
    _min?: SeleccionaMinAggregateInputType
    _max?: SeleccionaMaxAggregateInputType
  }


  export type SeleccionaGroupByOutputType = {
    cedulaEmpleado: string
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
    _count: SeleccionaCountAggregateOutputType | null
    _min: SeleccionaMinAggregateOutputType | null
    _max: SeleccionaMaxAggregateOutputType | null
  }

  type GetSeleccionaGroupByPayload<T extends SeleccionaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SeleccionaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeleccionaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeleccionaGroupByOutputType[P]>
            : GetScalarType<T[P], SeleccionaGroupByOutputType[P]>
        }
      >
    >


  export type seleccionaSelect = {
    cedulaEmpleado?: boolean
    cedulaJuridica?: boolean
    nombreProyecto?: boolean
    nombreBeneficio?: boolean
    empleado?: boolean | empleadoArgs
    beneficios?: boolean | beneficiosArgs
  }

  export type seleccionaInclude = {
    empleado?: boolean | empleadoArgs
    beneficios?: boolean | beneficiosArgs
  }

  export type seleccionaGetPayload<
    S extends boolean | null | undefined | seleccionaArgs,
    U = keyof S
      > = S extends true
        ? selecciona
    : S extends undefined
    ? never
    : S extends seleccionaArgs | seleccionaFindManyArgs
    ?'include' extends U
    ? selecciona  & {
    [P in TrueKeys<S['include']>]:
        P extends 'empleado' ? empleadoGetPayload<S['include'][P]> :
        P extends 'beneficios' ? beneficiosGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'empleado' ? empleadoGetPayload<S['select'][P]> :
        P extends 'beneficios' ? beneficiosGetPayload<S['select'][P]> :  P extends keyof selecciona ? selecciona[P] : never
  } 
    : selecciona
  : selecciona


  type seleccionaCountArgs = Merge<
    Omit<seleccionaFindManyArgs, 'select' | 'include'> & {
      select?: SeleccionaCountAggregateInputType | true
    }
  >

  export interface seleccionaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Selecciona that matches the filter.
     * @param {seleccionaFindUniqueArgs} args - Arguments to find a Selecciona
     * @example
     * // Get one Selecciona
     * const selecciona = await prisma.selecciona.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends seleccionaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, seleccionaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'selecciona'> extends True ? CheckSelect<T, Prisma__seleccionaClient<selecciona>, Prisma__seleccionaClient<seleccionaGetPayload<T>>> : CheckSelect<T, Prisma__seleccionaClient<selecciona | null >, Prisma__seleccionaClient<seleccionaGetPayload<T> | null >>

    /**
     * Find the first Selecciona that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seleccionaFindFirstArgs} args - Arguments to find a Selecciona
     * @example
     * // Get one Selecciona
     * const selecciona = await prisma.selecciona.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends seleccionaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, seleccionaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'selecciona'> extends True ? CheckSelect<T, Prisma__seleccionaClient<selecciona>, Prisma__seleccionaClient<seleccionaGetPayload<T>>> : CheckSelect<T, Prisma__seleccionaClient<selecciona | null >, Prisma__seleccionaClient<seleccionaGetPayload<T> | null >>

    /**
     * Find zero or more Seleccionas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seleccionaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seleccionas
     * const seleccionas = await prisma.selecciona.findMany()
     * 
     * // Get first 10 Seleccionas
     * const seleccionas = await prisma.selecciona.findMany({ take: 10 })
     * 
     * // Only select the `cedulaEmpleado`
     * const seleccionaWithCedulaEmpleadoOnly = await prisma.selecciona.findMany({ select: { cedulaEmpleado: true } })
     * 
    **/
    findMany<T extends seleccionaFindManyArgs>(
      args?: SelectSubset<T, seleccionaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<selecciona>>, PrismaPromise<Array<seleccionaGetPayload<T>>>>

    /**
     * Create a Selecciona.
     * @param {seleccionaCreateArgs} args - Arguments to create a Selecciona.
     * @example
     * // Create one Selecciona
     * const Selecciona = await prisma.selecciona.create({
     *   data: {
     *     // ... data to create a Selecciona
     *   }
     * })
     * 
    **/
    create<T extends seleccionaCreateArgs>(
      args: SelectSubset<T, seleccionaCreateArgs>
    ): CheckSelect<T, Prisma__seleccionaClient<selecciona>, Prisma__seleccionaClient<seleccionaGetPayload<T>>>

    /**
     * Create many Seleccionas.
     *     @param {seleccionaCreateManyArgs} args - Arguments to create many Seleccionas.
     *     @example
     *     // Create many Seleccionas
     *     const selecciona = await prisma.selecciona.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends seleccionaCreateManyArgs>(
      args?: SelectSubset<T, seleccionaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Selecciona.
     * @param {seleccionaDeleteArgs} args - Arguments to delete one Selecciona.
     * @example
     * // Delete one Selecciona
     * const Selecciona = await prisma.selecciona.delete({
     *   where: {
     *     // ... filter to delete one Selecciona
     *   }
     * })
     * 
    **/
    delete<T extends seleccionaDeleteArgs>(
      args: SelectSubset<T, seleccionaDeleteArgs>
    ): CheckSelect<T, Prisma__seleccionaClient<selecciona>, Prisma__seleccionaClient<seleccionaGetPayload<T>>>

    /**
     * Update one Selecciona.
     * @param {seleccionaUpdateArgs} args - Arguments to update one Selecciona.
     * @example
     * // Update one Selecciona
     * const selecciona = await prisma.selecciona.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends seleccionaUpdateArgs>(
      args: SelectSubset<T, seleccionaUpdateArgs>
    ): CheckSelect<T, Prisma__seleccionaClient<selecciona>, Prisma__seleccionaClient<seleccionaGetPayload<T>>>

    /**
     * Delete zero or more Seleccionas.
     * @param {seleccionaDeleteManyArgs} args - Arguments to filter Seleccionas to delete.
     * @example
     * // Delete a few Seleccionas
     * const { count } = await prisma.selecciona.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends seleccionaDeleteManyArgs>(
      args?: SelectSubset<T, seleccionaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seleccionas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seleccionaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seleccionas
     * const selecciona = await prisma.selecciona.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends seleccionaUpdateManyArgs>(
      args: SelectSubset<T, seleccionaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Selecciona.
     * @param {seleccionaUpsertArgs} args - Arguments to update or create a Selecciona.
     * @example
     * // Update or create a Selecciona
     * const selecciona = await prisma.selecciona.upsert({
     *   create: {
     *     // ... data to create a Selecciona
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Selecciona we want to update
     *   }
     * })
    **/
    upsert<T extends seleccionaUpsertArgs>(
      args: SelectSubset<T, seleccionaUpsertArgs>
    ): CheckSelect<T, Prisma__seleccionaClient<selecciona>, Prisma__seleccionaClient<seleccionaGetPayload<T>>>

    /**
     * Count the number of Seleccionas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seleccionaCountArgs} args - Arguments to filter Seleccionas to count.
     * @example
     * // Count the number of Seleccionas
     * const count = await prisma.selecciona.count({
     *   where: {
     *     // ... the filter for the Seleccionas we want to count
     *   }
     * })
    **/
    count<T extends seleccionaCountArgs>(
      args?: Subset<T, seleccionaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeleccionaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Selecciona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeleccionaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeleccionaAggregateArgs>(args: Subset<T, SeleccionaAggregateArgs>): PrismaPromise<GetSeleccionaAggregateType<T>>

    /**
     * Group by Selecciona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeleccionaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeleccionaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeleccionaGroupByArgs['orderBy'] }
        : { orderBy?: SeleccionaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeleccionaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeleccionaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for selecciona.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__seleccionaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empleado<T extends empleadoArgs = {}>(args?: Subset<T, empleadoArgs>): CheckSelect<T, Prisma__empleadoClient<empleado | null >, Prisma__empleadoClient<empleadoGetPayload<T> | null >>;

    beneficios<T extends beneficiosArgs = {}>(args?: Subset<T, beneficiosArgs>): CheckSelect<T, Prisma__beneficiosClient<beneficios | null >, Prisma__beneficiosClient<beneficiosGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * selecciona findUnique
   */
  export type seleccionaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the selecciona
     * 
    **/
    select?: seleccionaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: seleccionaInclude | null
    /**
     * Throw an Error if a selecciona can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which selecciona to fetch.
     * 
    **/
    where: seleccionaWhereUniqueInput
  }


  /**
   * selecciona findFirst
   */
  export type seleccionaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the selecciona
     * 
    **/
    select?: seleccionaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: seleccionaInclude | null
    /**
     * Throw an Error if a selecciona can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which selecciona to fetch.
     * 
    **/
    where?: seleccionaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seleccionas to fetch.
     * 
    **/
    orderBy?: Enumerable<seleccionaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seleccionas.
     * 
    **/
    cursor?: seleccionaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seleccionas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seleccionas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seleccionas.
     * 
    **/
    distinct?: Enumerable<SeleccionaScalarFieldEnum>
  }


  /**
   * selecciona findMany
   */
  export type seleccionaFindManyArgs = {
    /**
     * Select specific fields to fetch from the selecciona
     * 
    **/
    select?: seleccionaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: seleccionaInclude | null
    /**
     * Filter, which seleccionas to fetch.
     * 
    **/
    where?: seleccionaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seleccionas to fetch.
     * 
    **/
    orderBy?: Enumerable<seleccionaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seleccionas.
     * 
    **/
    cursor?: seleccionaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seleccionas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seleccionas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SeleccionaScalarFieldEnum>
  }


  /**
   * selecciona create
   */
  export type seleccionaCreateArgs = {
    /**
     * Select specific fields to fetch from the selecciona
     * 
    **/
    select?: seleccionaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: seleccionaInclude | null
    /**
     * The data needed to create a selecciona.
     * 
    **/
    data: XOR<seleccionaCreateInput, seleccionaUncheckedCreateInput>
  }


  /**
   * selecciona createMany
   */
  export type seleccionaCreateManyArgs = {
    /**
     * The data used to create many seleccionas.
     * 
    **/
    data: Enumerable<seleccionaCreateManyInput>
  }


  /**
   * selecciona update
   */
  export type seleccionaUpdateArgs = {
    /**
     * Select specific fields to fetch from the selecciona
     * 
    **/
    select?: seleccionaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: seleccionaInclude | null
    /**
     * The data needed to update a selecciona.
     * 
    **/
    data: XOR<seleccionaUpdateInput, seleccionaUncheckedUpdateInput>
    /**
     * Choose, which selecciona to update.
     * 
    **/
    where: seleccionaWhereUniqueInput
  }


  /**
   * selecciona updateMany
   */
  export type seleccionaUpdateManyArgs = {
    /**
     * The data used to update seleccionas.
     * 
    **/
    data: XOR<seleccionaUpdateManyMutationInput, seleccionaUncheckedUpdateManyInput>
    /**
     * Filter which seleccionas to update
     * 
    **/
    where?: seleccionaWhereInput
  }


  /**
   * selecciona upsert
   */
  export type seleccionaUpsertArgs = {
    /**
     * Select specific fields to fetch from the selecciona
     * 
    **/
    select?: seleccionaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: seleccionaInclude | null
    /**
     * The filter to search for the selecciona to update in case it exists.
     * 
    **/
    where: seleccionaWhereUniqueInput
    /**
     * In case the selecciona found by the `where` argument doesn't exist, create a new selecciona with this data.
     * 
    **/
    create: XOR<seleccionaCreateInput, seleccionaUncheckedCreateInput>
    /**
     * In case the selecciona was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<seleccionaUpdateInput, seleccionaUncheckedUpdateInput>
  }


  /**
   * selecciona delete
   */
  export type seleccionaDeleteArgs = {
    /**
     * Select specific fields to fetch from the selecciona
     * 
    **/
    select?: seleccionaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: seleccionaInclude | null
    /**
     * Filter which selecciona to delete.
     * 
    **/
    where: seleccionaWhereUniqueInput
  }


  /**
   * selecciona deleteMany
   */
  export type seleccionaDeleteManyArgs = {
    /**
     * Filter which seleccionas to delete
     * 
    **/
    where?: seleccionaWhereInput
  }


  /**
   * selecciona without action
   */
  export type seleccionaArgs = {
    /**
     * Select specific fields to fetch from the selecciona
     * 
    **/
    select?: seleccionaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: seleccionaInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Aplica_bScalarFieldEnum: {
    cedulaEmpleado: 'cedulaEmpleado',
    fechaHora: 'fechaHora',
    cedulaJuridica: 'cedulaJuridica',
    nombreProyecto: 'nombreProyecto',
    nombreBeneficio: 'nombreBeneficio'
  };

  export type Aplica_bScalarFieldEnum = (typeof Aplica_bScalarFieldEnum)[keyof typeof Aplica_bScalarFieldEnum]


  export const Aplica_doScalarFieldEnum: {
    cedulaEmpleado: 'cedulaEmpleado',
    fechaHora: 'fechaHora',
    nombreDO: 'nombreDO'
  };

  export type Aplica_doScalarFieldEnum = (typeof Aplica_doScalarFieldEnum)[keyof typeof Aplica_doScalarFieldEnum]


  export const Aplica_dvScalarFieldEnum: {
    cedulaEmpleado: 'cedulaEmpleado',
    fechaHora: 'fechaHora',
    cedulaJuridica: 'cedulaJuridica',
    nombreProyecto: 'nombreProyecto',
    nombreDeduccion: 'nombreDeduccion'
  };

  export type Aplica_dvScalarFieldEnum = (typeof Aplica_dvScalarFieldEnum)[keyof typeof Aplica_dvScalarFieldEnum]


  export const BeneficiosScalarFieldEnum: {
    cedulaJuridica: 'cedulaJuridica',
    nombreProyecto: 'nombreProyecto',
    nombreBeneficio: 'nombreBeneficio',
    montoPago: 'montoPago',
    descripcion: 'descripcion',
    habilitado: 'habilitado'
  };

  export type BeneficiosScalarFieldEnum = (typeof BeneficiosScalarFieldEnum)[keyof typeof BeneficiosScalarFieldEnum]


  export const CredencialesScalarFieldEnum: {
    email: 'email',
    contrasenna: 'contrasenna',
    verificado: 'verificado'
  };

  export type CredencialesScalarFieldEnum = (typeof CredencialesScalarFieldEnum)[keyof typeof CredencialesScalarFieldEnum]


  export const DeduccionObligatoriaScalarFieldEnum: {
    nombre: 'nombre',
    porcentaje: 'porcentaje'
  };

  export type DeduccionObligatoriaScalarFieldEnum = (typeof DeduccionObligatoriaScalarFieldEnum)[keyof typeof DeduccionObligatoriaScalarFieldEnum]


  export const DeduccionVoluntariaScalarFieldEnum: {
    cedulaJuridica: 'cedulaJuridica',
    nombreProyecto: 'nombreProyecto',
    nombreDeduccion: 'nombreDeduccion',
    descripcion: 'descripcion',
    monto: 'monto',
    habilitado: 'habilitado'
  };

  export type DeduccionVoluntariaScalarFieldEnum = (typeof DeduccionVoluntariaScalarFieldEnum)[keyof typeof DeduccionVoluntariaScalarFieldEnum]


  export const EmpleadoScalarFieldEnum: {
    cedula: 'cedula',
    cedulaJuridica: 'cedulaJuridica'
  };

  export type EmpleadoScalarFieldEnum = (typeof EmpleadoScalarFieldEnum)[keyof typeof EmpleadoScalarFieldEnum]


  export const EmpleadorScalarFieldEnum: {
    cedula: 'cedula'
  };

  export type EmpleadorScalarFieldEnum = (typeof EmpleadorScalarFieldEnum)[keyof typeof EmpleadorScalarFieldEnum]


  export const EmpresaScalarFieldEnum: {
    cedulaJuridica: 'cedulaJuridica',
    direccion: 'direccion',
    razonSocial: 'razonSocial',
    email: 'email',
    habilitado: 'habilitado',
    cedulaEmpleador: 'cedulaEmpleador',
    telefono: 'telefono'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const EscogeScalarFieldEnum: {
    cedulaEmpleado: 'cedulaEmpleado',
    cedulaJuridica: 'cedulaJuridica',
    nombreProyecto: 'nombreProyecto',
    nombreDeduccion: 'nombreDeduccion',
    aporte: 'aporte'
  };

  export type EscogeScalarFieldEnum = (typeof EscogeScalarFieldEnum)[keyof typeof EscogeScalarFieldEnum]


  export const EsContratadoScalarFieldEnum: {
    cedulaJuridica: 'cedulaJuridica',
    nombreProyecto: 'nombreProyecto',
    cedulaEmpleado: 'cedulaEmpleado',
    tipoEmpleado: 'tipoEmpleado',
    puesto: 'puesto',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    jornada: 'jornada',
    salario: 'salario'
  };

  export type EsContratadoScalarFieldEnum = (typeof EsContratadoScalarFieldEnum)[keyof typeof EsContratadoScalarFieldEnum]


  export const GeneraScalarFieldEnum: {
    cedulaEmpleado: 'cedulaEmpleado',
    fechaHora: 'fechaHora',
    cedulaJuridica: 'cedulaJuridica',
    nombreProyecto: 'nombreProyecto'
  };

  export type GeneraScalarFieldEnum = (typeof GeneraScalarFieldEnum)[keyof typeof GeneraScalarFieldEnum]


  export const Hace_usoScalarFieldEnum: {
    cedula: 'cedula',
    email: 'email'
  };

  export type Hace_usoScalarFieldEnum = (typeof Hace_usoScalarFieldEnum)[keyof typeof Hace_usoScalarFieldEnum]


  export const PagoScalarFieldEnum: {
    cedulaEmpleado: 'cedulaEmpleado',
    fechaHora: 'fechaHora',
    deduccionesEmpleado: 'deduccionesEmpleado',
    deduccionesPatrono: 'deduccionesPatrono',
    salarioBruto: 'salarioBruto',
    beneficios: 'beneficios',
    salarioNeto: 'salarioNeto',
    deduccionesVoluntarias: 'deduccionesVoluntarias'
  };

  export type PagoScalarFieldEnum = (typeof PagoScalarFieldEnum)[keyof typeof PagoScalarFieldEnum]


  export const PersonaScalarFieldEnum: {
    cedula: 'cedula',
    nombre: 'nombre',
    telefono: 'telefono'
  };

  export type PersonaScalarFieldEnum = (typeof PersonaScalarFieldEnum)[keyof typeof PersonaScalarFieldEnum]


  export const ProyectoScalarFieldEnum: {
    cedulaJuridica: 'cedulaJuridica',
    nombre: 'nombre',
    cantidadMaximaBeneficios: 'cantidadMaximaBeneficios',
    montoMaximoBeneficio: 'montoMaximoBeneficio',
    frecuenciaPago: 'frecuenciaPago',
    moneda: 'moneda',
    fechaInicio: 'fechaInicio',
    habilitado: 'habilitado',
    fechaFin: 'fechaFin',
    fechaUltimoPago: 'fechaUltimoPago'
  };

  export type ProyectoScalarFieldEnum = (typeof ProyectoScalarFieldEnum)[keyof typeof ProyectoScalarFieldEnum]


  export const ReporteHorasScalarFieldEnum: {
    cedulaEmpleado: 'cedulaEmpleado',
    cedulaEmpleador: 'cedulaEmpleador',
    cedulaJuridica: 'cedulaJuridica',
    nombreProyecto: 'nombreProyecto',
    fechaHora: 'fechaHora',
    horasTrabajadas: 'horasTrabajadas',
    estado: 'estado'
  };

  export type ReporteHorasScalarFieldEnum = (typeof ReporteHorasScalarFieldEnum)[keyof typeof ReporteHorasScalarFieldEnum]


  export const SeleccionaScalarFieldEnum: {
    cedulaEmpleado: 'cedulaEmpleado',
    cedulaJuridica: 'cedulaJuridica',
    nombreProyecto: 'nombreProyecto',
    nombreBeneficio: 'nombreBeneficio'
  };

  export type SeleccionaScalarFieldEnum = (typeof SeleccionaScalarFieldEnum)[keyof typeof SeleccionaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type aplica_bWhereInput = {
    AND?: Enumerable<aplica_bWhereInput>
    OR?: Enumerable<aplica_bWhereInput>
    NOT?: Enumerable<aplica_bWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreBeneficio?: StringFilter | string
    pago?: XOR<PagoRelationFilter, pagoWhereInput>
    beneficios?: XOR<BeneficiosRelationFilter, beneficiosWhereInput>
  }

  export type aplica_bOrderByWithRelationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
    pago?: pagoOrderByWithRelationInput
    beneficios?: beneficiosOrderByWithRelationInput
  }

  export type aplica_bWhereUniqueInput = {
    cedulaEmpleado_fechaHora_cedulaJuridica_nombreProyecto_nombreBeneficio?: aplica_bCedulaEmpleadoFechaHoraCedulaJuridicaNombreProyectoNombreBeneficioCompoundUniqueInput
  }

  export type aplica_bOrderByWithAggregationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
    _count?: aplica_bCountOrderByAggregateInput
    _max?: aplica_bMaxOrderByAggregateInput
    _min?: aplica_bMinOrderByAggregateInput
  }

  export type aplica_bScalarWhereWithAggregatesInput = {
    AND?: Enumerable<aplica_bScalarWhereWithAggregatesInput>
    OR?: Enumerable<aplica_bScalarWhereWithAggregatesInput>
    NOT?: Enumerable<aplica_bScalarWhereWithAggregatesInput>
    cedulaEmpleado?: StringWithAggregatesFilter | string
    fechaHora?: DateTimeWithAggregatesFilter | Date | string
    cedulaJuridica?: StringWithAggregatesFilter | string
    nombreProyecto?: StringWithAggregatesFilter | string
    nombreBeneficio?: StringWithAggregatesFilter | string
  }

  export type aplica_doWhereInput = {
    AND?: Enumerable<aplica_doWhereInput>
    OR?: Enumerable<aplica_doWhereInput>
    NOT?: Enumerable<aplica_doWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    nombreDO?: StringFilter | string
    pago?: XOR<PagoRelationFilter, pagoWhereInput>
    deduccionObligatoria?: XOR<DeduccionObligatoriaRelationFilter, deduccionObligatoriaWhereInput>
  }

  export type aplica_doOrderByWithRelationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    nombreDO?: SortOrder
    pago?: pagoOrderByWithRelationInput
    deduccionObligatoria?: deduccionObligatoriaOrderByWithRelationInput
  }

  export type aplica_doWhereUniqueInput = {
    cedulaEmpleado_fechaHora_nombreDO?: aplica_doCedulaEmpleadoFechaHoraNombreDOCompoundUniqueInput
  }

  export type aplica_doOrderByWithAggregationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    nombreDO?: SortOrder
    _count?: aplica_doCountOrderByAggregateInput
    _max?: aplica_doMaxOrderByAggregateInput
    _min?: aplica_doMinOrderByAggregateInput
  }

  export type aplica_doScalarWhereWithAggregatesInput = {
    AND?: Enumerable<aplica_doScalarWhereWithAggregatesInput>
    OR?: Enumerable<aplica_doScalarWhereWithAggregatesInput>
    NOT?: Enumerable<aplica_doScalarWhereWithAggregatesInput>
    cedulaEmpleado?: StringWithAggregatesFilter | string
    fechaHora?: DateTimeWithAggregatesFilter | Date | string
    nombreDO?: StringWithAggregatesFilter | string
  }

  export type aplica_dvWhereInput = {
    AND?: Enumerable<aplica_dvWhereInput>
    OR?: Enumerable<aplica_dvWhereInput>
    NOT?: Enumerable<aplica_dvWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreDeduccion?: StringFilter | string
    pago?: XOR<PagoRelationFilter, pagoWhereInput>
    deduccionVoluntaria?: XOR<DeduccionVoluntariaRelationFilter, deduccionVoluntariaWhereInput>
  }

  export type aplica_dvOrderByWithRelationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    pago?: pagoOrderByWithRelationInput
    deduccionVoluntaria?: deduccionVoluntariaOrderByWithRelationInput
  }

  export type aplica_dvWhereUniqueInput = {
    cedulaEmpleado_fechaHora_cedulaJuridica_nombreProyecto_nombreDeduccion?: aplica_dvCedulaEmpleadoFechaHoraCedulaJuridicaNombreProyectoNombreDeduccionCompoundUniqueInput
  }

  export type aplica_dvOrderByWithAggregationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    _count?: aplica_dvCountOrderByAggregateInput
    _max?: aplica_dvMaxOrderByAggregateInput
    _min?: aplica_dvMinOrderByAggregateInput
  }

  export type aplica_dvScalarWhereWithAggregatesInput = {
    AND?: Enumerable<aplica_dvScalarWhereWithAggregatesInput>
    OR?: Enumerable<aplica_dvScalarWhereWithAggregatesInput>
    NOT?: Enumerable<aplica_dvScalarWhereWithAggregatesInput>
    cedulaEmpleado?: StringWithAggregatesFilter | string
    fechaHora?: DateTimeWithAggregatesFilter | Date | string
    cedulaJuridica?: StringWithAggregatesFilter | string
    nombreProyecto?: StringWithAggregatesFilter | string
    nombreDeduccion?: StringWithAggregatesFilter | string
  }

  export type beneficiosWhereInput = {
    AND?: Enumerable<beneficiosWhereInput>
    OR?: Enumerable<beneficiosWhereInput>
    NOT?: Enumerable<beneficiosWhereInput>
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreBeneficio?: StringFilter | string
    montoPago?: FloatNullableFilter | number | null
    descripcion?: StringNullableFilter | string | null
    habilitado?: BoolNullableFilter | boolean | null
    proyecto?: XOR<ProyectoRelationFilter, proyectoWhereInput>
    aplica_b?: Aplica_bListRelationFilter
    selecciona?: SeleccionaListRelationFilter
  }

  export type beneficiosOrderByWithRelationInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
    montoPago?: SortOrder
    descripcion?: SortOrder
    habilitado?: SortOrder
    proyecto?: proyectoOrderByWithRelationInput
    aplica_b?: aplica_bOrderByRelationAggregateInput
    selecciona?: seleccionaOrderByRelationAggregateInput
  }

  export type beneficiosWhereUniqueInput = {
    cedulaJuridica_nombreProyecto_nombreBeneficio?: beneficiosCedulaJuridicaNombreProyectoNombreBeneficioCompoundUniqueInput
  }

  export type beneficiosOrderByWithAggregationInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
    montoPago?: SortOrder
    descripcion?: SortOrder
    habilitado?: SortOrder
    _count?: beneficiosCountOrderByAggregateInput
    _avg?: beneficiosAvgOrderByAggregateInput
    _max?: beneficiosMaxOrderByAggregateInput
    _min?: beneficiosMinOrderByAggregateInput
    _sum?: beneficiosSumOrderByAggregateInput
  }

  export type beneficiosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<beneficiosScalarWhereWithAggregatesInput>
    OR?: Enumerable<beneficiosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<beneficiosScalarWhereWithAggregatesInput>
    cedulaJuridica?: StringWithAggregatesFilter | string
    nombreProyecto?: StringWithAggregatesFilter | string
    nombreBeneficio?: StringWithAggregatesFilter | string
    montoPago?: FloatNullableWithAggregatesFilter | number | null
    descripcion?: StringNullableWithAggregatesFilter | string | null
    habilitado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type credencialesWhereInput = {
    AND?: Enumerable<credencialesWhereInput>
    OR?: Enumerable<credencialesWhereInput>
    NOT?: Enumerable<credencialesWhereInput>
    email?: StringFilter | string
    contrasenna?: StringNullableFilter | string | null
    verificado?: BoolNullableFilter | boolean | null
    hace_uso?: Hace_usoListRelationFilter
  }

  export type credencialesOrderByWithRelationInput = {
    email?: SortOrder
    contrasenna?: SortOrder
    verificado?: SortOrder
    hace_uso?: hace_usoOrderByRelationAggregateInput
  }

  export type credencialesWhereUniqueInput = {
    email?: string
  }

  export type credencialesOrderByWithAggregationInput = {
    email?: SortOrder
    contrasenna?: SortOrder
    verificado?: SortOrder
    _count?: credencialesCountOrderByAggregateInput
    _max?: credencialesMaxOrderByAggregateInput
    _min?: credencialesMinOrderByAggregateInput
  }

  export type credencialesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<credencialesScalarWhereWithAggregatesInput>
    OR?: Enumerable<credencialesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<credencialesScalarWhereWithAggregatesInput>
    email?: StringWithAggregatesFilter | string
    contrasenna?: StringNullableWithAggregatesFilter | string | null
    verificado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type deduccionObligatoriaWhereInput = {
    AND?: Enumerable<deduccionObligatoriaWhereInput>
    OR?: Enumerable<deduccionObligatoriaWhereInput>
    NOT?: Enumerable<deduccionObligatoriaWhereInput>
    nombre?: StringFilter | string
    porcentaje?: FloatNullableFilter | number | null
    aplica_do?: Aplica_doListRelationFilter
  }

  export type deduccionObligatoriaOrderByWithRelationInput = {
    nombre?: SortOrder
    porcentaje?: SortOrder
    aplica_do?: aplica_doOrderByRelationAggregateInput
  }

  export type deduccionObligatoriaWhereUniqueInput = {
    nombre?: string
  }

  export type deduccionObligatoriaOrderByWithAggregationInput = {
    nombre?: SortOrder
    porcentaje?: SortOrder
    _count?: deduccionObligatoriaCountOrderByAggregateInput
    _avg?: deduccionObligatoriaAvgOrderByAggregateInput
    _max?: deduccionObligatoriaMaxOrderByAggregateInput
    _min?: deduccionObligatoriaMinOrderByAggregateInput
    _sum?: deduccionObligatoriaSumOrderByAggregateInput
  }

  export type deduccionObligatoriaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<deduccionObligatoriaScalarWhereWithAggregatesInput>
    OR?: Enumerable<deduccionObligatoriaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<deduccionObligatoriaScalarWhereWithAggregatesInput>
    nombre?: StringWithAggregatesFilter | string
    porcentaje?: FloatNullableWithAggregatesFilter | number | null
  }

  export type deduccionVoluntariaWhereInput = {
    AND?: Enumerable<deduccionVoluntariaWhereInput>
    OR?: Enumerable<deduccionVoluntariaWhereInput>
    NOT?: Enumerable<deduccionVoluntariaWhereInput>
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreDeduccion?: StringFilter | string
    descripcion?: StringNullableFilter | string | null
    monto?: FloatNullableFilter | number | null
    habilitado?: BoolNullableFilter | boolean | null
    proyecto?: XOR<ProyectoRelationFilter, proyectoWhereInput>
    aplica_dv?: Aplica_dvListRelationFilter
    escoge?: EscogeListRelationFilter
  }

  export type deduccionVoluntariaOrderByWithRelationInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    habilitado?: SortOrder
    proyecto?: proyectoOrderByWithRelationInput
    aplica_dv?: aplica_dvOrderByRelationAggregateInput
    escoge?: escogeOrderByRelationAggregateInput
  }

  export type deduccionVoluntariaWhereUniqueInput = {
    cedulaJuridica_nombreProyecto_nombreDeduccion?: deduccionVoluntariaCedulaJuridicaNombreProyectoNombreDeduccionCompoundUniqueInput
  }

  export type deduccionVoluntariaOrderByWithAggregationInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    habilitado?: SortOrder
    _count?: deduccionVoluntariaCountOrderByAggregateInput
    _avg?: deduccionVoluntariaAvgOrderByAggregateInput
    _max?: deduccionVoluntariaMaxOrderByAggregateInput
    _min?: deduccionVoluntariaMinOrderByAggregateInput
    _sum?: deduccionVoluntariaSumOrderByAggregateInput
  }

  export type deduccionVoluntariaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<deduccionVoluntariaScalarWhereWithAggregatesInput>
    OR?: Enumerable<deduccionVoluntariaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<deduccionVoluntariaScalarWhereWithAggregatesInput>
    cedulaJuridica?: StringWithAggregatesFilter | string
    nombreProyecto?: StringWithAggregatesFilter | string
    nombreDeduccion?: StringWithAggregatesFilter | string
    descripcion?: StringNullableWithAggregatesFilter | string | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    habilitado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type empleadoWhereInput = {
    AND?: Enumerable<empleadoWhereInput>
    OR?: Enumerable<empleadoWhereInput>
    NOT?: Enumerable<empleadoWhereInput>
    cedula?: StringFilter | string
    cedulaJuridica?: StringNullableFilter | string | null
    persona?: XOR<PersonaRelationFilter, personaWhereInput>
    empresa?: XOR<EmpresaRelationFilter, empresaWhereInput> | null
    escoge?: EscogeListRelationFilter
    esContratado?: EsContratadoListRelationFilter
    pago?: PagoListRelationFilter
    reporteHoras?: ReporteHorasListRelationFilter
    selecciona?: SeleccionaListRelationFilter
  }

  export type empleadoOrderByWithRelationInput = {
    cedula?: SortOrder
    cedulaJuridica?: SortOrder
    persona?: personaOrderByWithRelationInput
    empresa?: empresaOrderByWithRelationInput
    escoge?: escogeOrderByRelationAggregateInput
    esContratado?: esContratadoOrderByRelationAggregateInput
    pago?: pagoOrderByRelationAggregateInput
    reporteHoras?: reporteHorasOrderByRelationAggregateInput
    selecciona?: seleccionaOrderByRelationAggregateInput
  }

  export type empleadoWhereUniqueInput = {
    cedula?: string
  }

  export type empleadoOrderByWithAggregationInput = {
    cedula?: SortOrder
    cedulaJuridica?: SortOrder
    _count?: empleadoCountOrderByAggregateInput
    _max?: empleadoMaxOrderByAggregateInput
    _min?: empleadoMinOrderByAggregateInput
  }

  export type empleadoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<empleadoScalarWhereWithAggregatesInput>
    OR?: Enumerable<empleadoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<empleadoScalarWhereWithAggregatesInput>
    cedula?: StringWithAggregatesFilter | string
    cedulaJuridica?: StringNullableWithAggregatesFilter | string | null
  }

  export type empleadorWhereInput = {
    AND?: Enumerable<empleadorWhereInput>
    OR?: Enumerable<empleadorWhereInput>
    NOT?: Enumerable<empleadorWhereInput>
    cedula?: StringFilter | string
    persona?: XOR<PersonaRelationFilter, personaWhereInput>
    empresa?: EmpresaListRelationFilter
    reporteHoras?: ReporteHorasListRelationFilter
  }

  export type empleadorOrderByWithRelationInput = {
    cedula?: SortOrder
    persona?: personaOrderByWithRelationInput
    empresa?: empresaOrderByRelationAggregateInput
    reporteHoras?: reporteHorasOrderByRelationAggregateInput
  }

  export type empleadorWhereUniqueInput = {
    cedula?: string
  }

  export type empleadorOrderByWithAggregationInput = {
    cedula?: SortOrder
    _count?: empleadorCountOrderByAggregateInput
    _max?: empleadorMaxOrderByAggregateInput
    _min?: empleadorMinOrderByAggregateInput
  }

  export type empleadorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<empleadorScalarWhereWithAggregatesInput>
    OR?: Enumerable<empleadorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<empleadorScalarWhereWithAggregatesInput>
    cedula?: StringWithAggregatesFilter | string
  }

  export type empresaWhereInput = {
    AND?: Enumerable<empresaWhereInput>
    OR?: Enumerable<empresaWhereInput>
    NOT?: Enumerable<empresaWhereInput>
    cedulaJuridica?: StringFilter | string
    direccion?: StringNullableFilter | string | null
    razonSocial?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    habilitado?: BoolNullableFilter | boolean | null
    cedulaEmpleador?: StringNullableFilter | string | null
    telefono?: StringNullableFilter | string | null
    empleador?: XOR<EmpleadorRelationFilter, empleadorWhereInput> | null
    empleado?: EmpleadoListRelationFilter
    proyecto?: ProyectoListRelationFilter
  }

  export type empresaOrderByWithRelationInput = {
    cedulaJuridica?: SortOrder
    direccion?: SortOrder
    razonSocial?: SortOrder
    email?: SortOrder
    habilitado?: SortOrder
    cedulaEmpleador?: SortOrder
    telefono?: SortOrder
    empleador?: empleadorOrderByWithRelationInput
    empleado?: empleadoOrderByRelationAggregateInput
    proyecto?: proyectoOrderByRelationAggregateInput
  }

  export type empresaWhereUniqueInput = {
    cedulaJuridica?: string
  }

  export type empresaOrderByWithAggregationInput = {
    cedulaJuridica?: SortOrder
    direccion?: SortOrder
    razonSocial?: SortOrder
    email?: SortOrder
    habilitado?: SortOrder
    cedulaEmpleador?: SortOrder
    telefono?: SortOrder
    _count?: empresaCountOrderByAggregateInput
    _max?: empresaMaxOrderByAggregateInput
    _min?: empresaMinOrderByAggregateInput
  }

  export type empresaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<empresaScalarWhereWithAggregatesInput>
    OR?: Enumerable<empresaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<empresaScalarWhereWithAggregatesInput>
    cedulaJuridica?: StringWithAggregatesFilter | string
    direccion?: StringNullableWithAggregatesFilter | string | null
    razonSocial?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    habilitado?: BoolNullableWithAggregatesFilter | boolean | null
    cedulaEmpleador?: StringNullableWithAggregatesFilter | string | null
    telefono?: StringNullableWithAggregatesFilter | string | null
  }

  export type escogeWhereInput = {
    AND?: Enumerable<escogeWhereInput>
    OR?: Enumerable<escogeWhereInput>
    NOT?: Enumerable<escogeWhereInput>
    cedulaEmpleado?: StringFilter | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreDeduccion?: StringFilter | string
    aporte?: FloatNullableFilter | number | null
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    deduccionVoluntaria?: XOR<DeduccionVoluntariaRelationFilter, deduccionVoluntariaWhereInput>
  }

  export type escogeOrderByWithRelationInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    aporte?: SortOrder
    empleado?: empleadoOrderByWithRelationInput
    deduccionVoluntaria?: deduccionVoluntariaOrderByWithRelationInput
  }

  export type escogeWhereUniqueInput = {
    cedulaEmpleado_cedulaJuridica_nombreProyecto_nombreDeduccion?: escogeCedulaEmpleadoCedulaJuridicaNombreProyectoNombreDeduccionCompoundUniqueInput
  }

  export type escogeOrderByWithAggregationInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    aporte?: SortOrder
    _count?: escogeCountOrderByAggregateInput
    _avg?: escogeAvgOrderByAggregateInput
    _max?: escogeMaxOrderByAggregateInput
    _min?: escogeMinOrderByAggregateInput
    _sum?: escogeSumOrderByAggregateInput
  }

  export type escogeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<escogeScalarWhereWithAggregatesInput>
    OR?: Enumerable<escogeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<escogeScalarWhereWithAggregatesInput>
    cedulaEmpleado?: StringWithAggregatesFilter | string
    cedulaJuridica?: StringWithAggregatesFilter | string
    nombreProyecto?: StringWithAggregatesFilter | string
    nombreDeduccion?: StringWithAggregatesFilter | string
    aporte?: FloatNullableWithAggregatesFilter | number | null
  }

  export type esContratadoWhereInput = {
    AND?: Enumerable<esContratadoWhereInput>
    OR?: Enumerable<esContratadoWhereInput>
    NOT?: Enumerable<esContratadoWhereInput>
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    cedulaEmpleado?: StringFilter | string
    tipoEmpleado?: StringNullableFilter | string | null
    puesto?: StringNullableFilter | string | null
    fechaInicio?: DateTimeNullableFilter | Date | string | null
    fechaFin?: DateTimeNullableFilter | Date | string | null
    jornada?: StringNullableFilter | string | null
    salario?: FloatNullableFilter | number | null
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    proyecto?: XOR<ProyectoRelationFilter, proyectoWhereInput>
  }

  export type esContratadoOrderByWithRelationInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    cedulaEmpleado?: SortOrder
    tipoEmpleado?: SortOrder
    puesto?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    jornada?: SortOrder
    salario?: SortOrder
    empleado?: empleadoOrderByWithRelationInput
    proyecto?: proyectoOrderByWithRelationInput
  }

  export type esContratadoWhereUniqueInput = {
    cedulaJuridica_nombreProyecto_cedulaEmpleado?: esContratadoCedulaJuridicaNombreProyectoCedulaEmpleadoCompoundUniqueInput
  }

  export type esContratadoOrderByWithAggregationInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    cedulaEmpleado?: SortOrder
    tipoEmpleado?: SortOrder
    puesto?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    jornada?: SortOrder
    salario?: SortOrder
    _count?: esContratadoCountOrderByAggregateInput
    _avg?: esContratadoAvgOrderByAggregateInput
    _max?: esContratadoMaxOrderByAggregateInput
    _min?: esContratadoMinOrderByAggregateInput
    _sum?: esContratadoSumOrderByAggregateInput
  }

  export type esContratadoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<esContratadoScalarWhereWithAggregatesInput>
    OR?: Enumerable<esContratadoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<esContratadoScalarWhereWithAggregatesInput>
    cedulaJuridica?: StringWithAggregatesFilter | string
    nombreProyecto?: StringWithAggregatesFilter | string
    cedulaEmpleado?: StringWithAggregatesFilter | string
    tipoEmpleado?: StringNullableWithAggregatesFilter | string | null
    puesto?: StringNullableWithAggregatesFilter | string | null
    fechaInicio?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fechaFin?: DateTimeNullableWithAggregatesFilter | Date | string | null
    jornada?: StringNullableWithAggregatesFilter | string | null
    salario?: FloatNullableWithAggregatesFilter | number | null
  }

  export type generaWhereInput = {
    AND?: Enumerable<generaWhereInput>
    OR?: Enumerable<generaWhereInput>
    NOT?: Enumerable<generaWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    pago?: XOR<PagoRelationFilter, pagoWhereInput>
    proyecto?: XOR<ProyectoRelationFilter, proyectoWhereInput>
  }

  export type generaOrderByWithRelationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    pago?: pagoOrderByWithRelationInput
    proyecto?: proyectoOrderByWithRelationInput
  }

  export type generaWhereUniqueInput = {
    cedulaEmpleado_fechaHora_cedulaJuridica_nombreProyecto?: generaCedulaEmpleadoFechaHoraCedulaJuridicaNombreProyectoCompoundUniqueInput
  }

  export type generaOrderByWithAggregationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    _count?: generaCountOrderByAggregateInput
    _max?: generaMaxOrderByAggregateInput
    _min?: generaMinOrderByAggregateInput
  }

  export type generaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<generaScalarWhereWithAggregatesInput>
    OR?: Enumerable<generaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<generaScalarWhereWithAggregatesInput>
    cedulaEmpleado?: StringWithAggregatesFilter | string
    fechaHora?: DateTimeWithAggregatesFilter | Date | string
    cedulaJuridica?: StringWithAggregatesFilter | string
    nombreProyecto?: StringWithAggregatesFilter | string
  }

  export type hace_usoWhereInput = {
    AND?: Enumerable<hace_usoWhereInput>
    OR?: Enumerable<hace_usoWhereInput>
    NOT?: Enumerable<hace_usoWhereInput>
    cedula?: StringFilter | string
    email?: StringFilter | string
    persona?: XOR<PersonaRelationFilter, personaWhereInput>
    credenciales?: XOR<CredencialesRelationFilter, credencialesWhereInput>
  }

  export type hace_usoOrderByWithRelationInput = {
    cedula?: SortOrder
    email?: SortOrder
    persona?: personaOrderByWithRelationInput
    credenciales?: credencialesOrderByWithRelationInput
  }

  export type hace_usoWhereUniqueInput = {
    cedula_email?: hace_usoCedulaEmailCompoundUniqueInput
  }

  export type hace_usoOrderByWithAggregationInput = {
    cedula?: SortOrder
    email?: SortOrder
    _count?: hace_usoCountOrderByAggregateInput
    _max?: hace_usoMaxOrderByAggregateInput
    _min?: hace_usoMinOrderByAggregateInput
  }

  export type hace_usoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<hace_usoScalarWhereWithAggregatesInput>
    OR?: Enumerable<hace_usoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<hace_usoScalarWhereWithAggregatesInput>
    cedula?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
  }

  export type pagoWhereInput = {
    AND?: Enumerable<pagoWhereInput>
    OR?: Enumerable<pagoWhereInput>
    NOT?: Enumerable<pagoWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    deduccionesEmpleado?: StringNullableFilter | string | null
    deduccionesPatrono?: StringNullableFilter | string | null
    salarioBruto?: FloatNullableFilter | number | null
    beneficios?: StringNullableFilter | string | null
    salarioNeto?: FloatNullableFilter | number | null
    deduccionesVoluntarias?: StringNullableFilter | string | null
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    aplica_b?: Aplica_bListRelationFilter
    aplica_do?: Aplica_doListRelationFilter
    aplica_dv?: Aplica_dvListRelationFilter
    genera?: GeneraListRelationFilter
  }

  export type pagoOrderByWithRelationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    deduccionesEmpleado?: SortOrder
    deduccionesPatrono?: SortOrder
    salarioBruto?: SortOrder
    beneficios?: SortOrder
    salarioNeto?: SortOrder
    deduccionesVoluntarias?: SortOrder
    empleado?: empleadoOrderByWithRelationInput
    aplica_b?: aplica_bOrderByRelationAggregateInput
    aplica_do?: aplica_doOrderByRelationAggregateInput
    aplica_dv?: aplica_dvOrderByRelationAggregateInput
    genera?: generaOrderByRelationAggregateInput
  }

  export type pagoWhereUniqueInput = {
    cedulaEmpleado_fechaHora?: pagoCedulaEmpleadoFechaHoraCompoundUniqueInput
  }

  export type pagoOrderByWithAggregationInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    deduccionesEmpleado?: SortOrder
    deduccionesPatrono?: SortOrder
    salarioBruto?: SortOrder
    beneficios?: SortOrder
    salarioNeto?: SortOrder
    deduccionesVoluntarias?: SortOrder
    _count?: pagoCountOrderByAggregateInput
    _avg?: pagoAvgOrderByAggregateInput
    _max?: pagoMaxOrderByAggregateInput
    _min?: pagoMinOrderByAggregateInput
    _sum?: pagoSumOrderByAggregateInput
  }

  export type pagoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pagoScalarWhereWithAggregatesInput>
    OR?: Enumerable<pagoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pagoScalarWhereWithAggregatesInput>
    cedulaEmpleado?: StringWithAggregatesFilter | string
    fechaHora?: DateTimeWithAggregatesFilter | Date | string
    deduccionesEmpleado?: StringNullableWithAggregatesFilter | string | null
    deduccionesPatrono?: StringNullableWithAggregatesFilter | string | null
    salarioBruto?: FloatNullableWithAggregatesFilter | number | null
    beneficios?: StringNullableWithAggregatesFilter | string | null
    salarioNeto?: FloatNullableWithAggregatesFilter | number | null
    deduccionesVoluntarias?: StringNullableWithAggregatesFilter | string | null
  }

  export type personaWhereInput = {
    AND?: Enumerable<personaWhereInput>
    OR?: Enumerable<personaWhereInput>
    NOT?: Enumerable<personaWhereInput>
    cedula?: StringFilter | string
    nombre?: StringNullableFilter | string | null
    telefono?: StringNullableFilter | string | null
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput> | null
    empleador?: XOR<EmpleadorRelationFilter, empleadorWhereInput> | null
    hace_uso?: Hace_usoListRelationFilter
  }

  export type personaOrderByWithRelationInput = {
    cedula?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    empleado?: empleadoOrderByWithRelationInput
    empleador?: empleadorOrderByWithRelationInput
    hace_uso?: hace_usoOrderByRelationAggregateInput
  }

  export type personaWhereUniqueInput = {
    cedula?: string
  }

  export type personaOrderByWithAggregationInput = {
    cedula?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    _count?: personaCountOrderByAggregateInput
    _max?: personaMaxOrderByAggregateInput
    _min?: personaMinOrderByAggregateInput
  }

  export type personaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<personaScalarWhereWithAggregatesInput>
    OR?: Enumerable<personaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<personaScalarWhereWithAggregatesInput>
    cedula?: StringWithAggregatesFilter | string
    nombre?: StringNullableWithAggregatesFilter | string | null
    telefono?: StringNullableWithAggregatesFilter | string | null
  }

  export type proyectoWhereInput = {
    AND?: Enumerable<proyectoWhereInput>
    OR?: Enumerable<proyectoWhereInput>
    NOT?: Enumerable<proyectoWhereInput>
    cedulaJuridica?: StringFilter | string
    nombre?: StringFilter | string
    cantidadMaximaBeneficios?: IntNullableFilter | number | null
    montoMaximoBeneficio?: IntNullableFilter | number | null
    frecuenciaPago?: StringNullableFilter | string | null
    moneda?: StringNullableFilter | string | null
    fechaInicio?: DateTimeNullableFilter | Date | string | null
    habilitado?: BoolNullableFilter | boolean | null
    fechaFin?: DateTimeNullableFilter | Date | string | null
    fechaUltimoPago?: DateTimeNullableFilter | Date | string | null
    empresa?: XOR<EmpresaRelationFilter, empresaWhereInput>
    beneficios?: BeneficiosListRelationFilter
    deduccionVoluntaria?: DeduccionVoluntariaListRelationFilter
    esContratado?: EsContratadoListRelationFilter
    genera?: GeneraListRelationFilter
    reporteHoras?: ReporteHorasListRelationFilter
  }

  export type proyectoOrderByWithRelationInput = {
    cedulaJuridica?: SortOrder
    nombre?: SortOrder
    cantidadMaximaBeneficios?: SortOrder
    montoMaximoBeneficio?: SortOrder
    frecuenciaPago?: SortOrder
    moneda?: SortOrder
    fechaInicio?: SortOrder
    habilitado?: SortOrder
    fechaFin?: SortOrder
    fechaUltimoPago?: SortOrder
    empresa?: empresaOrderByWithRelationInput
    beneficios?: beneficiosOrderByRelationAggregateInput
    deduccionVoluntaria?: deduccionVoluntariaOrderByRelationAggregateInput
    esContratado?: esContratadoOrderByRelationAggregateInput
    genera?: generaOrderByRelationAggregateInput
    reporteHoras?: reporteHorasOrderByRelationAggregateInput
  }

  export type proyectoWhereUniqueInput = {
    cedulaJuridica_nombre?: proyectoCedulaJuridicaNombreCompoundUniqueInput
  }

  export type proyectoOrderByWithAggregationInput = {
    cedulaJuridica?: SortOrder
    nombre?: SortOrder
    cantidadMaximaBeneficios?: SortOrder
    montoMaximoBeneficio?: SortOrder
    frecuenciaPago?: SortOrder
    moneda?: SortOrder
    fechaInicio?: SortOrder
    habilitado?: SortOrder
    fechaFin?: SortOrder
    fechaUltimoPago?: SortOrder
    _count?: proyectoCountOrderByAggregateInput
    _avg?: proyectoAvgOrderByAggregateInput
    _max?: proyectoMaxOrderByAggregateInput
    _min?: proyectoMinOrderByAggregateInput
    _sum?: proyectoSumOrderByAggregateInput
  }

  export type proyectoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<proyectoScalarWhereWithAggregatesInput>
    OR?: Enumerable<proyectoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<proyectoScalarWhereWithAggregatesInput>
    cedulaJuridica?: StringWithAggregatesFilter | string
    nombre?: StringWithAggregatesFilter | string
    cantidadMaximaBeneficios?: IntNullableWithAggregatesFilter | number | null
    montoMaximoBeneficio?: IntNullableWithAggregatesFilter | number | null
    frecuenciaPago?: StringNullableWithAggregatesFilter | string | null
    moneda?: StringNullableWithAggregatesFilter | string | null
    fechaInicio?: DateTimeNullableWithAggregatesFilter | Date | string | null
    habilitado?: BoolNullableWithAggregatesFilter | boolean | null
    fechaFin?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fechaUltimoPago?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type reporteHorasWhereInput = {
    AND?: Enumerable<reporteHorasWhereInput>
    OR?: Enumerable<reporteHorasWhereInput>
    NOT?: Enumerable<reporteHorasWhereInput>
    cedulaEmpleado?: StringFilter | string
    cedulaEmpleador?: StringNullableFilter | string | null
    cedulaJuridica?: StringNullableFilter | string | null
    nombreProyecto?: StringNullableFilter | string | null
    fechaHora?: DateTimeFilter | Date | string
    horasTrabajadas?: IntNullableFilter | number | null
    estado?: IntNullableFilter | number | null
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    empleador?: XOR<EmpleadorRelationFilter, empleadorWhereInput> | null
    proyecto?: XOR<ProyectoRelationFilter, proyectoWhereInput> | null
  }

  export type reporteHorasOrderByWithRelationInput = {
    cedulaEmpleado?: SortOrder
    cedulaEmpleador?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    fechaHora?: SortOrder
    horasTrabajadas?: SortOrder
    estado?: SortOrder
    empleado?: empleadoOrderByWithRelationInput
    empleador?: empleadorOrderByWithRelationInput
    proyecto?: proyectoOrderByWithRelationInput
  }

  export type reporteHorasWhereUniqueInput = {
    cedulaEmpleado_fechaHora?: reporteHorasCedulaEmpleadoFechaHoraCompoundUniqueInput
  }

  export type reporteHorasOrderByWithAggregationInput = {
    cedulaEmpleado?: SortOrder
    cedulaEmpleador?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    fechaHora?: SortOrder
    horasTrabajadas?: SortOrder
    estado?: SortOrder
    _count?: reporteHorasCountOrderByAggregateInput
    _avg?: reporteHorasAvgOrderByAggregateInput
    _max?: reporteHorasMaxOrderByAggregateInput
    _min?: reporteHorasMinOrderByAggregateInput
    _sum?: reporteHorasSumOrderByAggregateInput
  }

  export type reporteHorasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reporteHorasScalarWhereWithAggregatesInput>
    OR?: Enumerable<reporteHorasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reporteHorasScalarWhereWithAggregatesInput>
    cedulaEmpleado?: StringWithAggregatesFilter | string
    cedulaEmpleador?: StringNullableWithAggregatesFilter | string | null
    cedulaJuridica?: StringNullableWithAggregatesFilter | string | null
    nombreProyecto?: StringNullableWithAggregatesFilter | string | null
    fechaHora?: DateTimeWithAggregatesFilter | Date | string
    horasTrabajadas?: IntNullableWithAggregatesFilter | number | null
    estado?: IntNullableWithAggregatesFilter | number | null
  }

  export type seleccionaWhereInput = {
    AND?: Enumerable<seleccionaWhereInput>
    OR?: Enumerable<seleccionaWhereInput>
    NOT?: Enumerable<seleccionaWhereInput>
    cedulaEmpleado?: StringFilter | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreBeneficio?: StringFilter | string
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    beneficios?: XOR<BeneficiosRelationFilter, beneficiosWhereInput>
  }

  export type seleccionaOrderByWithRelationInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
    empleado?: empleadoOrderByWithRelationInput
    beneficios?: beneficiosOrderByWithRelationInput
  }

  export type seleccionaWhereUniqueInput = {
    cedulaEmpleado_cedulaJuridica_nombreProyecto_nombreBeneficio?: seleccionaCedulaEmpleadoCedulaJuridicaNombreProyectoNombreBeneficioCompoundUniqueInput
  }

  export type seleccionaOrderByWithAggregationInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
    _count?: seleccionaCountOrderByAggregateInput
    _max?: seleccionaMaxOrderByAggregateInput
    _min?: seleccionaMinOrderByAggregateInput
  }

  export type seleccionaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<seleccionaScalarWhereWithAggregatesInput>
    OR?: Enumerable<seleccionaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<seleccionaScalarWhereWithAggregatesInput>
    cedulaEmpleado?: StringWithAggregatesFilter | string
    cedulaJuridica?: StringWithAggregatesFilter | string
    nombreProyecto?: StringWithAggregatesFilter | string
    nombreBeneficio?: StringWithAggregatesFilter | string
  }

  export type aplica_bCreateInput = {
    pago: pagoCreateNestedOneWithoutAplica_bInput
    beneficios: beneficiosCreateNestedOneWithoutAplica_bInput
  }

  export type aplica_bUncheckedCreateInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type aplica_bUpdateInput = {
    pago?: pagoUpdateOneRequiredWithoutAplica_bInput
    beneficios?: beneficiosUpdateOneRequiredWithoutAplica_bInput
  }

  export type aplica_bUncheckedUpdateInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
  }

  export type aplica_bCreateManyInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type aplica_bUpdateManyMutationInput = {

  }

  export type aplica_bUncheckedUpdateManyInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
  }

  export type aplica_doCreateInput = {
    pago: pagoCreateNestedOneWithoutAplica_doInput
    deduccionObligatoria: deduccionObligatoriaCreateNestedOneWithoutAplica_doInput
  }

  export type aplica_doUncheckedCreateInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    nombreDO: string
  }

  export type aplica_doUpdateInput = {
    pago?: pagoUpdateOneRequiredWithoutAplica_doInput
    deduccionObligatoria?: deduccionObligatoriaUpdateOneRequiredWithoutAplica_doInput
  }

  export type aplica_doUncheckedUpdateInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreDO?: StringFieldUpdateOperationsInput | string
  }

  export type aplica_doCreateManyInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    nombreDO: string
  }

  export type aplica_doUpdateManyMutationInput = {

  }

  export type aplica_doUncheckedUpdateManyInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreDO?: StringFieldUpdateOperationsInput | string
  }

  export type aplica_dvCreateInput = {
    pago: pagoCreateNestedOneWithoutAplica_dvInput
    deduccionVoluntaria: deduccionVoluntariaCreateNestedOneWithoutAplica_dvInput
  }

  export type aplica_dvUncheckedCreateInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
  }

  export type aplica_dvUpdateInput = {
    pago?: pagoUpdateOneRequiredWithoutAplica_dvInput
    deduccionVoluntaria?: deduccionVoluntariaUpdateOneRequiredWithoutAplica_dvInput
  }

  export type aplica_dvUncheckedUpdateInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
  }

  export type aplica_dvCreateManyInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
  }

  export type aplica_dvUpdateManyMutationInput = {

  }

  export type aplica_dvUncheckedUpdateManyInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
  }

  export type beneficiosCreateInput = {
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
    proyecto: proyectoCreateNestedOneWithoutBeneficiosInput
    aplica_b?: aplica_bCreateNestedManyWithoutBeneficiosInput
    selecciona?: seleccionaCreateNestedManyWithoutBeneficiosInput
  }

  export type beneficiosUncheckedCreateInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
    aplica_b?: aplica_bUncheckedCreateNestedManyWithoutBeneficiosInput
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutBeneficiosInput
  }

  export type beneficiosUpdateInput = {
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    proyecto?: proyectoUpdateOneRequiredWithoutBeneficiosInput
    aplica_b?: aplica_bUpdateManyWithoutBeneficiosInput
    selecciona?: seleccionaUpdateManyWithoutBeneficiosInput
  }

  export type beneficiosUncheckedUpdateInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aplica_b?: aplica_bUncheckedUpdateManyWithoutBeneficiosInput
    selecciona?: seleccionaUncheckedUpdateManyWithoutBeneficiosInput
  }

  export type beneficiosCreateManyInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
  }

  export type beneficiosUpdateManyMutationInput = {
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type beneficiosUncheckedUpdateManyInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type credencialesCreateInput = {
    email: string
    contrasenna?: string | null
    verificado?: boolean | null
    hace_uso?: hace_usoCreateNestedManyWithoutCredencialesInput
  }

  export type credencialesUncheckedCreateInput = {
    email: string
    contrasenna?: string | null
    verificado?: boolean | null
    hace_uso?: hace_usoUncheckedCreateNestedManyWithoutCredencialesInput
  }

  export type credencialesUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    contrasenna?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hace_uso?: hace_usoUpdateManyWithoutCredencialesInput
  }

  export type credencialesUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    contrasenna?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hace_uso?: hace_usoUncheckedUpdateManyWithoutCredencialesInput
  }

  export type credencialesCreateManyInput = {
    email: string
    contrasenna?: string | null
    verificado?: boolean | null
  }

  export type credencialesUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    contrasenna?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type credencialesUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    contrasenna?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type deduccionObligatoriaCreateInput = {
    nombre: string
    porcentaje?: number | null
    aplica_do?: aplica_doCreateNestedManyWithoutDeduccionObligatoriaInput
  }

  export type deduccionObligatoriaUncheckedCreateInput = {
    nombre: string
    porcentaje?: number | null
    aplica_do?: aplica_doUncheckedCreateNestedManyWithoutDeduccionObligatoriaInput
  }

  export type deduccionObligatoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: NullableFloatFieldUpdateOperationsInput | number | null
    aplica_do?: aplica_doUpdateManyWithoutDeduccionObligatoriaInput
  }

  export type deduccionObligatoriaUncheckedUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: NullableFloatFieldUpdateOperationsInput | number | null
    aplica_do?: aplica_doUncheckedUpdateManyWithoutDeduccionObligatoriaInput
  }

  export type deduccionObligatoriaCreateManyInput = {
    nombre: string
    porcentaje?: number | null
  }

  export type deduccionObligatoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deduccionObligatoriaUncheckedUpdateManyInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deduccionVoluntariaCreateInput = {
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
    proyecto: proyectoCreateNestedOneWithoutDeduccionVoluntariaInput
    aplica_dv?: aplica_dvCreateNestedManyWithoutDeduccionVoluntariaInput
    escoge?: escogeCreateNestedManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUncheckedCreateInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
    aplica_dv?: aplica_dvUncheckedCreateNestedManyWithoutDeduccionVoluntariaInput
    escoge?: escogeUncheckedCreateNestedManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUpdateInput = {
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    proyecto?: proyectoUpdateOneRequiredWithoutDeduccionVoluntariaInput
    aplica_dv?: aplica_dvUpdateManyWithoutDeduccionVoluntariaInput
    escoge?: escogeUpdateManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUncheckedUpdateInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aplica_dv?: aplica_dvUncheckedUpdateManyWithoutDeduccionVoluntariaInput
    escoge?: escogeUncheckedUpdateManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaCreateManyInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
  }

  export type deduccionVoluntariaUpdateManyMutationInput = {
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type deduccionVoluntariaUncheckedUpdateManyInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type empleadoCreateInput = {
    persona: personaCreateNestedOneWithoutEmpleadoInput
    empresa?: empresaCreateNestedOneWithoutEmpleadoInput
    escoge?: escogeCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoCreateNestedManyWithoutEmpleadoInput
    pago?: pagoCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateInput = {
    cedula: string
    cedulaJuridica?: string | null
    escoge?: escogeUncheckedCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutEmpleadoInput
    pago?: pagoUncheckedCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUpdateInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadoInput
    empresa?: empresaUpdateOneWithoutEmpleadoInput
    escoge?: escogeUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUpdateManyWithoutEmpleadoInput
    pago?: pagoUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUpdateManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedUpdateInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    escoge?: escogeUncheckedUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutEmpleadoInput
    pago?: pagoUncheckedUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedUpdateManyWithoutEmpleadoInput
  }

  export type empleadoCreateManyInput = {
    cedula: string
    cedulaJuridica?: string | null
  }

  export type empleadoUpdateManyMutationInput = {

  }

  export type empleadoUncheckedUpdateManyInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empleadorCreateInput = {
    persona: personaCreateNestedOneWithoutEmpleadorInput
    empresa?: empresaCreateNestedManyWithoutEmpleadorInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadorInput
  }

  export type empleadorUncheckedCreateInput = {
    cedula: string
    empresa?: empresaUncheckedCreateNestedManyWithoutEmpleadorInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadorInput
  }

  export type empleadorUpdateInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadorInput
    empresa?: empresaUpdateManyWithoutEmpleadorInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadorInput
  }

  export type empleadorUncheckedUpdateInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    empresa?: empresaUncheckedUpdateManyWithoutEmpleadorInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadorInput
  }

  export type empleadorCreateManyInput = {
    cedula: string
  }

  export type empleadorUpdateManyMutationInput = {

  }

  export type empleadorUncheckedUpdateManyInput = {
    cedula?: StringFieldUpdateOperationsInput | string
  }

  export type empresaCreateInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    telefono?: string | null
    empleador?: empleadorCreateNestedOneWithoutEmpresaInput
    empleado?: empleadoCreateNestedManyWithoutEmpresaInput
    proyecto?: proyectoCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUncheckedCreateInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    cedulaEmpleador?: string | null
    telefono?: string | null
    empleado?: empleadoUncheckedCreateNestedManyWithoutEmpresaInput
    proyecto?: proyectoUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUpdateInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleador?: empleadorUpdateOneWithoutEmpresaInput
    empleado?: empleadoUpdateManyWithoutEmpresaInput
    proyecto?: proyectoUpdateManyWithoutEmpresaInput
  }

  export type empresaUncheckedUpdateInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cedulaEmpleador?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUncheckedUpdateManyWithoutEmpresaInput
    proyecto?: proyectoUncheckedUpdateManyWithoutEmpresaInput
  }

  export type empresaCreateManyInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    cedulaEmpleador?: string | null
    telefono?: string | null
  }

  export type empresaUpdateManyMutationInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empresaUncheckedUpdateManyInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cedulaEmpleador?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type escogeCreateInput = {
    aporte?: number | null
    empleado: empleadoCreateNestedOneWithoutEscogeInput
    deduccionVoluntaria: deduccionVoluntariaCreateNestedOneWithoutEscogeInput
  }

  export type escogeUncheckedCreateInput = {
    cedulaEmpleado: string
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    aporte?: number | null
  }

  export type escogeUpdateInput = {
    aporte?: NullableFloatFieldUpdateOperationsInput | number | null
    empleado?: empleadoUpdateOneRequiredWithoutEscogeInput
    deduccionVoluntaria?: deduccionVoluntariaUpdateOneRequiredWithoutEscogeInput
  }

  export type escogeUncheckedUpdateInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    aporte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type escogeCreateManyInput = {
    cedulaEmpleado: string
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    aporte?: number | null
  }

  export type escogeUpdateManyMutationInput = {
    aporte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type escogeUncheckedUpdateManyInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    aporte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type esContratadoCreateInput = {
    tipoEmpleado?: string | null
    puesto?: string | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    jornada?: string | null
    salario?: number | null
    empleado: empleadoCreateNestedOneWithoutEsContratadoInput
    proyecto: proyectoCreateNestedOneWithoutEsContratadoInput
  }

  export type esContratadoUncheckedCreateInput = {
    cedulaJuridica: string
    nombreProyecto: string
    cedulaEmpleado: string
    tipoEmpleado?: string | null
    puesto?: string | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    jornada?: string | null
    salario?: number | null
  }

  export type esContratadoUpdateInput = {
    tipoEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jornada?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    empleado?: empleadoUpdateOneRequiredWithoutEsContratadoInput
    proyecto?: proyectoUpdateOneRequiredWithoutEsContratadoInput
  }

  export type esContratadoUncheckedUpdateInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    tipoEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jornada?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type esContratadoCreateManyInput = {
    cedulaJuridica: string
    nombreProyecto: string
    cedulaEmpleado: string
    tipoEmpleado?: string | null
    puesto?: string | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    jornada?: string | null
    salario?: number | null
  }

  export type esContratadoUpdateManyMutationInput = {
    tipoEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jornada?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type esContratadoUncheckedUpdateManyInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    tipoEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jornada?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type generaCreateInput = {
    pago: pagoCreateNestedOneWithoutGeneraInput
    proyecto: proyectoCreateNestedOneWithoutGeneraInput
  }

  export type generaUncheckedCreateInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    cedulaJuridica: string
    nombreProyecto: string
  }

  export type generaUpdateInput = {
    pago?: pagoUpdateOneRequiredWithoutGeneraInput
    proyecto?: proyectoUpdateOneRequiredWithoutGeneraInput
  }

  export type generaUncheckedUpdateInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
  }

  export type generaCreateManyInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    cedulaJuridica: string
    nombreProyecto: string
  }

  export type generaUpdateManyMutationInput = {

  }

  export type generaUncheckedUpdateManyInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
  }

  export type hace_usoCreateInput = {
    persona: personaCreateNestedOneWithoutHace_usoInput
    credenciales: credencialesCreateNestedOneWithoutHace_usoInput
  }

  export type hace_usoUncheckedCreateInput = {
    cedula: string
    email: string
  }

  export type hace_usoUpdateInput = {
    persona?: personaUpdateOneRequiredWithoutHace_usoInput
    credenciales?: credencialesUpdateOneRequiredWithoutHace_usoInput
  }

  export type hace_usoUncheckedUpdateInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type hace_usoCreateManyInput = {
    cedula: string
    email: string
  }

  export type hace_usoUpdateManyMutationInput = {

  }

  export type hace_usoUncheckedUpdateManyInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type pagoCreateInput = {
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    empleado: empleadoCreateNestedOneWithoutPagoInput
    aplica_b?: aplica_bCreateNestedManyWithoutPagoInput
    aplica_do?: aplica_doCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvCreateNestedManyWithoutPagoInput
    genera?: generaCreateNestedManyWithoutPagoInput
  }

  export type pagoUncheckedCreateInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    aplica_b?: aplica_bUncheckedCreateNestedManyWithoutPagoInput
    aplica_do?: aplica_doUncheckedCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedCreateNestedManyWithoutPagoInput
    genera?: generaUncheckedCreateNestedManyWithoutPagoInput
  }

  export type pagoUpdateInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateOneRequiredWithoutPagoInput
    aplica_b?: aplica_bUpdateManyWithoutPagoInput
    aplica_do?: aplica_doUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUpdateManyWithoutPagoInput
    genera?: generaUpdateManyWithoutPagoInput
  }

  export type pagoUncheckedUpdateInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    aplica_b?: aplica_bUncheckedUpdateManyWithoutPagoInput
    aplica_do?: aplica_doUncheckedUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedUpdateManyWithoutPagoInput
    genera?: generaUncheckedUpdateManyWithoutPagoInput
  }

  export type pagoCreateManyInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
  }

  export type pagoUpdateManyMutationInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pagoUncheckedUpdateManyInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type personaCreateInput = {
    cedula: string
    nombre?: string | null
    telefono?: string | null
    empleado?: empleadoCreateNestedOneWithoutPersonaInput
    empleador?: empleadorCreateNestedOneWithoutPersonaInput
    hace_uso?: hace_usoCreateNestedManyWithoutPersonaInput
  }

  export type personaUncheckedCreateInput = {
    cedula: string
    nombre?: string | null
    telefono?: string | null
    empleado?: empleadoUncheckedCreateNestedOneWithoutPersonaInput
    empleador?: empleadorUncheckedCreateNestedOneWithoutPersonaInput
    hace_uso?: hace_usoUncheckedCreateNestedManyWithoutPersonaInput
  }

  export type personaUpdateInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateOneWithoutPersonaInput
    empleador?: empleadorUpdateOneWithoutPersonaInput
    hace_uso?: hace_usoUpdateManyWithoutPersonaInput
  }

  export type personaUncheckedUpdateInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUncheckedUpdateOneWithoutPersonaInput
    empleador?: empleadorUncheckedUpdateOneWithoutPersonaInput
    hace_uso?: hace_usoUncheckedUpdateManyWithoutPersonaInput
  }

  export type personaCreateManyInput = {
    cedula: string
    nombre?: string | null
    telefono?: string | null
  }

  export type personaUpdateManyMutationInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type personaUncheckedUpdateManyInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proyectoCreateInput = {
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    empresa: empresaCreateNestedOneWithoutProyectoInput
    beneficios?: beneficiosCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoCreateNestedManyWithoutProyectoInput
    genera?: generaCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutProyectoInput
  }

  export type proyectoUncheckedCreateInput = {
    cedulaJuridica: string
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    beneficios?: beneficiosUncheckedCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutProyectoInput
    genera?: generaUncheckedCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type proyectoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: empresaUpdateOneRequiredWithoutProyectoInput
    beneficios?: beneficiosUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUpdateManyWithoutProyectoInput
    genera?: generaUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUpdateManyWithoutProyectoInput
  }

  export type proyectoUncheckedUpdateInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficios?: beneficiosUncheckedUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutProyectoInput
    genera?: generaUncheckedUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutProyectoInput
  }

  export type proyectoCreateManyInput = {
    cedulaJuridica: string
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
  }

  export type proyectoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type proyectoUncheckedUpdateManyInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reporteHorasCreateInput = {
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
    empleado: empleadoCreateNestedOneWithoutReporteHorasInput
    empleador?: empleadorCreateNestedOneWithoutReporteHorasInput
    proyecto?: proyectoCreateNestedOneWithoutReporteHorasInput
  }

  export type reporteHorasUncheckedCreateInput = {
    cedulaEmpleado: string
    cedulaEmpleador?: string | null
    cedulaJuridica?: string | null
    nombreProyecto?: string | null
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
  }

  export type reporteHorasUpdateInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empleado?: empleadoUpdateOneRequiredWithoutReporteHorasInput
    empleador?: empleadorUpdateOneWithoutReporteHorasInput
    proyecto?: proyectoUpdateOneWithoutReporteHorasInput
  }

  export type reporteHorasUncheckedUpdateInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    cedulaEmpleador?: NullableStringFieldUpdateOperationsInput | string | null
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    nombreProyecto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reporteHorasCreateManyInput = {
    cedulaEmpleado: string
    cedulaEmpleador?: string | null
    cedulaJuridica?: string | null
    nombreProyecto?: string | null
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
  }

  export type reporteHorasUpdateManyMutationInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reporteHorasUncheckedUpdateManyInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    cedulaEmpleador?: NullableStringFieldUpdateOperationsInput | string | null
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    nombreProyecto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type seleccionaCreateInput = {
    empleado: empleadoCreateNestedOneWithoutSeleccionaInput
    beneficios: beneficiosCreateNestedOneWithoutSeleccionaInput
  }

  export type seleccionaUncheckedCreateInput = {
    cedulaEmpleado: string
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type seleccionaUpdateInput = {
    empleado?: empleadoUpdateOneRequiredWithoutSeleccionaInput
    beneficios?: beneficiosUpdateOneRequiredWithoutSeleccionaInput
  }

  export type seleccionaUncheckedUpdateInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
  }

  export type seleccionaCreateManyInput = {
    cedulaEmpleado: string
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type seleccionaUpdateManyMutationInput = {

  }

  export type seleccionaUncheckedUpdateManyInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type PagoRelationFilter = {
    is?: pagoWhereInput
    isNot?: pagoWhereInput
  }

  export type BeneficiosRelationFilter = {
    is?: beneficiosWhereInput
    isNot?: beneficiosWhereInput
  }

  export type aplica_bCedulaEmpleadoFechaHoraCedulaJuridicaNombreProyectoNombreBeneficioCompoundUniqueInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type aplica_bCountOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
  }

  export type aplica_bMaxOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
  }

  export type aplica_bMinOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DeduccionObligatoriaRelationFilter = {
    is?: deduccionObligatoriaWhereInput
    isNot?: deduccionObligatoriaWhereInput
  }

  export type aplica_doCedulaEmpleadoFechaHoraNombreDOCompoundUniqueInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    nombreDO: string
  }

  export type aplica_doCountOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    nombreDO?: SortOrder
  }

  export type aplica_doMaxOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    nombreDO?: SortOrder
  }

  export type aplica_doMinOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    nombreDO?: SortOrder
  }

  export type DeduccionVoluntariaRelationFilter = {
    is?: deduccionVoluntariaWhereInput
    isNot?: deduccionVoluntariaWhereInput
  }

  export type aplica_dvCedulaEmpleadoFechaHoraCedulaJuridicaNombreProyectoNombreDeduccionCompoundUniqueInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
  }

  export type aplica_dvCountOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
  }

  export type aplica_dvMaxOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
  }

  export type aplica_dvMinOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type ProyectoRelationFilter = {
    is?: proyectoWhereInput
    isNot?: proyectoWhereInput
  }

  export type Aplica_bListRelationFilter = {
    every?: aplica_bWhereInput
    some?: aplica_bWhereInput
    none?: aplica_bWhereInput
  }

  export type SeleccionaListRelationFilter = {
    every?: seleccionaWhereInput
    some?: seleccionaWhereInput
    none?: seleccionaWhereInput
  }

  export type aplica_bOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type seleccionaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type beneficiosCedulaJuridicaNombreProyectoNombreBeneficioCompoundUniqueInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type beneficiosCountOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
    montoPago?: SortOrder
    descripcion?: SortOrder
    habilitado?: SortOrder
  }

  export type beneficiosAvgOrderByAggregateInput = {
    montoPago?: SortOrder
  }

  export type beneficiosMaxOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
    montoPago?: SortOrder
    descripcion?: SortOrder
    habilitado?: SortOrder
  }

  export type beneficiosMinOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
    montoPago?: SortOrder
    descripcion?: SortOrder
    habilitado?: SortOrder
  }

  export type beneficiosSumOrderByAggregateInput = {
    montoPago?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type Hace_usoListRelationFilter = {
    every?: hace_usoWhereInput
    some?: hace_usoWhereInput
    none?: hace_usoWhereInput
  }

  export type hace_usoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type credencialesCountOrderByAggregateInput = {
    email?: SortOrder
    contrasenna?: SortOrder
    verificado?: SortOrder
  }

  export type credencialesMaxOrderByAggregateInput = {
    email?: SortOrder
    contrasenna?: SortOrder
    verificado?: SortOrder
  }

  export type credencialesMinOrderByAggregateInput = {
    email?: SortOrder
    contrasenna?: SortOrder
    verificado?: SortOrder
  }

  export type Aplica_doListRelationFilter = {
    every?: aplica_doWhereInput
    some?: aplica_doWhereInput
    none?: aplica_doWhereInput
  }

  export type aplica_doOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deduccionObligatoriaCountOrderByAggregateInput = {
    nombre?: SortOrder
    porcentaje?: SortOrder
  }

  export type deduccionObligatoriaAvgOrderByAggregateInput = {
    porcentaje?: SortOrder
  }

  export type deduccionObligatoriaMaxOrderByAggregateInput = {
    nombre?: SortOrder
    porcentaje?: SortOrder
  }

  export type deduccionObligatoriaMinOrderByAggregateInput = {
    nombre?: SortOrder
    porcentaje?: SortOrder
  }

  export type deduccionObligatoriaSumOrderByAggregateInput = {
    porcentaje?: SortOrder
  }

  export type Aplica_dvListRelationFilter = {
    every?: aplica_dvWhereInput
    some?: aplica_dvWhereInput
    none?: aplica_dvWhereInput
  }

  export type EscogeListRelationFilter = {
    every?: escogeWhereInput
    some?: escogeWhereInput
    none?: escogeWhereInput
  }

  export type aplica_dvOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type escogeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deduccionVoluntariaCedulaJuridicaNombreProyectoNombreDeduccionCompoundUniqueInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
  }

  export type deduccionVoluntariaCountOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    habilitado?: SortOrder
  }

  export type deduccionVoluntariaAvgOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type deduccionVoluntariaMaxOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    habilitado?: SortOrder
  }

  export type deduccionVoluntariaMinOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    habilitado?: SortOrder
  }

  export type deduccionVoluntariaSumOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type PersonaRelationFilter = {
    is?: personaWhereInput
    isNot?: personaWhereInput
  }

  export type EmpresaRelationFilter = {
    is?: empresaWhereInput
    isNot?: empresaWhereInput
  }

  export type EsContratadoListRelationFilter = {
    every?: esContratadoWhereInput
    some?: esContratadoWhereInput
    none?: esContratadoWhereInput
  }

  export type PagoListRelationFilter = {
    every?: pagoWhereInput
    some?: pagoWhereInput
    none?: pagoWhereInput
  }

  export type ReporteHorasListRelationFilter = {
    every?: reporteHorasWhereInput
    some?: reporteHorasWhereInput
    none?: reporteHorasWhereInput
  }

  export type esContratadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pagoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reporteHorasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type empleadoCountOrderByAggregateInput = {
    cedula?: SortOrder
    cedulaJuridica?: SortOrder
  }

  export type empleadoMaxOrderByAggregateInput = {
    cedula?: SortOrder
    cedulaJuridica?: SortOrder
  }

  export type empleadoMinOrderByAggregateInput = {
    cedula?: SortOrder
    cedulaJuridica?: SortOrder
  }

  export type EmpresaListRelationFilter = {
    every?: empresaWhereInput
    some?: empresaWhereInput
    none?: empresaWhereInput
  }

  export type empresaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type empleadorCountOrderByAggregateInput = {
    cedula?: SortOrder
  }

  export type empleadorMaxOrderByAggregateInput = {
    cedula?: SortOrder
  }

  export type empleadorMinOrderByAggregateInput = {
    cedula?: SortOrder
  }

  export type EmpleadorRelationFilter = {
    is?: empleadorWhereInput | null
    isNot?: empleadorWhereInput | null
  }

  export type EmpleadoListRelationFilter = {
    every?: empleadoWhereInput
    some?: empleadoWhereInput
    none?: empleadoWhereInput
  }

  export type ProyectoListRelationFilter = {
    every?: proyectoWhereInput
    some?: proyectoWhereInput
    none?: proyectoWhereInput
  }

  export type empleadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proyectoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type empresaCountOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    direccion?: SortOrder
    razonSocial?: SortOrder
    email?: SortOrder
    habilitado?: SortOrder
    cedulaEmpleador?: SortOrder
    telefono?: SortOrder
  }

  export type empresaMaxOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    direccion?: SortOrder
    razonSocial?: SortOrder
    email?: SortOrder
    habilitado?: SortOrder
    cedulaEmpleador?: SortOrder
    telefono?: SortOrder
  }

  export type empresaMinOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    direccion?: SortOrder
    razonSocial?: SortOrder
    email?: SortOrder
    habilitado?: SortOrder
    cedulaEmpleador?: SortOrder
    telefono?: SortOrder
  }

  export type EmpleadoRelationFilter = {
    is?: empleadoWhereInput | null
    isNot?: empleadoWhereInput | null
  }

  export type escogeCedulaEmpleadoCedulaJuridicaNombreProyectoNombreDeduccionCompoundUniqueInput = {
    cedulaEmpleado: string
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
  }

  export type escogeCountOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    aporte?: SortOrder
  }

  export type escogeAvgOrderByAggregateInput = {
    aporte?: SortOrder
  }

  export type escogeMaxOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    aporte?: SortOrder
  }

  export type escogeMinOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreDeduccion?: SortOrder
    aporte?: SortOrder
  }

  export type escogeSumOrderByAggregateInput = {
    aporte?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type esContratadoCedulaJuridicaNombreProyectoCedulaEmpleadoCompoundUniqueInput = {
    cedulaJuridica: string
    nombreProyecto: string
    cedulaEmpleado: string
  }

  export type esContratadoCountOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    cedulaEmpleado?: SortOrder
    tipoEmpleado?: SortOrder
    puesto?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    jornada?: SortOrder
    salario?: SortOrder
  }

  export type esContratadoAvgOrderByAggregateInput = {
    salario?: SortOrder
  }

  export type esContratadoMaxOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    cedulaEmpleado?: SortOrder
    tipoEmpleado?: SortOrder
    puesto?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    jornada?: SortOrder
    salario?: SortOrder
  }

  export type esContratadoMinOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    cedulaEmpleado?: SortOrder
    tipoEmpleado?: SortOrder
    puesto?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    jornada?: SortOrder
    salario?: SortOrder
  }

  export type esContratadoSumOrderByAggregateInput = {
    salario?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type generaCedulaEmpleadoFechaHoraCedulaJuridicaNombreProyectoCompoundUniqueInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    cedulaJuridica: string
    nombreProyecto: string
  }

  export type generaCountOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
  }

  export type generaMaxOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
  }

  export type generaMinOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
  }

  export type CredencialesRelationFilter = {
    is?: credencialesWhereInput
    isNot?: credencialesWhereInput
  }

  export type hace_usoCedulaEmailCompoundUniqueInput = {
    cedula: string
    email: string
  }

  export type hace_usoCountOrderByAggregateInput = {
    cedula?: SortOrder
    email?: SortOrder
  }

  export type hace_usoMaxOrderByAggregateInput = {
    cedula?: SortOrder
    email?: SortOrder
  }

  export type hace_usoMinOrderByAggregateInput = {
    cedula?: SortOrder
    email?: SortOrder
  }

  export type GeneraListRelationFilter = {
    every?: generaWhereInput
    some?: generaWhereInput
    none?: generaWhereInput
  }

  export type generaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pagoCedulaEmpleadoFechaHoraCompoundUniqueInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type pagoCountOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    deduccionesEmpleado?: SortOrder
    deduccionesPatrono?: SortOrder
    salarioBruto?: SortOrder
    beneficios?: SortOrder
    salarioNeto?: SortOrder
    deduccionesVoluntarias?: SortOrder
  }

  export type pagoAvgOrderByAggregateInput = {
    salarioBruto?: SortOrder
    salarioNeto?: SortOrder
  }

  export type pagoMaxOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    deduccionesEmpleado?: SortOrder
    deduccionesPatrono?: SortOrder
    salarioBruto?: SortOrder
    beneficios?: SortOrder
    salarioNeto?: SortOrder
    deduccionesVoluntarias?: SortOrder
  }

  export type pagoMinOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    fechaHora?: SortOrder
    deduccionesEmpleado?: SortOrder
    deduccionesPatrono?: SortOrder
    salarioBruto?: SortOrder
    beneficios?: SortOrder
    salarioNeto?: SortOrder
    deduccionesVoluntarias?: SortOrder
  }

  export type pagoSumOrderByAggregateInput = {
    salarioBruto?: SortOrder
    salarioNeto?: SortOrder
  }

  export type personaCountOrderByAggregateInput = {
    cedula?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
  }

  export type personaMaxOrderByAggregateInput = {
    cedula?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
  }

  export type personaMinOrderByAggregateInput = {
    cedula?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BeneficiosListRelationFilter = {
    every?: beneficiosWhereInput
    some?: beneficiosWhereInput
    none?: beneficiosWhereInput
  }

  export type DeduccionVoluntariaListRelationFilter = {
    every?: deduccionVoluntariaWhereInput
    some?: deduccionVoluntariaWhereInput
    none?: deduccionVoluntariaWhereInput
  }

  export type beneficiosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deduccionVoluntariaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proyectoCedulaJuridicaNombreCompoundUniqueInput = {
    cedulaJuridica: string
    nombre: string
  }

  export type proyectoCountOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombre?: SortOrder
    cantidadMaximaBeneficios?: SortOrder
    montoMaximoBeneficio?: SortOrder
    frecuenciaPago?: SortOrder
    moneda?: SortOrder
    fechaInicio?: SortOrder
    habilitado?: SortOrder
    fechaFin?: SortOrder
    fechaUltimoPago?: SortOrder
  }

  export type proyectoAvgOrderByAggregateInput = {
    cantidadMaximaBeneficios?: SortOrder
    montoMaximoBeneficio?: SortOrder
  }

  export type proyectoMaxOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombre?: SortOrder
    cantidadMaximaBeneficios?: SortOrder
    montoMaximoBeneficio?: SortOrder
    frecuenciaPago?: SortOrder
    moneda?: SortOrder
    fechaInicio?: SortOrder
    habilitado?: SortOrder
    fechaFin?: SortOrder
    fechaUltimoPago?: SortOrder
  }

  export type proyectoMinOrderByAggregateInput = {
    cedulaJuridica?: SortOrder
    nombre?: SortOrder
    cantidadMaximaBeneficios?: SortOrder
    montoMaximoBeneficio?: SortOrder
    frecuenciaPago?: SortOrder
    moneda?: SortOrder
    fechaInicio?: SortOrder
    habilitado?: SortOrder
    fechaFin?: SortOrder
    fechaUltimoPago?: SortOrder
  }

  export type proyectoSumOrderByAggregateInput = {
    cantidadMaximaBeneficios?: SortOrder
    montoMaximoBeneficio?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type reporteHorasCedulaEmpleadoFechaHoraCompoundUniqueInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type reporteHorasCountOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    cedulaEmpleador?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    fechaHora?: SortOrder
    horasTrabajadas?: SortOrder
    estado?: SortOrder
  }

  export type reporteHorasAvgOrderByAggregateInput = {
    horasTrabajadas?: SortOrder
    estado?: SortOrder
  }

  export type reporteHorasMaxOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    cedulaEmpleador?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    fechaHora?: SortOrder
    horasTrabajadas?: SortOrder
    estado?: SortOrder
  }

  export type reporteHorasMinOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    cedulaEmpleador?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    fechaHora?: SortOrder
    horasTrabajadas?: SortOrder
    estado?: SortOrder
  }

  export type reporteHorasSumOrderByAggregateInput = {
    horasTrabajadas?: SortOrder
    estado?: SortOrder
  }

  export type seleccionaCedulaEmpleadoCedulaJuridicaNombreProyectoNombreBeneficioCompoundUniqueInput = {
    cedulaEmpleado: string
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type seleccionaCountOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
  }

  export type seleccionaMaxOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
  }

  export type seleccionaMinOrderByAggregateInput = {
    cedulaEmpleado?: SortOrder
    cedulaJuridica?: SortOrder
    nombreProyecto?: SortOrder
    nombreBeneficio?: SortOrder
  }

  export type pagoCreateNestedOneWithoutAplica_bInput = {
    create?: XOR<pagoCreateWithoutAplica_bInput, pagoUncheckedCreateWithoutAplica_bInput>
    connectOrCreate?: pagoCreateOrConnectWithoutAplica_bInput
    connect?: pagoWhereUniqueInput
  }

  export type beneficiosCreateNestedOneWithoutAplica_bInput = {
    create?: XOR<beneficiosCreateWithoutAplica_bInput, beneficiosUncheckedCreateWithoutAplica_bInput>
    connectOrCreate?: beneficiosCreateOrConnectWithoutAplica_bInput
    connect?: beneficiosWhereUniqueInput
  }

  export type pagoUpdateOneRequiredWithoutAplica_bInput = {
    create?: XOR<pagoCreateWithoutAplica_bInput, pagoUncheckedCreateWithoutAplica_bInput>
    connectOrCreate?: pagoCreateOrConnectWithoutAplica_bInput
    upsert?: pagoUpsertWithoutAplica_bInput
    connect?: pagoWhereUniqueInput
    update?: XOR<pagoUpdateWithoutAplica_bInput, pagoUncheckedUpdateWithoutAplica_bInput>
  }

  export type beneficiosUpdateOneRequiredWithoutAplica_bInput = {
    create?: XOR<beneficiosCreateWithoutAplica_bInput, beneficiosUncheckedCreateWithoutAplica_bInput>
    connectOrCreate?: beneficiosCreateOrConnectWithoutAplica_bInput
    upsert?: beneficiosUpsertWithoutAplica_bInput
    connect?: beneficiosWhereUniqueInput
    update?: XOR<beneficiosUpdateWithoutAplica_bInput, beneficiosUncheckedUpdateWithoutAplica_bInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type pagoCreateNestedOneWithoutAplica_doInput = {
    create?: XOR<pagoCreateWithoutAplica_doInput, pagoUncheckedCreateWithoutAplica_doInput>
    connectOrCreate?: pagoCreateOrConnectWithoutAplica_doInput
    connect?: pagoWhereUniqueInput
  }

  export type deduccionObligatoriaCreateNestedOneWithoutAplica_doInput = {
    create?: XOR<deduccionObligatoriaCreateWithoutAplica_doInput, deduccionObligatoriaUncheckedCreateWithoutAplica_doInput>
    connectOrCreate?: deduccionObligatoriaCreateOrConnectWithoutAplica_doInput
    connect?: deduccionObligatoriaWhereUniqueInput
  }

  export type pagoUpdateOneRequiredWithoutAplica_doInput = {
    create?: XOR<pagoCreateWithoutAplica_doInput, pagoUncheckedCreateWithoutAplica_doInput>
    connectOrCreate?: pagoCreateOrConnectWithoutAplica_doInput
    upsert?: pagoUpsertWithoutAplica_doInput
    connect?: pagoWhereUniqueInput
    update?: XOR<pagoUpdateWithoutAplica_doInput, pagoUncheckedUpdateWithoutAplica_doInput>
  }

  export type deduccionObligatoriaUpdateOneRequiredWithoutAplica_doInput = {
    create?: XOR<deduccionObligatoriaCreateWithoutAplica_doInput, deduccionObligatoriaUncheckedCreateWithoutAplica_doInput>
    connectOrCreate?: deduccionObligatoriaCreateOrConnectWithoutAplica_doInput
    upsert?: deduccionObligatoriaUpsertWithoutAplica_doInput
    connect?: deduccionObligatoriaWhereUniqueInput
    update?: XOR<deduccionObligatoriaUpdateWithoutAplica_doInput, deduccionObligatoriaUncheckedUpdateWithoutAplica_doInput>
  }

  export type pagoCreateNestedOneWithoutAplica_dvInput = {
    create?: XOR<pagoCreateWithoutAplica_dvInput, pagoUncheckedCreateWithoutAplica_dvInput>
    connectOrCreate?: pagoCreateOrConnectWithoutAplica_dvInput
    connect?: pagoWhereUniqueInput
  }

  export type deduccionVoluntariaCreateNestedOneWithoutAplica_dvInput = {
    create?: XOR<deduccionVoluntariaCreateWithoutAplica_dvInput, deduccionVoluntariaUncheckedCreateWithoutAplica_dvInput>
    connectOrCreate?: deduccionVoluntariaCreateOrConnectWithoutAplica_dvInput
    connect?: deduccionVoluntariaWhereUniqueInput
  }

  export type pagoUpdateOneRequiredWithoutAplica_dvInput = {
    create?: XOR<pagoCreateWithoutAplica_dvInput, pagoUncheckedCreateWithoutAplica_dvInput>
    connectOrCreate?: pagoCreateOrConnectWithoutAplica_dvInput
    upsert?: pagoUpsertWithoutAplica_dvInput
    connect?: pagoWhereUniqueInput
    update?: XOR<pagoUpdateWithoutAplica_dvInput, pagoUncheckedUpdateWithoutAplica_dvInput>
  }

  export type deduccionVoluntariaUpdateOneRequiredWithoutAplica_dvInput = {
    create?: XOR<deduccionVoluntariaCreateWithoutAplica_dvInput, deduccionVoluntariaUncheckedCreateWithoutAplica_dvInput>
    connectOrCreate?: deduccionVoluntariaCreateOrConnectWithoutAplica_dvInput
    upsert?: deduccionVoluntariaUpsertWithoutAplica_dvInput
    connect?: deduccionVoluntariaWhereUniqueInput
    update?: XOR<deduccionVoluntariaUpdateWithoutAplica_dvInput, deduccionVoluntariaUncheckedUpdateWithoutAplica_dvInput>
  }

  export type proyectoCreateNestedOneWithoutBeneficiosInput = {
    create?: XOR<proyectoCreateWithoutBeneficiosInput, proyectoUncheckedCreateWithoutBeneficiosInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutBeneficiosInput
    connect?: proyectoWhereUniqueInput
  }

  export type aplica_bCreateNestedManyWithoutBeneficiosInput = {
    create?: XOR<Enumerable<aplica_bCreateWithoutBeneficiosInput>, Enumerable<aplica_bUncheckedCreateWithoutBeneficiosInput>>
    connectOrCreate?: Enumerable<aplica_bCreateOrConnectWithoutBeneficiosInput>
    createMany?: aplica_bCreateManyBeneficiosInputEnvelope
    connect?: Enumerable<aplica_bWhereUniqueInput>
  }

  export type seleccionaCreateNestedManyWithoutBeneficiosInput = {
    create?: XOR<Enumerable<seleccionaCreateWithoutBeneficiosInput>, Enumerable<seleccionaUncheckedCreateWithoutBeneficiosInput>>
    connectOrCreate?: Enumerable<seleccionaCreateOrConnectWithoutBeneficiosInput>
    createMany?: seleccionaCreateManyBeneficiosInputEnvelope
    connect?: Enumerable<seleccionaWhereUniqueInput>
  }

  export type aplica_bUncheckedCreateNestedManyWithoutBeneficiosInput = {
    create?: XOR<Enumerable<aplica_bCreateWithoutBeneficiosInput>, Enumerable<aplica_bUncheckedCreateWithoutBeneficiosInput>>
    connectOrCreate?: Enumerable<aplica_bCreateOrConnectWithoutBeneficiosInput>
    createMany?: aplica_bCreateManyBeneficiosInputEnvelope
    connect?: Enumerable<aplica_bWhereUniqueInput>
  }

  export type seleccionaUncheckedCreateNestedManyWithoutBeneficiosInput = {
    create?: XOR<Enumerable<seleccionaCreateWithoutBeneficiosInput>, Enumerable<seleccionaUncheckedCreateWithoutBeneficiosInput>>
    connectOrCreate?: Enumerable<seleccionaCreateOrConnectWithoutBeneficiosInput>
    createMany?: seleccionaCreateManyBeneficiosInputEnvelope
    connect?: Enumerable<seleccionaWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type proyectoUpdateOneRequiredWithoutBeneficiosInput = {
    create?: XOR<proyectoCreateWithoutBeneficiosInput, proyectoUncheckedCreateWithoutBeneficiosInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutBeneficiosInput
    upsert?: proyectoUpsertWithoutBeneficiosInput
    connect?: proyectoWhereUniqueInput
    update?: XOR<proyectoUpdateWithoutBeneficiosInput, proyectoUncheckedUpdateWithoutBeneficiosInput>
  }

  export type aplica_bUpdateManyWithoutBeneficiosInput = {
    create?: XOR<Enumerable<aplica_bCreateWithoutBeneficiosInput>, Enumerable<aplica_bUncheckedCreateWithoutBeneficiosInput>>
    connectOrCreate?: Enumerable<aplica_bCreateOrConnectWithoutBeneficiosInput>
    upsert?: Enumerable<aplica_bUpsertWithWhereUniqueWithoutBeneficiosInput>
    createMany?: aplica_bCreateManyBeneficiosInputEnvelope
    set?: Enumerable<aplica_bWhereUniqueInput>
    disconnect?: Enumerable<aplica_bWhereUniqueInput>
    delete?: Enumerable<aplica_bWhereUniqueInput>
    connect?: Enumerable<aplica_bWhereUniqueInput>
    update?: Enumerable<aplica_bUpdateWithWhereUniqueWithoutBeneficiosInput>
    updateMany?: Enumerable<aplica_bUpdateManyWithWhereWithoutBeneficiosInput>
    deleteMany?: Enumerable<aplica_bScalarWhereInput>
  }

  export type seleccionaUpdateManyWithoutBeneficiosInput = {
    create?: XOR<Enumerable<seleccionaCreateWithoutBeneficiosInput>, Enumerable<seleccionaUncheckedCreateWithoutBeneficiosInput>>
    connectOrCreate?: Enumerable<seleccionaCreateOrConnectWithoutBeneficiosInput>
    upsert?: Enumerable<seleccionaUpsertWithWhereUniqueWithoutBeneficiosInput>
    createMany?: seleccionaCreateManyBeneficiosInputEnvelope
    set?: Enumerable<seleccionaWhereUniqueInput>
    disconnect?: Enumerable<seleccionaWhereUniqueInput>
    delete?: Enumerable<seleccionaWhereUniqueInput>
    connect?: Enumerable<seleccionaWhereUniqueInput>
    update?: Enumerable<seleccionaUpdateWithWhereUniqueWithoutBeneficiosInput>
    updateMany?: Enumerable<seleccionaUpdateManyWithWhereWithoutBeneficiosInput>
    deleteMany?: Enumerable<seleccionaScalarWhereInput>
  }

  export type aplica_bUncheckedUpdateManyWithoutBeneficiosInput = {
    create?: XOR<Enumerable<aplica_bCreateWithoutBeneficiosInput>, Enumerable<aplica_bUncheckedCreateWithoutBeneficiosInput>>
    connectOrCreate?: Enumerable<aplica_bCreateOrConnectWithoutBeneficiosInput>
    upsert?: Enumerable<aplica_bUpsertWithWhereUniqueWithoutBeneficiosInput>
    createMany?: aplica_bCreateManyBeneficiosInputEnvelope
    set?: Enumerable<aplica_bWhereUniqueInput>
    disconnect?: Enumerable<aplica_bWhereUniqueInput>
    delete?: Enumerable<aplica_bWhereUniqueInput>
    connect?: Enumerable<aplica_bWhereUniqueInput>
    update?: Enumerable<aplica_bUpdateWithWhereUniqueWithoutBeneficiosInput>
    updateMany?: Enumerable<aplica_bUpdateManyWithWhereWithoutBeneficiosInput>
    deleteMany?: Enumerable<aplica_bScalarWhereInput>
  }

  export type seleccionaUncheckedUpdateManyWithoutBeneficiosInput = {
    create?: XOR<Enumerable<seleccionaCreateWithoutBeneficiosInput>, Enumerable<seleccionaUncheckedCreateWithoutBeneficiosInput>>
    connectOrCreate?: Enumerable<seleccionaCreateOrConnectWithoutBeneficiosInput>
    upsert?: Enumerable<seleccionaUpsertWithWhereUniqueWithoutBeneficiosInput>
    createMany?: seleccionaCreateManyBeneficiosInputEnvelope
    set?: Enumerable<seleccionaWhereUniqueInput>
    disconnect?: Enumerable<seleccionaWhereUniqueInput>
    delete?: Enumerable<seleccionaWhereUniqueInput>
    connect?: Enumerable<seleccionaWhereUniqueInput>
    update?: Enumerable<seleccionaUpdateWithWhereUniqueWithoutBeneficiosInput>
    updateMany?: Enumerable<seleccionaUpdateManyWithWhereWithoutBeneficiosInput>
    deleteMany?: Enumerable<seleccionaScalarWhereInput>
  }

  export type hace_usoCreateNestedManyWithoutCredencialesInput = {
    create?: XOR<Enumerable<hace_usoCreateWithoutCredencialesInput>, Enumerable<hace_usoUncheckedCreateWithoutCredencialesInput>>
    connectOrCreate?: Enumerable<hace_usoCreateOrConnectWithoutCredencialesInput>
    createMany?: hace_usoCreateManyCredencialesInputEnvelope
    connect?: Enumerable<hace_usoWhereUniqueInput>
  }

  export type hace_usoUncheckedCreateNestedManyWithoutCredencialesInput = {
    create?: XOR<Enumerable<hace_usoCreateWithoutCredencialesInput>, Enumerable<hace_usoUncheckedCreateWithoutCredencialesInput>>
    connectOrCreate?: Enumerable<hace_usoCreateOrConnectWithoutCredencialesInput>
    createMany?: hace_usoCreateManyCredencialesInputEnvelope
    connect?: Enumerable<hace_usoWhereUniqueInput>
  }

  export type hace_usoUpdateManyWithoutCredencialesInput = {
    create?: XOR<Enumerable<hace_usoCreateWithoutCredencialesInput>, Enumerable<hace_usoUncheckedCreateWithoutCredencialesInput>>
    connectOrCreate?: Enumerable<hace_usoCreateOrConnectWithoutCredencialesInput>
    upsert?: Enumerable<hace_usoUpsertWithWhereUniqueWithoutCredencialesInput>
    createMany?: hace_usoCreateManyCredencialesInputEnvelope
    set?: Enumerable<hace_usoWhereUniqueInput>
    disconnect?: Enumerable<hace_usoWhereUniqueInput>
    delete?: Enumerable<hace_usoWhereUniqueInput>
    connect?: Enumerable<hace_usoWhereUniqueInput>
    update?: Enumerable<hace_usoUpdateWithWhereUniqueWithoutCredencialesInput>
    updateMany?: Enumerable<hace_usoUpdateManyWithWhereWithoutCredencialesInput>
    deleteMany?: Enumerable<hace_usoScalarWhereInput>
  }

  export type hace_usoUncheckedUpdateManyWithoutCredencialesInput = {
    create?: XOR<Enumerable<hace_usoCreateWithoutCredencialesInput>, Enumerable<hace_usoUncheckedCreateWithoutCredencialesInput>>
    connectOrCreate?: Enumerable<hace_usoCreateOrConnectWithoutCredencialesInput>
    upsert?: Enumerable<hace_usoUpsertWithWhereUniqueWithoutCredencialesInput>
    createMany?: hace_usoCreateManyCredencialesInputEnvelope
    set?: Enumerable<hace_usoWhereUniqueInput>
    disconnect?: Enumerable<hace_usoWhereUniqueInput>
    delete?: Enumerable<hace_usoWhereUniqueInput>
    connect?: Enumerable<hace_usoWhereUniqueInput>
    update?: Enumerable<hace_usoUpdateWithWhereUniqueWithoutCredencialesInput>
    updateMany?: Enumerable<hace_usoUpdateManyWithWhereWithoutCredencialesInput>
    deleteMany?: Enumerable<hace_usoScalarWhereInput>
  }

  export type aplica_doCreateNestedManyWithoutDeduccionObligatoriaInput = {
    create?: XOR<Enumerable<aplica_doCreateWithoutDeduccionObligatoriaInput>, Enumerable<aplica_doUncheckedCreateWithoutDeduccionObligatoriaInput>>
    connectOrCreate?: Enumerable<aplica_doCreateOrConnectWithoutDeduccionObligatoriaInput>
    createMany?: aplica_doCreateManyDeduccionObligatoriaInputEnvelope
    connect?: Enumerable<aplica_doWhereUniqueInput>
  }

  export type aplica_doUncheckedCreateNestedManyWithoutDeduccionObligatoriaInput = {
    create?: XOR<Enumerable<aplica_doCreateWithoutDeduccionObligatoriaInput>, Enumerable<aplica_doUncheckedCreateWithoutDeduccionObligatoriaInput>>
    connectOrCreate?: Enumerable<aplica_doCreateOrConnectWithoutDeduccionObligatoriaInput>
    createMany?: aplica_doCreateManyDeduccionObligatoriaInputEnvelope
    connect?: Enumerable<aplica_doWhereUniqueInput>
  }

  export type aplica_doUpdateManyWithoutDeduccionObligatoriaInput = {
    create?: XOR<Enumerable<aplica_doCreateWithoutDeduccionObligatoriaInput>, Enumerable<aplica_doUncheckedCreateWithoutDeduccionObligatoriaInput>>
    connectOrCreate?: Enumerable<aplica_doCreateOrConnectWithoutDeduccionObligatoriaInput>
    upsert?: Enumerable<aplica_doUpsertWithWhereUniqueWithoutDeduccionObligatoriaInput>
    createMany?: aplica_doCreateManyDeduccionObligatoriaInputEnvelope
    set?: Enumerable<aplica_doWhereUniqueInput>
    disconnect?: Enumerable<aplica_doWhereUniqueInput>
    delete?: Enumerable<aplica_doWhereUniqueInput>
    connect?: Enumerable<aplica_doWhereUniqueInput>
    update?: Enumerable<aplica_doUpdateWithWhereUniqueWithoutDeduccionObligatoriaInput>
    updateMany?: Enumerable<aplica_doUpdateManyWithWhereWithoutDeduccionObligatoriaInput>
    deleteMany?: Enumerable<aplica_doScalarWhereInput>
  }

  export type aplica_doUncheckedUpdateManyWithoutDeduccionObligatoriaInput = {
    create?: XOR<Enumerable<aplica_doCreateWithoutDeduccionObligatoriaInput>, Enumerable<aplica_doUncheckedCreateWithoutDeduccionObligatoriaInput>>
    connectOrCreate?: Enumerable<aplica_doCreateOrConnectWithoutDeduccionObligatoriaInput>
    upsert?: Enumerable<aplica_doUpsertWithWhereUniqueWithoutDeduccionObligatoriaInput>
    createMany?: aplica_doCreateManyDeduccionObligatoriaInputEnvelope
    set?: Enumerable<aplica_doWhereUniqueInput>
    disconnect?: Enumerable<aplica_doWhereUniqueInput>
    delete?: Enumerable<aplica_doWhereUniqueInput>
    connect?: Enumerable<aplica_doWhereUniqueInput>
    update?: Enumerable<aplica_doUpdateWithWhereUniqueWithoutDeduccionObligatoriaInput>
    updateMany?: Enumerable<aplica_doUpdateManyWithWhereWithoutDeduccionObligatoriaInput>
    deleteMany?: Enumerable<aplica_doScalarWhereInput>
  }

  export type proyectoCreateNestedOneWithoutDeduccionVoluntariaInput = {
    create?: XOR<proyectoCreateWithoutDeduccionVoluntariaInput, proyectoUncheckedCreateWithoutDeduccionVoluntariaInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutDeduccionVoluntariaInput
    connect?: proyectoWhereUniqueInput
  }

  export type aplica_dvCreateNestedManyWithoutDeduccionVoluntariaInput = {
    create?: XOR<Enumerable<aplica_dvCreateWithoutDeduccionVoluntariaInput>, Enumerable<aplica_dvUncheckedCreateWithoutDeduccionVoluntariaInput>>
    connectOrCreate?: Enumerable<aplica_dvCreateOrConnectWithoutDeduccionVoluntariaInput>
    createMany?: aplica_dvCreateManyDeduccionVoluntariaInputEnvelope
    connect?: Enumerable<aplica_dvWhereUniqueInput>
  }

  export type escogeCreateNestedManyWithoutDeduccionVoluntariaInput = {
    create?: XOR<Enumerable<escogeCreateWithoutDeduccionVoluntariaInput>, Enumerable<escogeUncheckedCreateWithoutDeduccionVoluntariaInput>>
    connectOrCreate?: Enumerable<escogeCreateOrConnectWithoutDeduccionVoluntariaInput>
    createMany?: escogeCreateManyDeduccionVoluntariaInputEnvelope
    connect?: Enumerable<escogeWhereUniqueInput>
  }

  export type aplica_dvUncheckedCreateNestedManyWithoutDeduccionVoluntariaInput = {
    create?: XOR<Enumerable<aplica_dvCreateWithoutDeduccionVoluntariaInput>, Enumerable<aplica_dvUncheckedCreateWithoutDeduccionVoluntariaInput>>
    connectOrCreate?: Enumerable<aplica_dvCreateOrConnectWithoutDeduccionVoluntariaInput>
    createMany?: aplica_dvCreateManyDeduccionVoluntariaInputEnvelope
    connect?: Enumerable<aplica_dvWhereUniqueInput>
  }

  export type escogeUncheckedCreateNestedManyWithoutDeduccionVoluntariaInput = {
    create?: XOR<Enumerable<escogeCreateWithoutDeduccionVoluntariaInput>, Enumerable<escogeUncheckedCreateWithoutDeduccionVoluntariaInput>>
    connectOrCreate?: Enumerable<escogeCreateOrConnectWithoutDeduccionVoluntariaInput>
    createMany?: escogeCreateManyDeduccionVoluntariaInputEnvelope
    connect?: Enumerable<escogeWhereUniqueInput>
  }

  export type proyectoUpdateOneRequiredWithoutDeduccionVoluntariaInput = {
    create?: XOR<proyectoCreateWithoutDeduccionVoluntariaInput, proyectoUncheckedCreateWithoutDeduccionVoluntariaInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutDeduccionVoluntariaInput
    upsert?: proyectoUpsertWithoutDeduccionVoluntariaInput
    connect?: proyectoWhereUniqueInput
    update?: XOR<proyectoUpdateWithoutDeduccionVoluntariaInput, proyectoUncheckedUpdateWithoutDeduccionVoluntariaInput>
  }

  export type aplica_dvUpdateManyWithoutDeduccionVoluntariaInput = {
    create?: XOR<Enumerable<aplica_dvCreateWithoutDeduccionVoluntariaInput>, Enumerable<aplica_dvUncheckedCreateWithoutDeduccionVoluntariaInput>>
    connectOrCreate?: Enumerable<aplica_dvCreateOrConnectWithoutDeduccionVoluntariaInput>
    upsert?: Enumerable<aplica_dvUpsertWithWhereUniqueWithoutDeduccionVoluntariaInput>
    createMany?: aplica_dvCreateManyDeduccionVoluntariaInputEnvelope
    set?: Enumerable<aplica_dvWhereUniqueInput>
    disconnect?: Enumerable<aplica_dvWhereUniqueInput>
    delete?: Enumerable<aplica_dvWhereUniqueInput>
    connect?: Enumerable<aplica_dvWhereUniqueInput>
    update?: Enumerable<aplica_dvUpdateWithWhereUniqueWithoutDeduccionVoluntariaInput>
    updateMany?: Enumerable<aplica_dvUpdateManyWithWhereWithoutDeduccionVoluntariaInput>
    deleteMany?: Enumerable<aplica_dvScalarWhereInput>
  }

  export type escogeUpdateManyWithoutDeduccionVoluntariaInput = {
    create?: XOR<Enumerable<escogeCreateWithoutDeduccionVoluntariaInput>, Enumerable<escogeUncheckedCreateWithoutDeduccionVoluntariaInput>>
    connectOrCreate?: Enumerable<escogeCreateOrConnectWithoutDeduccionVoluntariaInput>
    upsert?: Enumerable<escogeUpsertWithWhereUniqueWithoutDeduccionVoluntariaInput>
    createMany?: escogeCreateManyDeduccionVoluntariaInputEnvelope
    set?: Enumerable<escogeWhereUniqueInput>
    disconnect?: Enumerable<escogeWhereUniqueInput>
    delete?: Enumerable<escogeWhereUniqueInput>
    connect?: Enumerable<escogeWhereUniqueInput>
    update?: Enumerable<escogeUpdateWithWhereUniqueWithoutDeduccionVoluntariaInput>
    updateMany?: Enumerable<escogeUpdateManyWithWhereWithoutDeduccionVoluntariaInput>
    deleteMany?: Enumerable<escogeScalarWhereInput>
  }

  export type aplica_dvUncheckedUpdateManyWithoutDeduccionVoluntariaInput = {
    create?: XOR<Enumerable<aplica_dvCreateWithoutDeduccionVoluntariaInput>, Enumerable<aplica_dvUncheckedCreateWithoutDeduccionVoluntariaInput>>
    connectOrCreate?: Enumerable<aplica_dvCreateOrConnectWithoutDeduccionVoluntariaInput>
    upsert?: Enumerable<aplica_dvUpsertWithWhereUniqueWithoutDeduccionVoluntariaInput>
    createMany?: aplica_dvCreateManyDeduccionVoluntariaInputEnvelope
    set?: Enumerable<aplica_dvWhereUniqueInput>
    disconnect?: Enumerable<aplica_dvWhereUniqueInput>
    delete?: Enumerable<aplica_dvWhereUniqueInput>
    connect?: Enumerable<aplica_dvWhereUniqueInput>
    update?: Enumerable<aplica_dvUpdateWithWhereUniqueWithoutDeduccionVoluntariaInput>
    updateMany?: Enumerable<aplica_dvUpdateManyWithWhereWithoutDeduccionVoluntariaInput>
    deleteMany?: Enumerable<aplica_dvScalarWhereInput>
  }

  export type escogeUncheckedUpdateManyWithoutDeduccionVoluntariaInput = {
    create?: XOR<Enumerable<escogeCreateWithoutDeduccionVoluntariaInput>, Enumerable<escogeUncheckedCreateWithoutDeduccionVoluntariaInput>>
    connectOrCreate?: Enumerable<escogeCreateOrConnectWithoutDeduccionVoluntariaInput>
    upsert?: Enumerable<escogeUpsertWithWhereUniqueWithoutDeduccionVoluntariaInput>
    createMany?: escogeCreateManyDeduccionVoluntariaInputEnvelope
    set?: Enumerable<escogeWhereUniqueInput>
    disconnect?: Enumerable<escogeWhereUniqueInput>
    delete?: Enumerable<escogeWhereUniqueInput>
    connect?: Enumerable<escogeWhereUniqueInput>
    update?: Enumerable<escogeUpdateWithWhereUniqueWithoutDeduccionVoluntariaInput>
    updateMany?: Enumerable<escogeUpdateManyWithWhereWithoutDeduccionVoluntariaInput>
    deleteMany?: Enumerable<escogeScalarWhereInput>
  }

  export type personaCreateNestedOneWithoutEmpleadoInput = {
    create?: XOR<personaCreateWithoutEmpleadoInput, personaUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: personaCreateOrConnectWithoutEmpleadoInput
    connect?: personaWhereUniqueInput
  }

  export type empresaCreateNestedOneWithoutEmpleadoInput = {
    create?: XOR<empresaCreateWithoutEmpleadoInput, empresaUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: empresaCreateOrConnectWithoutEmpleadoInput
    connect?: empresaWhereUniqueInput
  }

  export type escogeCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<escogeCreateWithoutEmpleadoInput>, Enumerable<escogeUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<escogeCreateOrConnectWithoutEmpleadoInput>
    createMany?: escogeCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<escogeWhereUniqueInput>
  }

  export type esContratadoCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<esContratadoCreateWithoutEmpleadoInput>, Enumerable<esContratadoUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<esContratadoCreateOrConnectWithoutEmpleadoInput>
    createMany?: esContratadoCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<esContratadoWhereUniqueInput>
  }

  export type pagoCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<pagoCreateWithoutEmpleadoInput>, Enumerable<pagoUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<pagoCreateOrConnectWithoutEmpleadoInput>
    createMany?: pagoCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<pagoWhereUniqueInput>
  }

  export type reporteHorasCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutEmpleadoInput>, Enumerable<reporteHorasUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutEmpleadoInput>
    createMany?: reporteHorasCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<reporteHorasWhereUniqueInput>
  }

  export type seleccionaCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<seleccionaCreateWithoutEmpleadoInput>, Enumerable<seleccionaUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<seleccionaCreateOrConnectWithoutEmpleadoInput>
    createMany?: seleccionaCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<seleccionaWhereUniqueInput>
  }

  export type escogeUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<escogeCreateWithoutEmpleadoInput>, Enumerable<escogeUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<escogeCreateOrConnectWithoutEmpleadoInput>
    createMany?: escogeCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<escogeWhereUniqueInput>
  }

  export type esContratadoUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<esContratadoCreateWithoutEmpleadoInput>, Enumerable<esContratadoUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<esContratadoCreateOrConnectWithoutEmpleadoInput>
    createMany?: esContratadoCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<esContratadoWhereUniqueInput>
  }

  export type pagoUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<pagoCreateWithoutEmpleadoInput>, Enumerable<pagoUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<pagoCreateOrConnectWithoutEmpleadoInput>
    createMany?: pagoCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<pagoWhereUniqueInput>
  }

  export type reporteHorasUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutEmpleadoInput>, Enumerable<reporteHorasUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutEmpleadoInput>
    createMany?: reporteHorasCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<reporteHorasWhereUniqueInput>
  }

  export type seleccionaUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<seleccionaCreateWithoutEmpleadoInput>, Enumerable<seleccionaUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<seleccionaCreateOrConnectWithoutEmpleadoInput>
    createMany?: seleccionaCreateManyEmpleadoInputEnvelope
    connect?: Enumerable<seleccionaWhereUniqueInput>
  }

  export type personaUpdateOneRequiredWithoutEmpleadoInput = {
    create?: XOR<personaCreateWithoutEmpleadoInput, personaUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: personaCreateOrConnectWithoutEmpleadoInput
    upsert?: personaUpsertWithoutEmpleadoInput
    connect?: personaWhereUniqueInput
    update?: XOR<personaUpdateWithoutEmpleadoInput, personaUncheckedUpdateWithoutEmpleadoInput>
  }

  export type empresaUpdateOneWithoutEmpleadoInput = {
    create?: XOR<empresaCreateWithoutEmpleadoInput, empresaUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: empresaCreateOrConnectWithoutEmpleadoInput
    upsert?: empresaUpsertWithoutEmpleadoInput
    disconnect?: boolean
    delete?: boolean
    connect?: empresaWhereUniqueInput
    update?: XOR<empresaUpdateWithoutEmpleadoInput, empresaUncheckedUpdateWithoutEmpleadoInput>
  }

  export type escogeUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<escogeCreateWithoutEmpleadoInput>, Enumerable<escogeUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<escogeCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<escogeUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: escogeCreateManyEmpleadoInputEnvelope
    set?: Enumerable<escogeWhereUniqueInput>
    disconnect?: Enumerable<escogeWhereUniqueInput>
    delete?: Enumerable<escogeWhereUniqueInput>
    connect?: Enumerable<escogeWhereUniqueInput>
    update?: Enumerable<escogeUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<escogeUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<escogeScalarWhereInput>
  }

  export type esContratadoUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<esContratadoCreateWithoutEmpleadoInput>, Enumerable<esContratadoUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<esContratadoCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<esContratadoUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: esContratadoCreateManyEmpleadoInputEnvelope
    set?: Enumerable<esContratadoWhereUniqueInput>
    disconnect?: Enumerable<esContratadoWhereUniqueInput>
    delete?: Enumerable<esContratadoWhereUniqueInput>
    connect?: Enumerable<esContratadoWhereUniqueInput>
    update?: Enumerable<esContratadoUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<esContratadoUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<esContratadoScalarWhereInput>
  }

  export type pagoUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<pagoCreateWithoutEmpleadoInput>, Enumerable<pagoUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<pagoCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<pagoUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: pagoCreateManyEmpleadoInputEnvelope
    set?: Enumerable<pagoWhereUniqueInput>
    disconnect?: Enumerable<pagoWhereUniqueInput>
    delete?: Enumerable<pagoWhereUniqueInput>
    connect?: Enumerable<pagoWhereUniqueInput>
    update?: Enumerable<pagoUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<pagoUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<pagoScalarWhereInput>
  }

  export type reporteHorasUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutEmpleadoInput>, Enumerable<reporteHorasUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<reporteHorasUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: reporteHorasCreateManyEmpleadoInputEnvelope
    set?: Enumerable<reporteHorasWhereUniqueInput>
    disconnect?: Enumerable<reporteHorasWhereUniqueInput>
    delete?: Enumerable<reporteHorasWhereUniqueInput>
    connect?: Enumerable<reporteHorasWhereUniqueInput>
    update?: Enumerable<reporteHorasUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<reporteHorasUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<reporteHorasScalarWhereInput>
  }

  export type seleccionaUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<seleccionaCreateWithoutEmpleadoInput>, Enumerable<seleccionaUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<seleccionaCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<seleccionaUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: seleccionaCreateManyEmpleadoInputEnvelope
    set?: Enumerable<seleccionaWhereUniqueInput>
    disconnect?: Enumerable<seleccionaWhereUniqueInput>
    delete?: Enumerable<seleccionaWhereUniqueInput>
    connect?: Enumerable<seleccionaWhereUniqueInput>
    update?: Enumerable<seleccionaUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<seleccionaUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<seleccionaScalarWhereInput>
  }

  export type escogeUncheckedUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<escogeCreateWithoutEmpleadoInput>, Enumerable<escogeUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<escogeCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<escogeUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: escogeCreateManyEmpleadoInputEnvelope
    set?: Enumerable<escogeWhereUniqueInput>
    disconnect?: Enumerable<escogeWhereUniqueInput>
    delete?: Enumerable<escogeWhereUniqueInput>
    connect?: Enumerable<escogeWhereUniqueInput>
    update?: Enumerable<escogeUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<escogeUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<escogeScalarWhereInput>
  }

  export type esContratadoUncheckedUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<esContratadoCreateWithoutEmpleadoInput>, Enumerable<esContratadoUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<esContratadoCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<esContratadoUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: esContratadoCreateManyEmpleadoInputEnvelope
    set?: Enumerable<esContratadoWhereUniqueInput>
    disconnect?: Enumerable<esContratadoWhereUniqueInput>
    delete?: Enumerable<esContratadoWhereUniqueInput>
    connect?: Enumerable<esContratadoWhereUniqueInput>
    update?: Enumerable<esContratadoUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<esContratadoUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<esContratadoScalarWhereInput>
  }

  export type pagoUncheckedUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<pagoCreateWithoutEmpleadoInput>, Enumerable<pagoUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<pagoCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<pagoUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: pagoCreateManyEmpleadoInputEnvelope
    set?: Enumerable<pagoWhereUniqueInput>
    disconnect?: Enumerable<pagoWhereUniqueInput>
    delete?: Enumerable<pagoWhereUniqueInput>
    connect?: Enumerable<pagoWhereUniqueInput>
    update?: Enumerable<pagoUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<pagoUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<pagoScalarWhereInput>
  }

  export type reporteHorasUncheckedUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutEmpleadoInput>, Enumerable<reporteHorasUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<reporteHorasUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: reporteHorasCreateManyEmpleadoInputEnvelope
    set?: Enumerable<reporteHorasWhereUniqueInput>
    disconnect?: Enumerable<reporteHorasWhereUniqueInput>
    delete?: Enumerable<reporteHorasWhereUniqueInput>
    connect?: Enumerable<reporteHorasWhereUniqueInput>
    update?: Enumerable<reporteHorasUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<reporteHorasUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<reporteHorasScalarWhereInput>
  }

  export type seleccionaUncheckedUpdateManyWithoutEmpleadoInput = {
    create?: XOR<Enumerable<seleccionaCreateWithoutEmpleadoInput>, Enumerable<seleccionaUncheckedCreateWithoutEmpleadoInput>>
    connectOrCreate?: Enumerable<seleccionaCreateOrConnectWithoutEmpleadoInput>
    upsert?: Enumerable<seleccionaUpsertWithWhereUniqueWithoutEmpleadoInput>
    createMany?: seleccionaCreateManyEmpleadoInputEnvelope
    set?: Enumerable<seleccionaWhereUniqueInput>
    disconnect?: Enumerable<seleccionaWhereUniqueInput>
    delete?: Enumerable<seleccionaWhereUniqueInput>
    connect?: Enumerable<seleccionaWhereUniqueInput>
    update?: Enumerable<seleccionaUpdateWithWhereUniqueWithoutEmpleadoInput>
    updateMany?: Enumerable<seleccionaUpdateManyWithWhereWithoutEmpleadoInput>
    deleteMany?: Enumerable<seleccionaScalarWhereInput>
  }

  export type personaCreateNestedOneWithoutEmpleadorInput = {
    create?: XOR<personaCreateWithoutEmpleadorInput, personaUncheckedCreateWithoutEmpleadorInput>
    connectOrCreate?: personaCreateOrConnectWithoutEmpleadorInput
    connect?: personaWhereUniqueInput
  }

  export type empresaCreateNestedManyWithoutEmpleadorInput = {
    create?: XOR<Enumerable<empresaCreateWithoutEmpleadorInput>, Enumerable<empresaUncheckedCreateWithoutEmpleadorInput>>
    connectOrCreate?: Enumerable<empresaCreateOrConnectWithoutEmpleadorInput>
    createMany?: empresaCreateManyEmpleadorInputEnvelope
    connect?: Enumerable<empresaWhereUniqueInput>
  }

  export type reporteHorasCreateNestedManyWithoutEmpleadorInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutEmpleadorInput>, Enumerable<reporteHorasUncheckedCreateWithoutEmpleadorInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutEmpleadorInput>
    createMany?: reporteHorasCreateManyEmpleadorInputEnvelope
    connect?: Enumerable<reporteHorasWhereUniqueInput>
  }

  export type empresaUncheckedCreateNestedManyWithoutEmpleadorInput = {
    create?: XOR<Enumerable<empresaCreateWithoutEmpleadorInput>, Enumerable<empresaUncheckedCreateWithoutEmpleadorInput>>
    connectOrCreate?: Enumerable<empresaCreateOrConnectWithoutEmpleadorInput>
    createMany?: empresaCreateManyEmpleadorInputEnvelope
    connect?: Enumerable<empresaWhereUniqueInput>
  }

  export type reporteHorasUncheckedCreateNestedManyWithoutEmpleadorInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutEmpleadorInput>, Enumerable<reporteHorasUncheckedCreateWithoutEmpleadorInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutEmpleadorInput>
    createMany?: reporteHorasCreateManyEmpleadorInputEnvelope
    connect?: Enumerable<reporteHorasWhereUniqueInput>
  }

  export type personaUpdateOneRequiredWithoutEmpleadorInput = {
    create?: XOR<personaCreateWithoutEmpleadorInput, personaUncheckedCreateWithoutEmpleadorInput>
    connectOrCreate?: personaCreateOrConnectWithoutEmpleadorInput
    upsert?: personaUpsertWithoutEmpleadorInput
    connect?: personaWhereUniqueInput
    update?: XOR<personaUpdateWithoutEmpleadorInput, personaUncheckedUpdateWithoutEmpleadorInput>
  }

  export type empresaUpdateManyWithoutEmpleadorInput = {
    create?: XOR<Enumerable<empresaCreateWithoutEmpleadorInput>, Enumerable<empresaUncheckedCreateWithoutEmpleadorInput>>
    connectOrCreate?: Enumerable<empresaCreateOrConnectWithoutEmpleadorInput>
    upsert?: Enumerable<empresaUpsertWithWhereUniqueWithoutEmpleadorInput>
    createMany?: empresaCreateManyEmpleadorInputEnvelope
    set?: Enumerable<empresaWhereUniqueInput>
    disconnect?: Enumerable<empresaWhereUniqueInput>
    delete?: Enumerable<empresaWhereUniqueInput>
    connect?: Enumerable<empresaWhereUniqueInput>
    update?: Enumerable<empresaUpdateWithWhereUniqueWithoutEmpleadorInput>
    updateMany?: Enumerable<empresaUpdateManyWithWhereWithoutEmpleadorInput>
    deleteMany?: Enumerable<empresaScalarWhereInput>
  }

  export type reporteHorasUpdateManyWithoutEmpleadorInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutEmpleadorInput>, Enumerable<reporteHorasUncheckedCreateWithoutEmpleadorInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutEmpleadorInput>
    upsert?: Enumerable<reporteHorasUpsertWithWhereUniqueWithoutEmpleadorInput>
    createMany?: reporteHorasCreateManyEmpleadorInputEnvelope
    set?: Enumerable<reporteHorasWhereUniqueInput>
    disconnect?: Enumerable<reporteHorasWhereUniqueInput>
    delete?: Enumerable<reporteHorasWhereUniqueInput>
    connect?: Enumerable<reporteHorasWhereUniqueInput>
    update?: Enumerable<reporteHorasUpdateWithWhereUniqueWithoutEmpleadorInput>
    updateMany?: Enumerable<reporteHorasUpdateManyWithWhereWithoutEmpleadorInput>
    deleteMany?: Enumerable<reporteHorasScalarWhereInput>
  }

  export type empresaUncheckedUpdateManyWithoutEmpleadorInput = {
    create?: XOR<Enumerable<empresaCreateWithoutEmpleadorInput>, Enumerable<empresaUncheckedCreateWithoutEmpleadorInput>>
    connectOrCreate?: Enumerable<empresaCreateOrConnectWithoutEmpleadorInput>
    upsert?: Enumerable<empresaUpsertWithWhereUniqueWithoutEmpleadorInput>
    createMany?: empresaCreateManyEmpleadorInputEnvelope
    set?: Enumerable<empresaWhereUniqueInput>
    disconnect?: Enumerable<empresaWhereUniqueInput>
    delete?: Enumerable<empresaWhereUniqueInput>
    connect?: Enumerable<empresaWhereUniqueInput>
    update?: Enumerable<empresaUpdateWithWhereUniqueWithoutEmpleadorInput>
    updateMany?: Enumerable<empresaUpdateManyWithWhereWithoutEmpleadorInput>
    deleteMany?: Enumerable<empresaScalarWhereInput>
  }

  export type reporteHorasUncheckedUpdateManyWithoutEmpleadorInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutEmpleadorInput>, Enumerable<reporteHorasUncheckedCreateWithoutEmpleadorInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutEmpleadorInput>
    upsert?: Enumerable<reporteHorasUpsertWithWhereUniqueWithoutEmpleadorInput>
    createMany?: reporteHorasCreateManyEmpleadorInputEnvelope
    set?: Enumerable<reporteHorasWhereUniqueInput>
    disconnect?: Enumerable<reporteHorasWhereUniqueInput>
    delete?: Enumerable<reporteHorasWhereUniqueInput>
    connect?: Enumerable<reporteHorasWhereUniqueInput>
    update?: Enumerable<reporteHorasUpdateWithWhereUniqueWithoutEmpleadorInput>
    updateMany?: Enumerable<reporteHorasUpdateManyWithWhereWithoutEmpleadorInput>
    deleteMany?: Enumerable<reporteHorasScalarWhereInput>
  }

  export type empleadorCreateNestedOneWithoutEmpresaInput = {
    create?: XOR<empleadorCreateWithoutEmpresaInput, empleadorUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: empleadorCreateOrConnectWithoutEmpresaInput
    connect?: empleadorWhereUniqueInput
  }

  export type empleadoCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<empleadoCreateWithoutEmpresaInput>, Enumerable<empleadoUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<empleadoCreateOrConnectWithoutEmpresaInput>
    createMany?: empleadoCreateManyEmpresaInputEnvelope
    connect?: Enumerable<empleadoWhereUniqueInput>
  }

  export type proyectoCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<proyectoCreateWithoutEmpresaInput>, Enumerable<proyectoUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<proyectoCreateOrConnectWithoutEmpresaInput>
    createMany?: proyectoCreateManyEmpresaInputEnvelope
    connect?: Enumerable<proyectoWhereUniqueInput>
  }

  export type empleadoUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<empleadoCreateWithoutEmpresaInput>, Enumerable<empleadoUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<empleadoCreateOrConnectWithoutEmpresaInput>
    createMany?: empleadoCreateManyEmpresaInputEnvelope
    connect?: Enumerable<empleadoWhereUniqueInput>
  }

  export type proyectoUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<proyectoCreateWithoutEmpresaInput>, Enumerable<proyectoUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<proyectoCreateOrConnectWithoutEmpresaInput>
    createMany?: proyectoCreateManyEmpresaInputEnvelope
    connect?: Enumerable<proyectoWhereUniqueInput>
  }

  export type empleadorUpdateOneWithoutEmpresaInput = {
    create?: XOR<empleadorCreateWithoutEmpresaInput, empleadorUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: empleadorCreateOrConnectWithoutEmpresaInput
    upsert?: empleadorUpsertWithoutEmpresaInput
    disconnect?: boolean
    delete?: boolean
    connect?: empleadorWhereUniqueInput
    update?: XOR<empleadorUpdateWithoutEmpresaInput, empleadorUncheckedUpdateWithoutEmpresaInput>
  }

  export type empleadoUpdateManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<empleadoCreateWithoutEmpresaInput>, Enumerable<empleadoUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<empleadoCreateOrConnectWithoutEmpresaInput>
    upsert?: Enumerable<empleadoUpsertWithWhereUniqueWithoutEmpresaInput>
    createMany?: empleadoCreateManyEmpresaInputEnvelope
    set?: Enumerable<empleadoWhereUniqueInput>
    disconnect?: Enumerable<empleadoWhereUniqueInput>
    delete?: Enumerable<empleadoWhereUniqueInput>
    connect?: Enumerable<empleadoWhereUniqueInput>
    update?: Enumerable<empleadoUpdateWithWhereUniqueWithoutEmpresaInput>
    updateMany?: Enumerable<empleadoUpdateManyWithWhereWithoutEmpresaInput>
    deleteMany?: Enumerable<empleadoScalarWhereInput>
  }

  export type proyectoUpdateManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<proyectoCreateWithoutEmpresaInput>, Enumerable<proyectoUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<proyectoCreateOrConnectWithoutEmpresaInput>
    upsert?: Enumerable<proyectoUpsertWithWhereUniqueWithoutEmpresaInput>
    createMany?: proyectoCreateManyEmpresaInputEnvelope
    set?: Enumerable<proyectoWhereUniqueInput>
    disconnect?: Enumerable<proyectoWhereUniqueInput>
    delete?: Enumerable<proyectoWhereUniqueInput>
    connect?: Enumerable<proyectoWhereUniqueInput>
    update?: Enumerable<proyectoUpdateWithWhereUniqueWithoutEmpresaInput>
    updateMany?: Enumerable<proyectoUpdateManyWithWhereWithoutEmpresaInput>
    deleteMany?: Enumerable<proyectoScalarWhereInput>
  }

  export type empleadoUncheckedUpdateManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<empleadoCreateWithoutEmpresaInput>, Enumerable<empleadoUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<empleadoCreateOrConnectWithoutEmpresaInput>
    upsert?: Enumerable<empleadoUpsertWithWhereUniqueWithoutEmpresaInput>
    createMany?: empleadoCreateManyEmpresaInputEnvelope
    set?: Enumerable<empleadoWhereUniqueInput>
    disconnect?: Enumerable<empleadoWhereUniqueInput>
    delete?: Enumerable<empleadoWhereUniqueInput>
    connect?: Enumerable<empleadoWhereUniqueInput>
    update?: Enumerable<empleadoUpdateWithWhereUniqueWithoutEmpresaInput>
    updateMany?: Enumerable<empleadoUpdateManyWithWhereWithoutEmpresaInput>
    deleteMany?: Enumerable<empleadoScalarWhereInput>
  }

  export type proyectoUncheckedUpdateManyWithoutEmpresaInput = {
    create?: XOR<Enumerable<proyectoCreateWithoutEmpresaInput>, Enumerable<proyectoUncheckedCreateWithoutEmpresaInput>>
    connectOrCreate?: Enumerable<proyectoCreateOrConnectWithoutEmpresaInput>
    upsert?: Enumerable<proyectoUpsertWithWhereUniqueWithoutEmpresaInput>
    createMany?: proyectoCreateManyEmpresaInputEnvelope
    set?: Enumerable<proyectoWhereUniqueInput>
    disconnect?: Enumerable<proyectoWhereUniqueInput>
    delete?: Enumerable<proyectoWhereUniqueInput>
    connect?: Enumerable<proyectoWhereUniqueInput>
    update?: Enumerable<proyectoUpdateWithWhereUniqueWithoutEmpresaInput>
    updateMany?: Enumerable<proyectoUpdateManyWithWhereWithoutEmpresaInput>
    deleteMany?: Enumerable<proyectoScalarWhereInput>
  }

  export type empleadoCreateNestedOneWithoutEscogeInput = {
    create?: XOR<empleadoCreateWithoutEscogeInput, empleadoUncheckedCreateWithoutEscogeInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutEscogeInput
    connect?: empleadoWhereUniqueInput
  }

  export type deduccionVoluntariaCreateNestedOneWithoutEscogeInput = {
    create?: XOR<deduccionVoluntariaCreateWithoutEscogeInput, deduccionVoluntariaUncheckedCreateWithoutEscogeInput>
    connectOrCreate?: deduccionVoluntariaCreateOrConnectWithoutEscogeInput
    connect?: deduccionVoluntariaWhereUniqueInput
  }

  export type empleadoUpdateOneRequiredWithoutEscogeInput = {
    create?: XOR<empleadoCreateWithoutEscogeInput, empleadoUncheckedCreateWithoutEscogeInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutEscogeInput
    upsert?: empleadoUpsertWithoutEscogeInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<empleadoUpdateWithoutEscogeInput, empleadoUncheckedUpdateWithoutEscogeInput>
  }

  export type deduccionVoluntariaUpdateOneRequiredWithoutEscogeInput = {
    create?: XOR<deduccionVoluntariaCreateWithoutEscogeInput, deduccionVoluntariaUncheckedCreateWithoutEscogeInput>
    connectOrCreate?: deduccionVoluntariaCreateOrConnectWithoutEscogeInput
    upsert?: deduccionVoluntariaUpsertWithoutEscogeInput
    connect?: deduccionVoluntariaWhereUniqueInput
    update?: XOR<deduccionVoluntariaUpdateWithoutEscogeInput, deduccionVoluntariaUncheckedUpdateWithoutEscogeInput>
  }

  export type empleadoCreateNestedOneWithoutEsContratadoInput = {
    create?: XOR<empleadoCreateWithoutEsContratadoInput, empleadoUncheckedCreateWithoutEsContratadoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutEsContratadoInput
    connect?: empleadoWhereUniqueInput
  }

  export type proyectoCreateNestedOneWithoutEsContratadoInput = {
    create?: XOR<proyectoCreateWithoutEsContratadoInput, proyectoUncheckedCreateWithoutEsContratadoInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutEsContratadoInput
    connect?: proyectoWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type empleadoUpdateOneRequiredWithoutEsContratadoInput = {
    create?: XOR<empleadoCreateWithoutEsContratadoInput, empleadoUncheckedCreateWithoutEsContratadoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutEsContratadoInput
    upsert?: empleadoUpsertWithoutEsContratadoInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<empleadoUpdateWithoutEsContratadoInput, empleadoUncheckedUpdateWithoutEsContratadoInput>
  }

  export type proyectoUpdateOneRequiredWithoutEsContratadoInput = {
    create?: XOR<proyectoCreateWithoutEsContratadoInput, proyectoUncheckedCreateWithoutEsContratadoInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutEsContratadoInput
    upsert?: proyectoUpsertWithoutEsContratadoInput
    connect?: proyectoWhereUniqueInput
    update?: XOR<proyectoUpdateWithoutEsContratadoInput, proyectoUncheckedUpdateWithoutEsContratadoInput>
  }

  export type pagoCreateNestedOneWithoutGeneraInput = {
    create?: XOR<pagoCreateWithoutGeneraInput, pagoUncheckedCreateWithoutGeneraInput>
    connectOrCreate?: pagoCreateOrConnectWithoutGeneraInput
    connect?: pagoWhereUniqueInput
  }

  export type proyectoCreateNestedOneWithoutGeneraInput = {
    create?: XOR<proyectoCreateWithoutGeneraInput, proyectoUncheckedCreateWithoutGeneraInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutGeneraInput
    connect?: proyectoWhereUniqueInput
  }

  export type pagoUpdateOneRequiredWithoutGeneraInput = {
    create?: XOR<pagoCreateWithoutGeneraInput, pagoUncheckedCreateWithoutGeneraInput>
    connectOrCreate?: pagoCreateOrConnectWithoutGeneraInput
    upsert?: pagoUpsertWithoutGeneraInput
    connect?: pagoWhereUniqueInput
    update?: XOR<pagoUpdateWithoutGeneraInput, pagoUncheckedUpdateWithoutGeneraInput>
  }

  export type proyectoUpdateOneRequiredWithoutGeneraInput = {
    create?: XOR<proyectoCreateWithoutGeneraInput, proyectoUncheckedCreateWithoutGeneraInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutGeneraInput
    upsert?: proyectoUpsertWithoutGeneraInput
    connect?: proyectoWhereUniqueInput
    update?: XOR<proyectoUpdateWithoutGeneraInput, proyectoUncheckedUpdateWithoutGeneraInput>
  }

  export type personaCreateNestedOneWithoutHace_usoInput = {
    create?: XOR<personaCreateWithoutHace_usoInput, personaUncheckedCreateWithoutHace_usoInput>
    connectOrCreate?: personaCreateOrConnectWithoutHace_usoInput
    connect?: personaWhereUniqueInput
  }

  export type credencialesCreateNestedOneWithoutHace_usoInput = {
    create?: XOR<credencialesCreateWithoutHace_usoInput, credencialesUncheckedCreateWithoutHace_usoInput>
    connectOrCreate?: credencialesCreateOrConnectWithoutHace_usoInput
    connect?: credencialesWhereUniqueInput
  }

  export type personaUpdateOneRequiredWithoutHace_usoInput = {
    create?: XOR<personaCreateWithoutHace_usoInput, personaUncheckedCreateWithoutHace_usoInput>
    connectOrCreate?: personaCreateOrConnectWithoutHace_usoInput
    upsert?: personaUpsertWithoutHace_usoInput
    connect?: personaWhereUniqueInput
    update?: XOR<personaUpdateWithoutHace_usoInput, personaUncheckedUpdateWithoutHace_usoInput>
  }

  export type credencialesUpdateOneRequiredWithoutHace_usoInput = {
    create?: XOR<credencialesCreateWithoutHace_usoInput, credencialesUncheckedCreateWithoutHace_usoInput>
    connectOrCreate?: credencialesCreateOrConnectWithoutHace_usoInput
    upsert?: credencialesUpsertWithoutHace_usoInput
    connect?: credencialesWhereUniqueInput
    update?: XOR<credencialesUpdateWithoutHace_usoInput, credencialesUncheckedUpdateWithoutHace_usoInput>
  }

  export type empleadoCreateNestedOneWithoutPagoInput = {
    create?: XOR<empleadoCreateWithoutPagoInput, empleadoUncheckedCreateWithoutPagoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutPagoInput
    connect?: empleadoWhereUniqueInput
  }

  export type aplica_bCreateNestedManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_bCreateWithoutPagoInput>, Enumerable<aplica_bUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_bCreateOrConnectWithoutPagoInput>
    createMany?: aplica_bCreateManyPagoInputEnvelope
    connect?: Enumerable<aplica_bWhereUniqueInput>
  }

  export type aplica_doCreateNestedManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_doCreateWithoutPagoInput>, Enumerable<aplica_doUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_doCreateOrConnectWithoutPagoInput>
    createMany?: aplica_doCreateManyPagoInputEnvelope
    connect?: Enumerable<aplica_doWhereUniqueInput>
  }

  export type aplica_dvCreateNestedManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_dvCreateWithoutPagoInput>, Enumerable<aplica_dvUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_dvCreateOrConnectWithoutPagoInput>
    createMany?: aplica_dvCreateManyPagoInputEnvelope
    connect?: Enumerable<aplica_dvWhereUniqueInput>
  }

  export type generaCreateNestedManyWithoutPagoInput = {
    create?: XOR<Enumerable<generaCreateWithoutPagoInput>, Enumerable<generaUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<generaCreateOrConnectWithoutPagoInput>
    createMany?: generaCreateManyPagoInputEnvelope
    connect?: Enumerable<generaWhereUniqueInput>
  }

  export type aplica_bUncheckedCreateNestedManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_bCreateWithoutPagoInput>, Enumerable<aplica_bUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_bCreateOrConnectWithoutPagoInput>
    createMany?: aplica_bCreateManyPagoInputEnvelope
    connect?: Enumerable<aplica_bWhereUniqueInput>
  }

  export type aplica_doUncheckedCreateNestedManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_doCreateWithoutPagoInput>, Enumerable<aplica_doUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_doCreateOrConnectWithoutPagoInput>
    createMany?: aplica_doCreateManyPagoInputEnvelope
    connect?: Enumerable<aplica_doWhereUniqueInput>
  }

  export type aplica_dvUncheckedCreateNestedManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_dvCreateWithoutPagoInput>, Enumerable<aplica_dvUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_dvCreateOrConnectWithoutPagoInput>
    createMany?: aplica_dvCreateManyPagoInputEnvelope
    connect?: Enumerable<aplica_dvWhereUniqueInput>
  }

  export type generaUncheckedCreateNestedManyWithoutPagoInput = {
    create?: XOR<Enumerable<generaCreateWithoutPagoInput>, Enumerable<generaUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<generaCreateOrConnectWithoutPagoInput>
    createMany?: generaCreateManyPagoInputEnvelope
    connect?: Enumerable<generaWhereUniqueInput>
  }

  export type empleadoUpdateOneRequiredWithoutPagoInput = {
    create?: XOR<empleadoCreateWithoutPagoInput, empleadoUncheckedCreateWithoutPagoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutPagoInput
    upsert?: empleadoUpsertWithoutPagoInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<empleadoUpdateWithoutPagoInput, empleadoUncheckedUpdateWithoutPagoInput>
  }

  export type aplica_bUpdateManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_bCreateWithoutPagoInput>, Enumerable<aplica_bUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_bCreateOrConnectWithoutPagoInput>
    upsert?: Enumerable<aplica_bUpsertWithWhereUniqueWithoutPagoInput>
    createMany?: aplica_bCreateManyPagoInputEnvelope
    set?: Enumerable<aplica_bWhereUniqueInput>
    disconnect?: Enumerable<aplica_bWhereUniqueInput>
    delete?: Enumerable<aplica_bWhereUniqueInput>
    connect?: Enumerable<aplica_bWhereUniqueInput>
    update?: Enumerable<aplica_bUpdateWithWhereUniqueWithoutPagoInput>
    updateMany?: Enumerable<aplica_bUpdateManyWithWhereWithoutPagoInput>
    deleteMany?: Enumerable<aplica_bScalarWhereInput>
  }

  export type aplica_doUpdateManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_doCreateWithoutPagoInput>, Enumerable<aplica_doUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_doCreateOrConnectWithoutPagoInput>
    upsert?: Enumerable<aplica_doUpsertWithWhereUniqueWithoutPagoInput>
    createMany?: aplica_doCreateManyPagoInputEnvelope
    set?: Enumerable<aplica_doWhereUniqueInput>
    disconnect?: Enumerable<aplica_doWhereUniqueInput>
    delete?: Enumerable<aplica_doWhereUniqueInput>
    connect?: Enumerable<aplica_doWhereUniqueInput>
    update?: Enumerable<aplica_doUpdateWithWhereUniqueWithoutPagoInput>
    updateMany?: Enumerable<aplica_doUpdateManyWithWhereWithoutPagoInput>
    deleteMany?: Enumerable<aplica_doScalarWhereInput>
  }

  export type aplica_dvUpdateManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_dvCreateWithoutPagoInput>, Enumerable<aplica_dvUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_dvCreateOrConnectWithoutPagoInput>
    upsert?: Enumerable<aplica_dvUpsertWithWhereUniqueWithoutPagoInput>
    createMany?: aplica_dvCreateManyPagoInputEnvelope
    set?: Enumerable<aplica_dvWhereUniqueInput>
    disconnect?: Enumerable<aplica_dvWhereUniqueInput>
    delete?: Enumerable<aplica_dvWhereUniqueInput>
    connect?: Enumerable<aplica_dvWhereUniqueInput>
    update?: Enumerable<aplica_dvUpdateWithWhereUniqueWithoutPagoInput>
    updateMany?: Enumerable<aplica_dvUpdateManyWithWhereWithoutPagoInput>
    deleteMany?: Enumerable<aplica_dvScalarWhereInput>
  }

  export type generaUpdateManyWithoutPagoInput = {
    create?: XOR<Enumerable<generaCreateWithoutPagoInput>, Enumerable<generaUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<generaCreateOrConnectWithoutPagoInput>
    upsert?: Enumerable<generaUpsertWithWhereUniqueWithoutPagoInput>
    createMany?: generaCreateManyPagoInputEnvelope
    set?: Enumerable<generaWhereUniqueInput>
    disconnect?: Enumerable<generaWhereUniqueInput>
    delete?: Enumerable<generaWhereUniqueInput>
    connect?: Enumerable<generaWhereUniqueInput>
    update?: Enumerable<generaUpdateWithWhereUniqueWithoutPagoInput>
    updateMany?: Enumerable<generaUpdateManyWithWhereWithoutPagoInput>
    deleteMany?: Enumerable<generaScalarWhereInput>
  }

  export type aplica_bUncheckedUpdateManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_bCreateWithoutPagoInput>, Enumerable<aplica_bUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_bCreateOrConnectWithoutPagoInput>
    upsert?: Enumerable<aplica_bUpsertWithWhereUniqueWithoutPagoInput>
    createMany?: aplica_bCreateManyPagoInputEnvelope
    set?: Enumerable<aplica_bWhereUniqueInput>
    disconnect?: Enumerable<aplica_bWhereUniqueInput>
    delete?: Enumerable<aplica_bWhereUniqueInput>
    connect?: Enumerable<aplica_bWhereUniqueInput>
    update?: Enumerable<aplica_bUpdateWithWhereUniqueWithoutPagoInput>
    updateMany?: Enumerable<aplica_bUpdateManyWithWhereWithoutPagoInput>
    deleteMany?: Enumerable<aplica_bScalarWhereInput>
  }

  export type aplica_doUncheckedUpdateManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_doCreateWithoutPagoInput>, Enumerable<aplica_doUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_doCreateOrConnectWithoutPagoInput>
    upsert?: Enumerable<aplica_doUpsertWithWhereUniqueWithoutPagoInput>
    createMany?: aplica_doCreateManyPagoInputEnvelope
    set?: Enumerable<aplica_doWhereUniqueInput>
    disconnect?: Enumerable<aplica_doWhereUniqueInput>
    delete?: Enumerable<aplica_doWhereUniqueInput>
    connect?: Enumerable<aplica_doWhereUniqueInput>
    update?: Enumerable<aplica_doUpdateWithWhereUniqueWithoutPagoInput>
    updateMany?: Enumerable<aplica_doUpdateManyWithWhereWithoutPagoInput>
    deleteMany?: Enumerable<aplica_doScalarWhereInput>
  }

  export type aplica_dvUncheckedUpdateManyWithoutPagoInput = {
    create?: XOR<Enumerable<aplica_dvCreateWithoutPagoInput>, Enumerable<aplica_dvUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<aplica_dvCreateOrConnectWithoutPagoInput>
    upsert?: Enumerable<aplica_dvUpsertWithWhereUniqueWithoutPagoInput>
    createMany?: aplica_dvCreateManyPagoInputEnvelope
    set?: Enumerable<aplica_dvWhereUniqueInput>
    disconnect?: Enumerable<aplica_dvWhereUniqueInput>
    delete?: Enumerable<aplica_dvWhereUniqueInput>
    connect?: Enumerable<aplica_dvWhereUniqueInput>
    update?: Enumerable<aplica_dvUpdateWithWhereUniqueWithoutPagoInput>
    updateMany?: Enumerable<aplica_dvUpdateManyWithWhereWithoutPagoInput>
    deleteMany?: Enumerable<aplica_dvScalarWhereInput>
  }

  export type generaUncheckedUpdateManyWithoutPagoInput = {
    create?: XOR<Enumerable<generaCreateWithoutPagoInput>, Enumerable<generaUncheckedCreateWithoutPagoInput>>
    connectOrCreate?: Enumerable<generaCreateOrConnectWithoutPagoInput>
    upsert?: Enumerable<generaUpsertWithWhereUniqueWithoutPagoInput>
    createMany?: generaCreateManyPagoInputEnvelope
    set?: Enumerable<generaWhereUniqueInput>
    disconnect?: Enumerable<generaWhereUniqueInput>
    delete?: Enumerable<generaWhereUniqueInput>
    connect?: Enumerable<generaWhereUniqueInput>
    update?: Enumerable<generaUpdateWithWhereUniqueWithoutPagoInput>
    updateMany?: Enumerable<generaUpdateManyWithWhereWithoutPagoInput>
    deleteMany?: Enumerable<generaScalarWhereInput>
  }

  export type empleadoCreateNestedOneWithoutPersonaInput = {
    create?: XOR<empleadoCreateWithoutPersonaInput, empleadoUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutPersonaInput
    connect?: empleadoWhereUniqueInput
  }

  export type empleadorCreateNestedOneWithoutPersonaInput = {
    create?: XOR<empleadorCreateWithoutPersonaInput, empleadorUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: empleadorCreateOrConnectWithoutPersonaInput
    connect?: empleadorWhereUniqueInput
  }

  export type hace_usoCreateNestedManyWithoutPersonaInput = {
    create?: XOR<Enumerable<hace_usoCreateWithoutPersonaInput>, Enumerable<hace_usoUncheckedCreateWithoutPersonaInput>>
    connectOrCreate?: Enumerable<hace_usoCreateOrConnectWithoutPersonaInput>
    createMany?: hace_usoCreateManyPersonaInputEnvelope
    connect?: Enumerable<hace_usoWhereUniqueInput>
  }

  export type empleadoUncheckedCreateNestedOneWithoutPersonaInput = {
    create?: XOR<empleadoCreateWithoutPersonaInput, empleadoUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutPersonaInput
    connect?: empleadoWhereUniqueInput
  }

  export type empleadorUncheckedCreateNestedOneWithoutPersonaInput = {
    create?: XOR<empleadorCreateWithoutPersonaInput, empleadorUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: empleadorCreateOrConnectWithoutPersonaInput
    connect?: empleadorWhereUniqueInput
  }

  export type hace_usoUncheckedCreateNestedManyWithoutPersonaInput = {
    create?: XOR<Enumerable<hace_usoCreateWithoutPersonaInput>, Enumerable<hace_usoUncheckedCreateWithoutPersonaInput>>
    connectOrCreate?: Enumerable<hace_usoCreateOrConnectWithoutPersonaInput>
    createMany?: hace_usoCreateManyPersonaInputEnvelope
    connect?: Enumerable<hace_usoWhereUniqueInput>
  }

  export type empleadoUpdateOneWithoutPersonaInput = {
    create?: XOR<empleadoCreateWithoutPersonaInput, empleadoUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutPersonaInput
    upsert?: empleadoUpsertWithoutPersonaInput
    disconnect?: boolean
    delete?: boolean
    connect?: empleadoWhereUniqueInput
    update?: XOR<empleadoUpdateWithoutPersonaInput, empleadoUncheckedUpdateWithoutPersonaInput>
  }

  export type empleadorUpdateOneWithoutPersonaInput = {
    create?: XOR<empleadorCreateWithoutPersonaInput, empleadorUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: empleadorCreateOrConnectWithoutPersonaInput
    upsert?: empleadorUpsertWithoutPersonaInput
    disconnect?: boolean
    delete?: boolean
    connect?: empleadorWhereUniqueInput
    update?: XOR<empleadorUpdateWithoutPersonaInput, empleadorUncheckedUpdateWithoutPersonaInput>
  }

  export type hace_usoUpdateManyWithoutPersonaInput = {
    create?: XOR<Enumerable<hace_usoCreateWithoutPersonaInput>, Enumerable<hace_usoUncheckedCreateWithoutPersonaInput>>
    connectOrCreate?: Enumerable<hace_usoCreateOrConnectWithoutPersonaInput>
    upsert?: Enumerable<hace_usoUpsertWithWhereUniqueWithoutPersonaInput>
    createMany?: hace_usoCreateManyPersonaInputEnvelope
    set?: Enumerable<hace_usoWhereUniqueInput>
    disconnect?: Enumerable<hace_usoWhereUniqueInput>
    delete?: Enumerable<hace_usoWhereUniqueInput>
    connect?: Enumerable<hace_usoWhereUniqueInput>
    update?: Enumerable<hace_usoUpdateWithWhereUniqueWithoutPersonaInput>
    updateMany?: Enumerable<hace_usoUpdateManyWithWhereWithoutPersonaInput>
    deleteMany?: Enumerable<hace_usoScalarWhereInput>
  }

  export type empleadoUncheckedUpdateOneWithoutPersonaInput = {
    create?: XOR<empleadoCreateWithoutPersonaInput, empleadoUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutPersonaInput
    upsert?: empleadoUpsertWithoutPersonaInput
    disconnect?: boolean
    delete?: boolean
    connect?: empleadoWhereUniqueInput
    update?: XOR<empleadoUpdateWithoutPersonaInput, empleadoUncheckedUpdateWithoutPersonaInput>
  }

  export type empleadorUncheckedUpdateOneWithoutPersonaInput = {
    create?: XOR<empleadorCreateWithoutPersonaInput, empleadorUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: empleadorCreateOrConnectWithoutPersonaInput
    upsert?: empleadorUpsertWithoutPersonaInput
    disconnect?: boolean
    delete?: boolean
    connect?: empleadorWhereUniqueInput
    update?: XOR<empleadorUpdateWithoutPersonaInput, empleadorUncheckedUpdateWithoutPersonaInput>
  }

  export type hace_usoUncheckedUpdateManyWithoutPersonaInput = {
    create?: XOR<Enumerable<hace_usoCreateWithoutPersonaInput>, Enumerable<hace_usoUncheckedCreateWithoutPersonaInput>>
    connectOrCreate?: Enumerable<hace_usoCreateOrConnectWithoutPersonaInput>
    upsert?: Enumerable<hace_usoUpsertWithWhereUniqueWithoutPersonaInput>
    createMany?: hace_usoCreateManyPersonaInputEnvelope
    set?: Enumerable<hace_usoWhereUniqueInput>
    disconnect?: Enumerable<hace_usoWhereUniqueInput>
    delete?: Enumerable<hace_usoWhereUniqueInput>
    connect?: Enumerable<hace_usoWhereUniqueInput>
    update?: Enumerable<hace_usoUpdateWithWhereUniqueWithoutPersonaInput>
    updateMany?: Enumerable<hace_usoUpdateManyWithWhereWithoutPersonaInput>
    deleteMany?: Enumerable<hace_usoScalarWhereInput>
  }

  export type empresaCreateNestedOneWithoutProyectoInput = {
    create?: XOR<empresaCreateWithoutProyectoInput, empresaUncheckedCreateWithoutProyectoInput>
    connectOrCreate?: empresaCreateOrConnectWithoutProyectoInput
    connect?: empresaWhereUniqueInput
  }

  export type beneficiosCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<beneficiosCreateWithoutProyectoInput>, Enumerable<beneficiosUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<beneficiosCreateOrConnectWithoutProyectoInput>
    createMany?: beneficiosCreateManyProyectoInputEnvelope
    connect?: Enumerable<beneficiosWhereUniqueInput>
  }

  export type deduccionVoluntariaCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<deduccionVoluntariaCreateWithoutProyectoInput>, Enumerable<deduccionVoluntariaUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<deduccionVoluntariaCreateOrConnectWithoutProyectoInput>
    createMany?: deduccionVoluntariaCreateManyProyectoInputEnvelope
    connect?: Enumerable<deduccionVoluntariaWhereUniqueInput>
  }

  export type esContratadoCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<esContratadoCreateWithoutProyectoInput>, Enumerable<esContratadoUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<esContratadoCreateOrConnectWithoutProyectoInput>
    createMany?: esContratadoCreateManyProyectoInputEnvelope
    connect?: Enumerable<esContratadoWhereUniqueInput>
  }

  export type generaCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<generaCreateWithoutProyectoInput>, Enumerable<generaUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<generaCreateOrConnectWithoutProyectoInput>
    createMany?: generaCreateManyProyectoInputEnvelope
    connect?: Enumerable<generaWhereUniqueInput>
  }

  export type reporteHorasCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutProyectoInput>, Enumerable<reporteHorasUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutProyectoInput>
    createMany?: reporteHorasCreateManyProyectoInputEnvelope
    connect?: Enumerable<reporteHorasWhereUniqueInput>
  }

  export type beneficiosUncheckedCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<beneficiosCreateWithoutProyectoInput>, Enumerable<beneficiosUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<beneficiosCreateOrConnectWithoutProyectoInput>
    createMany?: beneficiosCreateManyProyectoInputEnvelope
    connect?: Enumerable<beneficiosWhereUniqueInput>
  }

  export type deduccionVoluntariaUncheckedCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<deduccionVoluntariaCreateWithoutProyectoInput>, Enumerable<deduccionVoluntariaUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<deduccionVoluntariaCreateOrConnectWithoutProyectoInput>
    createMany?: deduccionVoluntariaCreateManyProyectoInputEnvelope
    connect?: Enumerable<deduccionVoluntariaWhereUniqueInput>
  }

  export type esContratadoUncheckedCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<esContratadoCreateWithoutProyectoInput>, Enumerable<esContratadoUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<esContratadoCreateOrConnectWithoutProyectoInput>
    createMany?: esContratadoCreateManyProyectoInputEnvelope
    connect?: Enumerable<esContratadoWhereUniqueInput>
  }

  export type generaUncheckedCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<generaCreateWithoutProyectoInput>, Enumerable<generaUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<generaCreateOrConnectWithoutProyectoInput>
    createMany?: generaCreateManyProyectoInputEnvelope
    connect?: Enumerable<generaWhereUniqueInput>
  }

  export type reporteHorasUncheckedCreateNestedManyWithoutProyectoInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutProyectoInput>, Enumerable<reporteHorasUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutProyectoInput>
    createMany?: reporteHorasCreateManyProyectoInputEnvelope
    connect?: Enumerable<reporteHorasWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type empresaUpdateOneRequiredWithoutProyectoInput = {
    create?: XOR<empresaCreateWithoutProyectoInput, empresaUncheckedCreateWithoutProyectoInput>
    connectOrCreate?: empresaCreateOrConnectWithoutProyectoInput
    upsert?: empresaUpsertWithoutProyectoInput
    connect?: empresaWhereUniqueInput
    update?: XOR<empresaUpdateWithoutProyectoInput, empresaUncheckedUpdateWithoutProyectoInput>
  }

  export type beneficiosUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<beneficiosCreateWithoutProyectoInput>, Enumerable<beneficiosUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<beneficiosCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<beneficiosUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: beneficiosCreateManyProyectoInputEnvelope
    set?: Enumerable<beneficiosWhereUniqueInput>
    disconnect?: Enumerable<beneficiosWhereUniqueInput>
    delete?: Enumerable<beneficiosWhereUniqueInput>
    connect?: Enumerable<beneficiosWhereUniqueInput>
    update?: Enumerable<beneficiosUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<beneficiosUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<beneficiosScalarWhereInput>
  }

  export type deduccionVoluntariaUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<deduccionVoluntariaCreateWithoutProyectoInput>, Enumerable<deduccionVoluntariaUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<deduccionVoluntariaCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<deduccionVoluntariaUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: deduccionVoluntariaCreateManyProyectoInputEnvelope
    set?: Enumerable<deduccionVoluntariaWhereUniqueInput>
    disconnect?: Enumerable<deduccionVoluntariaWhereUniqueInput>
    delete?: Enumerable<deduccionVoluntariaWhereUniqueInput>
    connect?: Enumerable<deduccionVoluntariaWhereUniqueInput>
    update?: Enumerable<deduccionVoluntariaUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<deduccionVoluntariaUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<deduccionVoluntariaScalarWhereInput>
  }

  export type esContratadoUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<esContratadoCreateWithoutProyectoInput>, Enumerable<esContratadoUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<esContratadoCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<esContratadoUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: esContratadoCreateManyProyectoInputEnvelope
    set?: Enumerable<esContratadoWhereUniqueInput>
    disconnect?: Enumerable<esContratadoWhereUniqueInput>
    delete?: Enumerable<esContratadoWhereUniqueInput>
    connect?: Enumerable<esContratadoWhereUniqueInput>
    update?: Enumerable<esContratadoUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<esContratadoUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<esContratadoScalarWhereInput>
  }

  export type generaUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<generaCreateWithoutProyectoInput>, Enumerable<generaUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<generaCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<generaUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: generaCreateManyProyectoInputEnvelope
    set?: Enumerable<generaWhereUniqueInput>
    disconnect?: Enumerable<generaWhereUniqueInput>
    delete?: Enumerable<generaWhereUniqueInput>
    connect?: Enumerable<generaWhereUniqueInput>
    update?: Enumerable<generaUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<generaUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<generaScalarWhereInput>
  }

  export type reporteHorasUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutProyectoInput>, Enumerable<reporteHorasUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<reporteHorasUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: reporteHorasCreateManyProyectoInputEnvelope
    set?: Enumerable<reporteHorasWhereUniqueInput>
    disconnect?: Enumerable<reporteHorasWhereUniqueInput>
    delete?: Enumerable<reporteHorasWhereUniqueInput>
    connect?: Enumerable<reporteHorasWhereUniqueInput>
    update?: Enumerable<reporteHorasUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<reporteHorasUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<reporteHorasScalarWhereInput>
  }

  export type beneficiosUncheckedUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<beneficiosCreateWithoutProyectoInput>, Enumerable<beneficiosUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<beneficiosCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<beneficiosUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: beneficiosCreateManyProyectoInputEnvelope
    set?: Enumerable<beneficiosWhereUniqueInput>
    disconnect?: Enumerable<beneficiosWhereUniqueInput>
    delete?: Enumerable<beneficiosWhereUniqueInput>
    connect?: Enumerable<beneficiosWhereUniqueInput>
    update?: Enumerable<beneficiosUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<beneficiosUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<beneficiosScalarWhereInput>
  }

  export type deduccionVoluntariaUncheckedUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<deduccionVoluntariaCreateWithoutProyectoInput>, Enumerable<deduccionVoluntariaUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<deduccionVoluntariaCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<deduccionVoluntariaUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: deduccionVoluntariaCreateManyProyectoInputEnvelope
    set?: Enumerable<deduccionVoluntariaWhereUniqueInput>
    disconnect?: Enumerable<deduccionVoluntariaWhereUniqueInput>
    delete?: Enumerable<deduccionVoluntariaWhereUniqueInput>
    connect?: Enumerable<deduccionVoluntariaWhereUniqueInput>
    update?: Enumerable<deduccionVoluntariaUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<deduccionVoluntariaUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<deduccionVoluntariaScalarWhereInput>
  }

  export type esContratadoUncheckedUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<esContratadoCreateWithoutProyectoInput>, Enumerable<esContratadoUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<esContratadoCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<esContratadoUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: esContratadoCreateManyProyectoInputEnvelope
    set?: Enumerable<esContratadoWhereUniqueInput>
    disconnect?: Enumerable<esContratadoWhereUniqueInput>
    delete?: Enumerable<esContratadoWhereUniqueInput>
    connect?: Enumerable<esContratadoWhereUniqueInput>
    update?: Enumerable<esContratadoUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<esContratadoUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<esContratadoScalarWhereInput>
  }

  export type generaUncheckedUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<generaCreateWithoutProyectoInput>, Enumerable<generaUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<generaCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<generaUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: generaCreateManyProyectoInputEnvelope
    set?: Enumerable<generaWhereUniqueInput>
    disconnect?: Enumerable<generaWhereUniqueInput>
    delete?: Enumerable<generaWhereUniqueInput>
    connect?: Enumerable<generaWhereUniqueInput>
    update?: Enumerable<generaUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<generaUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<generaScalarWhereInput>
  }

  export type reporteHorasUncheckedUpdateManyWithoutProyectoInput = {
    create?: XOR<Enumerable<reporteHorasCreateWithoutProyectoInput>, Enumerable<reporteHorasUncheckedCreateWithoutProyectoInput>>
    connectOrCreate?: Enumerable<reporteHorasCreateOrConnectWithoutProyectoInput>
    upsert?: Enumerable<reporteHorasUpsertWithWhereUniqueWithoutProyectoInput>
    createMany?: reporteHorasCreateManyProyectoInputEnvelope
    set?: Enumerable<reporteHorasWhereUniqueInput>
    disconnect?: Enumerable<reporteHorasWhereUniqueInput>
    delete?: Enumerable<reporteHorasWhereUniqueInput>
    connect?: Enumerable<reporteHorasWhereUniqueInput>
    update?: Enumerable<reporteHorasUpdateWithWhereUniqueWithoutProyectoInput>
    updateMany?: Enumerable<reporteHorasUpdateManyWithWhereWithoutProyectoInput>
    deleteMany?: Enumerable<reporteHorasScalarWhereInput>
  }

  export type empleadoCreateNestedOneWithoutReporteHorasInput = {
    create?: XOR<empleadoCreateWithoutReporteHorasInput, empleadoUncheckedCreateWithoutReporteHorasInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutReporteHorasInput
    connect?: empleadoWhereUniqueInput
  }

  export type empleadorCreateNestedOneWithoutReporteHorasInput = {
    create?: XOR<empleadorCreateWithoutReporteHorasInput, empleadorUncheckedCreateWithoutReporteHorasInput>
    connectOrCreate?: empleadorCreateOrConnectWithoutReporteHorasInput
    connect?: empleadorWhereUniqueInput
  }

  export type proyectoCreateNestedOneWithoutReporteHorasInput = {
    create?: XOR<proyectoCreateWithoutReporteHorasInput, proyectoUncheckedCreateWithoutReporteHorasInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutReporteHorasInput
    connect?: proyectoWhereUniqueInput
  }

  export type empleadoUpdateOneRequiredWithoutReporteHorasInput = {
    create?: XOR<empleadoCreateWithoutReporteHorasInput, empleadoUncheckedCreateWithoutReporteHorasInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutReporteHorasInput
    upsert?: empleadoUpsertWithoutReporteHorasInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<empleadoUpdateWithoutReporteHorasInput, empleadoUncheckedUpdateWithoutReporteHorasInput>
  }

  export type empleadorUpdateOneWithoutReporteHorasInput = {
    create?: XOR<empleadorCreateWithoutReporteHorasInput, empleadorUncheckedCreateWithoutReporteHorasInput>
    connectOrCreate?: empleadorCreateOrConnectWithoutReporteHorasInput
    upsert?: empleadorUpsertWithoutReporteHorasInput
    disconnect?: boolean
    delete?: boolean
    connect?: empleadorWhereUniqueInput
    update?: XOR<empleadorUpdateWithoutReporteHorasInput, empleadorUncheckedUpdateWithoutReporteHorasInput>
  }

  export type proyectoUpdateOneWithoutReporteHorasInput = {
    create?: XOR<proyectoCreateWithoutReporteHorasInput, proyectoUncheckedCreateWithoutReporteHorasInput>
    connectOrCreate?: proyectoCreateOrConnectWithoutReporteHorasInput
    upsert?: proyectoUpsertWithoutReporteHorasInput
    disconnect?: boolean
    delete?: boolean
    connect?: proyectoWhereUniqueInput
    update?: XOR<proyectoUpdateWithoutReporteHorasInput, proyectoUncheckedUpdateWithoutReporteHorasInput>
  }

  export type empleadoCreateNestedOneWithoutSeleccionaInput = {
    create?: XOR<empleadoCreateWithoutSeleccionaInput, empleadoUncheckedCreateWithoutSeleccionaInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutSeleccionaInput
    connect?: empleadoWhereUniqueInput
  }

  export type beneficiosCreateNestedOneWithoutSeleccionaInput = {
    create?: XOR<beneficiosCreateWithoutSeleccionaInput, beneficiosUncheckedCreateWithoutSeleccionaInput>
    connectOrCreate?: beneficiosCreateOrConnectWithoutSeleccionaInput
    connect?: beneficiosWhereUniqueInput
  }

  export type empleadoUpdateOneRequiredWithoutSeleccionaInput = {
    create?: XOR<empleadoCreateWithoutSeleccionaInput, empleadoUncheckedCreateWithoutSeleccionaInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutSeleccionaInput
    upsert?: empleadoUpsertWithoutSeleccionaInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<empleadoUpdateWithoutSeleccionaInput, empleadoUncheckedUpdateWithoutSeleccionaInput>
  }

  export type beneficiosUpdateOneRequiredWithoutSeleccionaInput = {
    create?: XOR<beneficiosCreateWithoutSeleccionaInput, beneficiosUncheckedCreateWithoutSeleccionaInput>
    connectOrCreate?: beneficiosCreateOrConnectWithoutSeleccionaInput
    upsert?: beneficiosUpsertWithoutSeleccionaInput
    connect?: beneficiosWhereUniqueInput
    update?: XOR<beneficiosUpdateWithoutSeleccionaInput, beneficiosUncheckedUpdateWithoutSeleccionaInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type pagoCreateWithoutAplica_bInput = {
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    empleado: empleadoCreateNestedOneWithoutPagoInput
    aplica_do?: aplica_doCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvCreateNestedManyWithoutPagoInput
    genera?: generaCreateNestedManyWithoutPagoInput
  }

  export type pagoUncheckedCreateWithoutAplica_bInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    aplica_do?: aplica_doUncheckedCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedCreateNestedManyWithoutPagoInput
    genera?: generaUncheckedCreateNestedManyWithoutPagoInput
  }

  export type pagoCreateOrConnectWithoutAplica_bInput = {
    where: pagoWhereUniqueInput
    create: XOR<pagoCreateWithoutAplica_bInput, pagoUncheckedCreateWithoutAplica_bInput>
  }

  export type beneficiosCreateWithoutAplica_bInput = {
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
    proyecto: proyectoCreateNestedOneWithoutBeneficiosInput
    selecciona?: seleccionaCreateNestedManyWithoutBeneficiosInput
  }

  export type beneficiosUncheckedCreateWithoutAplica_bInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutBeneficiosInput
  }

  export type beneficiosCreateOrConnectWithoutAplica_bInput = {
    where: beneficiosWhereUniqueInput
    create: XOR<beneficiosCreateWithoutAplica_bInput, beneficiosUncheckedCreateWithoutAplica_bInput>
  }

  export type pagoUpsertWithoutAplica_bInput = {
    update: XOR<pagoUpdateWithoutAplica_bInput, pagoUncheckedUpdateWithoutAplica_bInput>
    create: XOR<pagoCreateWithoutAplica_bInput, pagoUncheckedCreateWithoutAplica_bInput>
  }

  export type pagoUpdateWithoutAplica_bInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateOneRequiredWithoutPagoInput
    aplica_do?: aplica_doUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUpdateManyWithoutPagoInput
    genera?: generaUpdateManyWithoutPagoInput
  }

  export type pagoUncheckedUpdateWithoutAplica_bInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    aplica_do?: aplica_doUncheckedUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedUpdateManyWithoutPagoInput
    genera?: generaUncheckedUpdateManyWithoutPagoInput
  }

  export type beneficiosUpsertWithoutAplica_bInput = {
    update: XOR<beneficiosUpdateWithoutAplica_bInput, beneficiosUncheckedUpdateWithoutAplica_bInput>
    create: XOR<beneficiosCreateWithoutAplica_bInput, beneficiosUncheckedCreateWithoutAplica_bInput>
  }

  export type beneficiosUpdateWithoutAplica_bInput = {
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    proyecto?: proyectoUpdateOneRequiredWithoutBeneficiosInput
    selecciona?: seleccionaUpdateManyWithoutBeneficiosInput
  }

  export type beneficiosUncheckedUpdateWithoutAplica_bInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selecciona?: seleccionaUncheckedUpdateManyWithoutBeneficiosInput
  }

  export type pagoCreateWithoutAplica_doInput = {
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    empleado: empleadoCreateNestedOneWithoutPagoInput
    aplica_b?: aplica_bCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvCreateNestedManyWithoutPagoInput
    genera?: generaCreateNestedManyWithoutPagoInput
  }

  export type pagoUncheckedCreateWithoutAplica_doInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    aplica_b?: aplica_bUncheckedCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedCreateNestedManyWithoutPagoInput
    genera?: generaUncheckedCreateNestedManyWithoutPagoInput
  }

  export type pagoCreateOrConnectWithoutAplica_doInput = {
    where: pagoWhereUniqueInput
    create: XOR<pagoCreateWithoutAplica_doInput, pagoUncheckedCreateWithoutAplica_doInput>
  }

  export type deduccionObligatoriaCreateWithoutAplica_doInput = {
    nombre: string
    porcentaje?: number | null
  }

  export type deduccionObligatoriaUncheckedCreateWithoutAplica_doInput = {
    nombre: string
    porcentaje?: number | null
  }

  export type deduccionObligatoriaCreateOrConnectWithoutAplica_doInput = {
    where: deduccionObligatoriaWhereUniqueInput
    create: XOR<deduccionObligatoriaCreateWithoutAplica_doInput, deduccionObligatoriaUncheckedCreateWithoutAplica_doInput>
  }

  export type pagoUpsertWithoutAplica_doInput = {
    update: XOR<pagoUpdateWithoutAplica_doInput, pagoUncheckedUpdateWithoutAplica_doInput>
    create: XOR<pagoCreateWithoutAplica_doInput, pagoUncheckedCreateWithoutAplica_doInput>
  }

  export type pagoUpdateWithoutAplica_doInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateOneRequiredWithoutPagoInput
    aplica_b?: aplica_bUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUpdateManyWithoutPagoInput
    genera?: generaUpdateManyWithoutPagoInput
  }

  export type pagoUncheckedUpdateWithoutAplica_doInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    aplica_b?: aplica_bUncheckedUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedUpdateManyWithoutPagoInput
    genera?: generaUncheckedUpdateManyWithoutPagoInput
  }

  export type deduccionObligatoriaUpsertWithoutAplica_doInput = {
    update: XOR<deduccionObligatoriaUpdateWithoutAplica_doInput, deduccionObligatoriaUncheckedUpdateWithoutAplica_doInput>
    create: XOR<deduccionObligatoriaCreateWithoutAplica_doInput, deduccionObligatoriaUncheckedCreateWithoutAplica_doInput>
  }

  export type deduccionObligatoriaUpdateWithoutAplica_doInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deduccionObligatoriaUncheckedUpdateWithoutAplica_doInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    porcentaje?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type pagoCreateWithoutAplica_dvInput = {
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    empleado: empleadoCreateNestedOneWithoutPagoInput
    aplica_b?: aplica_bCreateNestedManyWithoutPagoInput
    aplica_do?: aplica_doCreateNestedManyWithoutPagoInput
    genera?: generaCreateNestedManyWithoutPagoInput
  }

  export type pagoUncheckedCreateWithoutAplica_dvInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    aplica_b?: aplica_bUncheckedCreateNestedManyWithoutPagoInput
    aplica_do?: aplica_doUncheckedCreateNestedManyWithoutPagoInput
    genera?: generaUncheckedCreateNestedManyWithoutPagoInput
  }

  export type pagoCreateOrConnectWithoutAplica_dvInput = {
    where: pagoWhereUniqueInput
    create: XOR<pagoCreateWithoutAplica_dvInput, pagoUncheckedCreateWithoutAplica_dvInput>
  }

  export type deduccionVoluntariaCreateWithoutAplica_dvInput = {
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
    proyecto: proyectoCreateNestedOneWithoutDeduccionVoluntariaInput
    escoge?: escogeCreateNestedManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUncheckedCreateWithoutAplica_dvInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
    escoge?: escogeUncheckedCreateNestedManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaCreateOrConnectWithoutAplica_dvInput = {
    where: deduccionVoluntariaWhereUniqueInput
    create: XOR<deduccionVoluntariaCreateWithoutAplica_dvInput, deduccionVoluntariaUncheckedCreateWithoutAplica_dvInput>
  }

  export type pagoUpsertWithoutAplica_dvInput = {
    update: XOR<pagoUpdateWithoutAplica_dvInput, pagoUncheckedUpdateWithoutAplica_dvInput>
    create: XOR<pagoCreateWithoutAplica_dvInput, pagoUncheckedCreateWithoutAplica_dvInput>
  }

  export type pagoUpdateWithoutAplica_dvInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateOneRequiredWithoutPagoInput
    aplica_b?: aplica_bUpdateManyWithoutPagoInput
    aplica_do?: aplica_doUpdateManyWithoutPagoInput
    genera?: generaUpdateManyWithoutPagoInput
  }

  export type pagoUncheckedUpdateWithoutAplica_dvInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    aplica_b?: aplica_bUncheckedUpdateManyWithoutPagoInput
    aplica_do?: aplica_doUncheckedUpdateManyWithoutPagoInput
    genera?: generaUncheckedUpdateManyWithoutPagoInput
  }

  export type deduccionVoluntariaUpsertWithoutAplica_dvInput = {
    update: XOR<deduccionVoluntariaUpdateWithoutAplica_dvInput, deduccionVoluntariaUncheckedUpdateWithoutAplica_dvInput>
    create: XOR<deduccionVoluntariaCreateWithoutAplica_dvInput, deduccionVoluntariaUncheckedCreateWithoutAplica_dvInput>
  }

  export type deduccionVoluntariaUpdateWithoutAplica_dvInput = {
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    proyecto?: proyectoUpdateOneRequiredWithoutDeduccionVoluntariaInput
    escoge?: escogeUpdateManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUncheckedUpdateWithoutAplica_dvInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    escoge?: escogeUncheckedUpdateManyWithoutDeduccionVoluntariaInput
  }

  export type proyectoCreateWithoutBeneficiosInput = {
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    empresa: empresaCreateNestedOneWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoCreateNestedManyWithoutProyectoInput
    genera?: generaCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutProyectoInput
  }

  export type proyectoUncheckedCreateWithoutBeneficiosInput = {
    cedulaJuridica: string
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    deduccionVoluntaria?: deduccionVoluntariaUncheckedCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutProyectoInput
    genera?: generaUncheckedCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type proyectoCreateOrConnectWithoutBeneficiosInput = {
    where: proyectoWhereUniqueInput
    create: XOR<proyectoCreateWithoutBeneficiosInput, proyectoUncheckedCreateWithoutBeneficiosInput>
  }

  export type aplica_bCreateWithoutBeneficiosInput = {
    pago: pagoCreateNestedOneWithoutAplica_bInput
  }

  export type aplica_bUncheckedCreateWithoutBeneficiosInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type aplica_bCreateOrConnectWithoutBeneficiosInput = {
    where: aplica_bWhereUniqueInput
    create: XOR<aplica_bCreateWithoutBeneficiosInput, aplica_bUncheckedCreateWithoutBeneficiosInput>
  }

  export type aplica_bCreateManyBeneficiosInputEnvelope = {
    data: Enumerable<aplica_bCreateManyBeneficiosInput>
  }

  export type seleccionaCreateWithoutBeneficiosInput = {
    empleado: empleadoCreateNestedOneWithoutSeleccionaInput
  }

  export type seleccionaUncheckedCreateWithoutBeneficiosInput = {
    cedulaEmpleado: string
  }

  export type seleccionaCreateOrConnectWithoutBeneficiosInput = {
    where: seleccionaWhereUniqueInput
    create: XOR<seleccionaCreateWithoutBeneficiosInput, seleccionaUncheckedCreateWithoutBeneficiosInput>
  }

  export type seleccionaCreateManyBeneficiosInputEnvelope = {
    data: Enumerable<seleccionaCreateManyBeneficiosInput>
  }

  export type proyectoUpsertWithoutBeneficiosInput = {
    update: XOR<proyectoUpdateWithoutBeneficiosInput, proyectoUncheckedUpdateWithoutBeneficiosInput>
    create: XOR<proyectoCreateWithoutBeneficiosInput, proyectoUncheckedCreateWithoutBeneficiosInput>
  }

  export type proyectoUpdateWithoutBeneficiosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: empresaUpdateOneRequiredWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUpdateManyWithoutProyectoInput
    genera?: generaUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUpdateManyWithoutProyectoInput
  }

  export type proyectoUncheckedUpdateWithoutBeneficiosInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deduccionVoluntaria?: deduccionVoluntariaUncheckedUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutProyectoInput
    genera?: generaUncheckedUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutProyectoInput
  }

  export type aplica_bUpsertWithWhereUniqueWithoutBeneficiosInput = {
    where: aplica_bWhereUniqueInput
    update: XOR<aplica_bUpdateWithoutBeneficiosInput, aplica_bUncheckedUpdateWithoutBeneficiosInput>
    create: XOR<aplica_bCreateWithoutBeneficiosInput, aplica_bUncheckedCreateWithoutBeneficiosInput>
  }

  export type aplica_bUpdateWithWhereUniqueWithoutBeneficiosInput = {
    where: aplica_bWhereUniqueInput
    data: XOR<aplica_bUpdateWithoutBeneficiosInput, aplica_bUncheckedUpdateWithoutBeneficiosInput>
  }

  export type aplica_bUpdateManyWithWhereWithoutBeneficiosInput = {
    where: aplica_bScalarWhereInput
    data: XOR<aplica_bUpdateManyMutationInput, aplica_bUncheckedUpdateManyWithoutAplica_bInput>
  }

  export type aplica_bScalarWhereInput = {
    AND?: Enumerable<aplica_bScalarWhereInput>
    OR?: Enumerable<aplica_bScalarWhereInput>
    NOT?: Enumerable<aplica_bScalarWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreBeneficio?: StringFilter | string
  }

  export type seleccionaUpsertWithWhereUniqueWithoutBeneficiosInput = {
    where: seleccionaWhereUniqueInput
    update: XOR<seleccionaUpdateWithoutBeneficiosInput, seleccionaUncheckedUpdateWithoutBeneficiosInput>
    create: XOR<seleccionaCreateWithoutBeneficiosInput, seleccionaUncheckedCreateWithoutBeneficiosInput>
  }

  export type seleccionaUpdateWithWhereUniqueWithoutBeneficiosInput = {
    where: seleccionaWhereUniqueInput
    data: XOR<seleccionaUpdateWithoutBeneficiosInput, seleccionaUncheckedUpdateWithoutBeneficiosInput>
  }

  export type seleccionaUpdateManyWithWhereWithoutBeneficiosInput = {
    where: seleccionaScalarWhereInput
    data: XOR<seleccionaUpdateManyMutationInput, seleccionaUncheckedUpdateManyWithoutSeleccionaInput>
  }

  export type seleccionaScalarWhereInput = {
    AND?: Enumerable<seleccionaScalarWhereInput>
    OR?: Enumerable<seleccionaScalarWhereInput>
    NOT?: Enumerable<seleccionaScalarWhereInput>
    cedulaEmpleado?: StringFilter | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreBeneficio?: StringFilter | string
  }

  export type hace_usoCreateWithoutCredencialesInput = {
    persona: personaCreateNestedOneWithoutHace_usoInput
  }

  export type hace_usoUncheckedCreateWithoutCredencialesInput = {
    cedula: string
  }

  export type hace_usoCreateOrConnectWithoutCredencialesInput = {
    where: hace_usoWhereUniqueInput
    create: XOR<hace_usoCreateWithoutCredencialesInput, hace_usoUncheckedCreateWithoutCredencialesInput>
  }

  export type hace_usoCreateManyCredencialesInputEnvelope = {
    data: Enumerable<hace_usoCreateManyCredencialesInput>
  }

  export type hace_usoUpsertWithWhereUniqueWithoutCredencialesInput = {
    where: hace_usoWhereUniqueInput
    update: XOR<hace_usoUpdateWithoutCredencialesInput, hace_usoUncheckedUpdateWithoutCredencialesInput>
    create: XOR<hace_usoCreateWithoutCredencialesInput, hace_usoUncheckedCreateWithoutCredencialesInput>
  }

  export type hace_usoUpdateWithWhereUniqueWithoutCredencialesInput = {
    where: hace_usoWhereUniqueInput
    data: XOR<hace_usoUpdateWithoutCredencialesInput, hace_usoUncheckedUpdateWithoutCredencialesInput>
  }

  export type hace_usoUpdateManyWithWhereWithoutCredencialesInput = {
    where: hace_usoScalarWhereInput
    data: XOR<hace_usoUpdateManyMutationInput, hace_usoUncheckedUpdateManyWithoutHace_usoInput>
  }

  export type hace_usoScalarWhereInput = {
    AND?: Enumerable<hace_usoScalarWhereInput>
    OR?: Enumerable<hace_usoScalarWhereInput>
    NOT?: Enumerable<hace_usoScalarWhereInput>
    cedula?: StringFilter | string
    email?: StringFilter | string
  }

  export type aplica_doCreateWithoutDeduccionObligatoriaInput = {
    pago: pagoCreateNestedOneWithoutAplica_doInput
  }

  export type aplica_doUncheckedCreateWithoutDeduccionObligatoriaInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type aplica_doCreateOrConnectWithoutDeduccionObligatoriaInput = {
    where: aplica_doWhereUniqueInput
    create: XOR<aplica_doCreateWithoutDeduccionObligatoriaInput, aplica_doUncheckedCreateWithoutDeduccionObligatoriaInput>
  }

  export type aplica_doCreateManyDeduccionObligatoriaInputEnvelope = {
    data: Enumerable<aplica_doCreateManyDeduccionObligatoriaInput>
  }

  export type aplica_doUpsertWithWhereUniqueWithoutDeduccionObligatoriaInput = {
    where: aplica_doWhereUniqueInput
    update: XOR<aplica_doUpdateWithoutDeduccionObligatoriaInput, aplica_doUncheckedUpdateWithoutDeduccionObligatoriaInput>
    create: XOR<aplica_doCreateWithoutDeduccionObligatoriaInput, aplica_doUncheckedCreateWithoutDeduccionObligatoriaInput>
  }

  export type aplica_doUpdateWithWhereUniqueWithoutDeduccionObligatoriaInput = {
    where: aplica_doWhereUniqueInput
    data: XOR<aplica_doUpdateWithoutDeduccionObligatoriaInput, aplica_doUncheckedUpdateWithoutDeduccionObligatoriaInput>
  }

  export type aplica_doUpdateManyWithWhereWithoutDeduccionObligatoriaInput = {
    where: aplica_doScalarWhereInput
    data: XOR<aplica_doUpdateManyMutationInput, aplica_doUncheckedUpdateManyWithoutAplica_doInput>
  }

  export type aplica_doScalarWhereInput = {
    AND?: Enumerable<aplica_doScalarWhereInput>
    OR?: Enumerable<aplica_doScalarWhereInput>
    NOT?: Enumerable<aplica_doScalarWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    nombreDO?: StringFilter | string
  }

  export type proyectoCreateWithoutDeduccionVoluntariaInput = {
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    empresa: empresaCreateNestedOneWithoutProyectoInput
    beneficios?: beneficiosCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoCreateNestedManyWithoutProyectoInput
    genera?: generaCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutProyectoInput
  }

  export type proyectoUncheckedCreateWithoutDeduccionVoluntariaInput = {
    cedulaJuridica: string
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    beneficios?: beneficiosUncheckedCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutProyectoInput
    genera?: generaUncheckedCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type proyectoCreateOrConnectWithoutDeduccionVoluntariaInput = {
    where: proyectoWhereUniqueInput
    create: XOR<proyectoCreateWithoutDeduccionVoluntariaInput, proyectoUncheckedCreateWithoutDeduccionVoluntariaInput>
  }

  export type aplica_dvCreateWithoutDeduccionVoluntariaInput = {
    pago: pagoCreateNestedOneWithoutAplica_dvInput
  }

  export type aplica_dvUncheckedCreateWithoutDeduccionVoluntariaInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type aplica_dvCreateOrConnectWithoutDeduccionVoluntariaInput = {
    where: aplica_dvWhereUniqueInput
    create: XOR<aplica_dvCreateWithoutDeduccionVoluntariaInput, aplica_dvUncheckedCreateWithoutDeduccionVoluntariaInput>
  }

  export type aplica_dvCreateManyDeduccionVoluntariaInputEnvelope = {
    data: Enumerable<aplica_dvCreateManyDeduccionVoluntariaInput>
  }

  export type escogeCreateWithoutDeduccionVoluntariaInput = {
    aporte?: number | null
    empleado: empleadoCreateNestedOneWithoutEscogeInput
  }

  export type escogeUncheckedCreateWithoutDeduccionVoluntariaInput = {
    cedulaEmpleado: string
    aporte?: number | null
  }

  export type escogeCreateOrConnectWithoutDeduccionVoluntariaInput = {
    where: escogeWhereUniqueInput
    create: XOR<escogeCreateWithoutDeduccionVoluntariaInput, escogeUncheckedCreateWithoutDeduccionVoluntariaInput>
  }

  export type escogeCreateManyDeduccionVoluntariaInputEnvelope = {
    data: Enumerable<escogeCreateManyDeduccionVoluntariaInput>
  }

  export type proyectoUpsertWithoutDeduccionVoluntariaInput = {
    update: XOR<proyectoUpdateWithoutDeduccionVoluntariaInput, proyectoUncheckedUpdateWithoutDeduccionVoluntariaInput>
    create: XOR<proyectoCreateWithoutDeduccionVoluntariaInput, proyectoUncheckedCreateWithoutDeduccionVoluntariaInput>
  }

  export type proyectoUpdateWithoutDeduccionVoluntariaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: empresaUpdateOneRequiredWithoutProyectoInput
    beneficios?: beneficiosUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUpdateManyWithoutProyectoInput
    genera?: generaUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUpdateManyWithoutProyectoInput
  }

  export type proyectoUncheckedUpdateWithoutDeduccionVoluntariaInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficios?: beneficiosUncheckedUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutProyectoInput
    genera?: generaUncheckedUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutProyectoInput
  }

  export type aplica_dvUpsertWithWhereUniqueWithoutDeduccionVoluntariaInput = {
    where: aplica_dvWhereUniqueInput
    update: XOR<aplica_dvUpdateWithoutDeduccionVoluntariaInput, aplica_dvUncheckedUpdateWithoutDeduccionVoluntariaInput>
    create: XOR<aplica_dvCreateWithoutDeduccionVoluntariaInput, aplica_dvUncheckedCreateWithoutDeduccionVoluntariaInput>
  }

  export type aplica_dvUpdateWithWhereUniqueWithoutDeduccionVoluntariaInput = {
    where: aplica_dvWhereUniqueInput
    data: XOR<aplica_dvUpdateWithoutDeduccionVoluntariaInput, aplica_dvUncheckedUpdateWithoutDeduccionVoluntariaInput>
  }

  export type aplica_dvUpdateManyWithWhereWithoutDeduccionVoluntariaInput = {
    where: aplica_dvScalarWhereInput
    data: XOR<aplica_dvUpdateManyMutationInput, aplica_dvUncheckedUpdateManyWithoutAplica_dvInput>
  }

  export type aplica_dvScalarWhereInput = {
    AND?: Enumerable<aplica_dvScalarWhereInput>
    OR?: Enumerable<aplica_dvScalarWhereInput>
    NOT?: Enumerable<aplica_dvScalarWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreDeduccion?: StringFilter | string
  }

  export type escogeUpsertWithWhereUniqueWithoutDeduccionVoluntariaInput = {
    where: escogeWhereUniqueInput
    update: XOR<escogeUpdateWithoutDeduccionVoluntariaInput, escogeUncheckedUpdateWithoutDeduccionVoluntariaInput>
    create: XOR<escogeCreateWithoutDeduccionVoluntariaInput, escogeUncheckedCreateWithoutDeduccionVoluntariaInput>
  }

  export type escogeUpdateWithWhereUniqueWithoutDeduccionVoluntariaInput = {
    where: escogeWhereUniqueInput
    data: XOR<escogeUpdateWithoutDeduccionVoluntariaInput, escogeUncheckedUpdateWithoutDeduccionVoluntariaInput>
  }

  export type escogeUpdateManyWithWhereWithoutDeduccionVoluntariaInput = {
    where: escogeScalarWhereInput
    data: XOR<escogeUpdateManyMutationInput, escogeUncheckedUpdateManyWithoutEscogeInput>
  }

  export type escogeScalarWhereInput = {
    AND?: Enumerable<escogeScalarWhereInput>
    OR?: Enumerable<escogeScalarWhereInput>
    NOT?: Enumerable<escogeScalarWhereInput>
    cedulaEmpleado?: StringFilter | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreDeduccion?: StringFilter | string
    aporte?: FloatNullableFilter | number | null
  }

  export type personaCreateWithoutEmpleadoInput = {
    cedula: string
    nombre?: string | null
    telefono?: string | null
    empleador?: empleadorCreateNestedOneWithoutPersonaInput
    hace_uso?: hace_usoCreateNestedManyWithoutPersonaInput
  }

  export type personaUncheckedCreateWithoutEmpleadoInput = {
    cedula: string
    nombre?: string | null
    telefono?: string | null
    empleador?: empleadorUncheckedCreateNestedOneWithoutPersonaInput
    hace_uso?: hace_usoUncheckedCreateNestedManyWithoutPersonaInput
  }

  export type personaCreateOrConnectWithoutEmpleadoInput = {
    where: personaWhereUniqueInput
    create: XOR<personaCreateWithoutEmpleadoInput, personaUncheckedCreateWithoutEmpleadoInput>
  }

  export type empresaCreateWithoutEmpleadoInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    telefono?: string | null
    empleador?: empleadorCreateNestedOneWithoutEmpresaInput
    proyecto?: proyectoCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUncheckedCreateWithoutEmpleadoInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    cedulaEmpleador?: string | null
    telefono?: string | null
    proyecto?: proyectoUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type empresaCreateOrConnectWithoutEmpleadoInput = {
    where: empresaWhereUniqueInput
    create: XOR<empresaCreateWithoutEmpleadoInput, empresaUncheckedCreateWithoutEmpleadoInput>
  }

  export type escogeCreateWithoutEmpleadoInput = {
    aporte?: number | null
    deduccionVoluntaria: deduccionVoluntariaCreateNestedOneWithoutEscogeInput
  }

  export type escogeUncheckedCreateWithoutEmpleadoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    aporte?: number | null
  }

  export type escogeCreateOrConnectWithoutEmpleadoInput = {
    where: escogeWhereUniqueInput
    create: XOR<escogeCreateWithoutEmpleadoInput, escogeUncheckedCreateWithoutEmpleadoInput>
  }

  export type escogeCreateManyEmpleadoInputEnvelope = {
    data: Enumerable<escogeCreateManyEmpleadoInput>
  }

  export type esContratadoCreateWithoutEmpleadoInput = {
    tipoEmpleado?: string | null
    puesto?: string | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    jornada?: string | null
    salario?: number | null
    proyecto: proyectoCreateNestedOneWithoutEsContratadoInput
  }

  export type esContratadoUncheckedCreateWithoutEmpleadoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    tipoEmpleado?: string | null
    puesto?: string | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    jornada?: string | null
    salario?: number | null
  }

  export type esContratadoCreateOrConnectWithoutEmpleadoInput = {
    where: esContratadoWhereUniqueInput
    create: XOR<esContratadoCreateWithoutEmpleadoInput, esContratadoUncheckedCreateWithoutEmpleadoInput>
  }

  export type esContratadoCreateManyEmpleadoInputEnvelope = {
    data: Enumerable<esContratadoCreateManyEmpleadoInput>
  }

  export type pagoCreateWithoutEmpleadoInput = {
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    aplica_b?: aplica_bCreateNestedManyWithoutPagoInput
    aplica_do?: aplica_doCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvCreateNestedManyWithoutPagoInput
    genera?: generaCreateNestedManyWithoutPagoInput
  }

  export type pagoUncheckedCreateWithoutEmpleadoInput = {
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    aplica_b?: aplica_bUncheckedCreateNestedManyWithoutPagoInput
    aplica_do?: aplica_doUncheckedCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedCreateNestedManyWithoutPagoInput
    genera?: generaUncheckedCreateNestedManyWithoutPagoInput
  }

  export type pagoCreateOrConnectWithoutEmpleadoInput = {
    where: pagoWhereUniqueInput
    create: XOR<pagoCreateWithoutEmpleadoInput, pagoUncheckedCreateWithoutEmpleadoInput>
  }

  export type pagoCreateManyEmpleadoInputEnvelope = {
    data: Enumerable<pagoCreateManyEmpleadoInput>
  }

  export type reporteHorasCreateWithoutEmpleadoInput = {
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
    empleador?: empleadorCreateNestedOneWithoutReporteHorasInput
    proyecto?: proyectoCreateNestedOneWithoutReporteHorasInput
  }

  export type reporteHorasUncheckedCreateWithoutEmpleadoInput = {
    cedulaEmpleador?: string | null
    cedulaJuridica?: string | null
    nombreProyecto?: string | null
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
  }

  export type reporteHorasCreateOrConnectWithoutEmpleadoInput = {
    where: reporteHorasWhereUniqueInput
    create: XOR<reporteHorasCreateWithoutEmpleadoInput, reporteHorasUncheckedCreateWithoutEmpleadoInput>
  }

  export type reporteHorasCreateManyEmpleadoInputEnvelope = {
    data: Enumerable<reporteHorasCreateManyEmpleadoInput>
  }

  export type seleccionaCreateWithoutEmpleadoInput = {
    beneficios: beneficiosCreateNestedOneWithoutSeleccionaInput
  }

  export type seleccionaUncheckedCreateWithoutEmpleadoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type seleccionaCreateOrConnectWithoutEmpleadoInput = {
    where: seleccionaWhereUniqueInput
    create: XOR<seleccionaCreateWithoutEmpleadoInput, seleccionaUncheckedCreateWithoutEmpleadoInput>
  }

  export type seleccionaCreateManyEmpleadoInputEnvelope = {
    data: Enumerable<seleccionaCreateManyEmpleadoInput>
  }

  export type personaUpsertWithoutEmpleadoInput = {
    update: XOR<personaUpdateWithoutEmpleadoInput, personaUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<personaCreateWithoutEmpleadoInput, personaUncheckedCreateWithoutEmpleadoInput>
  }

  export type personaUpdateWithoutEmpleadoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleador?: empleadorUpdateOneWithoutPersonaInput
    hace_uso?: hace_usoUpdateManyWithoutPersonaInput
  }

  export type personaUncheckedUpdateWithoutEmpleadoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleador?: empleadorUncheckedUpdateOneWithoutPersonaInput
    hace_uso?: hace_usoUncheckedUpdateManyWithoutPersonaInput
  }

  export type empresaUpsertWithoutEmpleadoInput = {
    update: XOR<empresaUpdateWithoutEmpleadoInput, empresaUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<empresaCreateWithoutEmpleadoInput, empresaUncheckedCreateWithoutEmpleadoInput>
  }

  export type empresaUpdateWithoutEmpleadoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleador?: empleadorUpdateOneWithoutEmpresaInput
    proyecto?: proyectoUpdateManyWithoutEmpresaInput
  }

  export type empresaUncheckedUpdateWithoutEmpleadoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cedulaEmpleador?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    proyecto?: proyectoUncheckedUpdateManyWithoutEmpresaInput
  }

  export type escogeUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: escogeWhereUniqueInput
    update: XOR<escogeUpdateWithoutEmpleadoInput, escogeUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<escogeCreateWithoutEmpleadoInput, escogeUncheckedCreateWithoutEmpleadoInput>
  }

  export type escogeUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: escogeWhereUniqueInput
    data: XOR<escogeUpdateWithoutEmpleadoInput, escogeUncheckedUpdateWithoutEmpleadoInput>
  }

  export type escogeUpdateManyWithWhereWithoutEmpleadoInput = {
    where: escogeScalarWhereInput
    data: XOR<escogeUpdateManyMutationInput, escogeUncheckedUpdateManyWithoutEscogeInput>
  }

  export type esContratadoUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: esContratadoWhereUniqueInput
    update: XOR<esContratadoUpdateWithoutEmpleadoInput, esContratadoUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<esContratadoCreateWithoutEmpleadoInput, esContratadoUncheckedCreateWithoutEmpleadoInput>
  }

  export type esContratadoUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: esContratadoWhereUniqueInput
    data: XOR<esContratadoUpdateWithoutEmpleadoInput, esContratadoUncheckedUpdateWithoutEmpleadoInput>
  }

  export type esContratadoUpdateManyWithWhereWithoutEmpleadoInput = {
    where: esContratadoScalarWhereInput
    data: XOR<esContratadoUpdateManyMutationInput, esContratadoUncheckedUpdateManyWithoutEsContratadoInput>
  }

  export type esContratadoScalarWhereInput = {
    AND?: Enumerable<esContratadoScalarWhereInput>
    OR?: Enumerable<esContratadoScalarWhereInput>
    NOT?: Enumerable<esContratadoScalarWhereInput>
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    cedulaEmpleado?: StringFilter | string
    tipoEmpleado?: StringNullableFilter | string | null
    puesto?: StringNullableFilter | string | null
    fechaInicio?: DateTimeNullableFilter | Date | string | null
    fechaFin?: DateTimeNullableFilter | Date | string | null
    jornada?: StringNullableFilter | string | null
    salario?: FloatNullableFilter | number | null
  }

  export type pagoUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: pagoWhereUniqueInput
    update: XOR<pagoUpdateWithoutEmpleadoInput, pagoUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<pagoCreateWithoutEmpleadoInput, pagoUncheckedCreateWithoutEmpleadoInput>
  }

  export type pagoUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: pagoWhereUniqueInput
    data: XOR<pagoUpdateWithoutEmpleadoInput, pagoUncheckedUpdateWithoutEmpleadoInput>
  }

  export type pagoUpdateManyWithWhereWithoutEmpleadoInput = {
    where: pagoScalarWhereInput
    data: XOR<pagoUpdateManyMutationInput, pagoUncheckedUpdateManyWithoutPagoInput>
  }

  export type pagoScalarWhereInput = {
    AND?: Enumerable<pagoScalarWhereInput>
    OR?: Enumerable<pagoScalarWhereInput>
    NOT?: Enumerable<pagoScalarWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    deduccionesEmpleado?: StringNullableFilter | string | null
    deduccionesPatrono?: StringNullableFilter | string | null
    salarioBruto?: FloatNullableFilter | number | null
    beneficios?: StringNullableFilter | string | null
    salarioNeto?: FloatNullableFilter | number | null
    deduccionesVoluntarias?: StringNullableFilter | string | null
  }

  export type reporteHorasUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: reporteHorasWhereUniqueInput
    update: XOR<reporteHorasUpdateWithoutEmpleadoInput, reporteHorasUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<reporteHorasCreateWithoutEmpleadoInput, reporteHorasUncheckedCreateWithoutEmpleadoInput>
  }

  export type reporteHorasUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: reporteHorasWhereUniqueInput
    data: XOR<reporteHorasUpdateWithoutEmpleadoInput, reporteHorasUncheckedUpdateWithoutEmpleadoInput>
  }

  export type reporteHorasUpdateManyWithWhereWithoutEmpleadoInput = {
    where: reporteHorasScalarWhereInput
    data: XOR<reporteHorasUpdateManyMutationInput, reporteHorasUncheckedUpdateManyWithoutReporteHorasInput>
  }

  export type reporteHorasScalarWhereInput = {
    AND?: Enumerable<reporteHorasScalarWhereInput>
    OR?: Enumerable<reporteHorasScalarWhereInput>
    NOT?: Enumerable<reporteHorasScalarWhereInput>
    cedulaEmpleado?: StringFilter | string
    cedulaEmpleador?: StringNullableFilter | string | null
    cedulaJuridica?: StringNullableFilter | string | null
    nombreProyecto?: StringNullableFilter | string | null
    fechaHora?: DateTimeFilter | Date | string
    horasTrabajadas?: IntNullableFilter | number | null
    estado?: IntNullableFilter | number | null
  }

  export type seleccionaUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: seleccionaWhereUniqueInput
    update: XOR<seleccionaUpdateWithoutEmpleadoInput, seleccionaUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<seleccionaCreateWithoutEmpleadoInput, seleccionaUncheckedCreateWithoutEmpleadoInput>
  }

  export type seleccionaUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: seleccionaWhereUniqueInput
    data: XOR<seleccionaUpdateWithoutEmpleadoInput, seleccionaUncheckedUpdateWithoutEmpleadoInput>
  }

  export type seleccionaUpdateManyWithWhereWithoutEmpleadoInput = {
    where: seleccionaScalarWhereInput
    data: XOR<seleccionaUpdateManyMutationInput, seleccionaUncheckedUpdateManyWithoutSeleccionaInput>
  }

  export type personaCreateWithoutEmpleadorInput = {
    cedula: string
    nombre?: string | null
    telefono?: string | null
    empleado?: empleadoCreateNestedOneWithoutPersonaInput
    hace_uso?: hace_usoCreateNestedManyWithoutPersonaInput
  }

  export type personaUncheckedCreateWithoutEmpleadorInput = {
    cedula: string
    nombre?: string | null
    telefono?: string | null
    empleado?: empleadoUncheckedCreateNestedOneWithoutPersonaInput
    hace_uso?: hace_usoUncheckedCreateNestedManyWithoutPersonaInput
  }

  export type personaCreateOrConnectWithoutEmpleadorInput = {
    where: personaWhereUniqueInput
    create: XOR<personaCreateWithoutEmpleadorInput, personaUncheckedCreateWithoutEmpleadorInput>
  }

  export type empresaCreateWithoutEmpleadorInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    telefono?: string | null
    empleado?: empleadoCreateNestedManyWithoutEmpresaInput
    proyecto?: proyectoCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUncheckedCreateWithoutEmpleadorInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    telefono?: string | null
    empleado?: empleadoUncheckedCreateNestedManyWithoutEmpresaInput
    proyecto?: proyectoUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type empresaCreateOrConnectWithoutEmpleadorInput = {
    where: empresaWhereUniqueInput
    create: XOR<empresaCreateWithoutEmpleadorInput, empresaUncheckedCreateWithoutEmpleadorInput>
  }

  export type empresaCreateManyEmpleadorInputEnvelope = {
    data: Enumerable<empresaCreateManyEmpleadorInput>
  }

  export type reporteHorasCreateWithoutEmpleadorInput = {
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
    empleado: empleadoCreateNestedOneWithoutReporteHorasInput
    proyecto?: proyectoCreateNestedOneWithoutReporteHorasInput
  }

  export type reporteHorasUncheckedCreateWithoutEmpleadorInput = {
    cedulaEmpleado: string
    cedulaJuridica?: string | null
    nombreProyecto?: string | null
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
  }

  export type reporteHorasCreateOrConnectWithoutEmpleadorInput = {
    where: reporteHorasWhereUniqueInput
    create: XOR<reporteHorasCreateWithoutEmpleadorInput, reporteHorasUncheckedCreateWithoutEmpleadorInput>
  }

  export type reporteHorasCreateManyEmpleadorInputEnvelope = {
    data: Enumerable<reporteHorasCreateManyEmpleadorInput>
  }

  export type personaUpsertWithoutEmpleadorInput = {
    update: XOR<personaUpdateWithoutEmpleadorInput, personaUncheckedUpdateWithoutEmpleadorInput>
    create: XOR<personaCreateWithoutEmpleadorInput, personaUncheckedCreateWithoutEmpleadorInput>
  }

  export type personaUpdateWithoutEmpleadorInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateOneWithoutPersonaInput
    hace_uso?: hace_usoUpdateManyWithoutPersonaInput
  }

  export type personaUncheckedUpdateWithoutEmpleadorInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUncheckedUpdateOneWithoutPersonaInput
    hace_uso?: hace_usoUncheckedUpdateManyWithoutPersonaInput
  }

  export type empresaUpsertWithWhereUniqueWithoutEmpleadorInput = {
    where: empresaWhereUniqueInput
    update: XOR<empresaUpdateWithoutEmpleadorInput, empresaUncheckedUpdateWithoutEmpleadorInput>
    create: XOR<empresaCreateWithoutEmpleadorInput, empresaUncheckedCreateWithoutEmpleadorInput>
  }

  export type empresaUpdateWithWhereUniqueWithoutEmpleadorInput = {
    where: empresaWhereUniqueInput
    data: XOR<empresaUpdateWithoutEmpleadorInput, empresaUncheckedUpdateWithoutEmpleadorInput>
  }

  export type empresaUpdateManyWithWhereWithoutEmpleadorInput = {
    where: empresaScalarWhereInput
    data: XOR<empresaUpdateManyMutationInput, empresaUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type empresaScalarWhereInput = {
    AND?: Enumerable<empresaScalarWhereInput>
    OR?: Enumerable<empresaScalarWhereInput>
    NOT?: Enumerable<empresaScalarWhereInput>
    cedulaJuridica?: StringFilter | string
    direccion?: StringNullableFilter | string | null
    razonSocial?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    habilitado?: BoolNullableFilter | boolean | null
    cedulaEmpleador?: StringNullableFilter | string | null
    telefono?: StringNullableFilter | string | null
  }

  export type reporteHorasUpsertWithWhereUniqueWithoutEmpleadorInput = {
    where: reporteHorasWhereUniqueInput
    update: XOR<reporteHorasUpdateWithoutEmpleadorInput, reporteHorasUncheckedUpdateWithoutEmpleadorInput>
    create: XOR<reporteHorasCreateWithoutEmpleadorInput, reporteHorasUncheckedCreateWithoutEmpleadorInput>
  }

  export type reporteHorasUpdateWithWhereUniqueWithoutEmpleadorInput = {
    where: reporteHorasWhereUniqueInput
    data: XOR<reporteHorasUpdateWithoutEmpleadorInput, reporteHorasUncheckedUpdateWithoutEmpleadorInput>
  }

  export type reporteHorasUpdateManyWithWhereWithoutEmpleadorInput = {
    where: reporteHorasScalarWhereInput
    data: XOR<reporteHorasUpdateManyMutationInput, reporteHorasUncheckedUpdateManyWithoutReporteHorasInput>
  }

  export type empleadorCreateWithoutEmpresaInput = {
    persona: personaCreateNestedOneWithoutEmpleadorInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadorInput
  }

  export type empleadorUncheckedCreateWithoutEmpresaInput = {
    cedula: string
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadorInput
  }

  export type empleadorCreateOrConnectWithoutEmpresaInput = {
    where: empleadorWhereUniqueInput
    create: XOR<empleadorCreateWithoutEmpresaInput, empleadorUncheckedCreateWithoutEmpresaInput>
  }

  export type empleadoCreateWithoutEmpresaInput = {
    persona: personaCreateNestedOneWithoutEmpleadoInput
    escoge?: escogeCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoCreateNestedManyWithoutEmpleadoInput
    pago?: pagoCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutEmpresaInput = {
    cedula: string
    escoge?: escogeUncheckedCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutEmpleadoInput
    pago?: pagoUncheckedCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutEmpresaInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutEmpresaInput, empleadoUncheckedCreateWithoutEmpresaInput>
  }

  export type empleadoCreateManyEmpresaInputEnvelope = {
    data: Enumerable<empleadoCreateManyEmpresaInput>
  }

  export type proyectoCreateWithoutEmpresaInput = {
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    beneficios?: beneficiosCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoCreateNestedManyWithoutProyectoInput
    genera?: generaCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutProyectoInput
  }

  export type proyectoUncheckedCreateWithoutEmpresaInput = {
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    beneficios?: beneficiosUncheckedCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutProyectoInput
    genera?: generaUncheckedCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type proyectoCreateOrConnectWithoutEmpresaInput = {
    where: proyectoWhereUniqueInput
    create: XOR<proyectoCreateWithoutEmpresaInput, proyectoUncheckedCreateWithoutEmpresaInput>
  }

  export type proyectoCreateManyEmpresaInputEnvelope = {
    data: Enumerable<proyectoCreateManyEmpresaInput>
  }

  export type empleadorUpsertWithoutEmpresaInput = {
    update: XOR<empleadorUpdateWithoutEmpresaInput, empleadorUncheckedUpdateWithoutEmpresaInput>
    create: XOR<empleadorCreateWithoutEmpresaInput, empleadorUncheckedCreateWithoutEmpresaInput>
  }

  export type empleadorUpdateWithoutEmpresaInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadorInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadorInput
  }

  export type empleadorUncheckedUpdateWithoutEmpresaInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadorInput
  }

  export type empleadoUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: empleadoWhereUniqueInput
    update: XOR<empleadoUpdateWithoutEmpresaInput, empleadoUncheckedUpdateWithoutEmpresaInput>
    create: XOR<empleadoCreateWithoutEmpresaInput, empleadoUncheckedCreateWithoutEmpresaInput>
  }

  export type empleadoUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: empleadoWhereUniqueInput
    data: XOR<empleadoUpdateWithoutEmpresaInput, empleadoUncheckedUpdateWithoutEmpresaInput>
  }

  export type empleadoUpdateManyWithWhereWithoutEmpresaInput = {
    where: empleadoScalarWhereInput
    data: XOR<empleadoUpdateManyMutationInput, empleadoUncheckedUpdateManyWithoutEmpleadoInput>
  }

  export type empleadoScalarWhereInput = {
    AND?: Enumerable<empleadoScalarWhereInput>
    OR?: Enumerable<empleadoScalarWhereInput>
    NOT?: Enumerable<empleadoScalarWhereInput>
    cedula?: StringFilter | string
    cedulaJuridica?: StringNullableFilter | string | null
  }

  export type proyectoUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: proyectoWhereUniqueInput
    update: XOR<proyectoUpdateWithoutEmpresaInput, proyectoUncheckedUpdateWithoutEmpresaInput>
    create: XOR<proyectoCreateWithoutEmpresaInput, proyectoUncheckedCreateWithoutEmpresaInput>
  }

  export type proyectoUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: proyectoWhereUniqueInput
    data: XOR<proyectoUpdateWithoutEmpresaInput, proyectoUncheckedUpdateWithoutEmpresaInput>
  }

  export type proyectoUpdateManyWithWhereWithoutEmpresaInput = {
    where: proyectoScalarWhereInput
    data: XOR<proyectoUpdateManyMutationInput, proyectoUncheckedUpdateManyWithoutProyectoInput>
  }

  export type proyectoScalarWhereInput = {
    AND?: Enumerable<proyectoScalarWhereInput>
    OR?: Enumerable<proyectoScalarWhereInput>
    NOT?: Enumerable<proyectoScalarWhereInput>
    cedulaJuridica?: StringFilter | string
    nombre?: StringFilter | string
    cantidadMaximaBeneficios?: IntNullableFilter | number | null
    montoMaximoBeneficio?: IntNullableFilter | number | null
    frecuenciaPago?: StringNullableFilter | string | null
    moneda?: StringNullableFilter | string | null
    fechaInicio?: DateTimeNullableFilter | Date | string | null
    habilitado?: BoolNullableFilter | boolean | null
    fechaFin?: DateTimeNullableFilter | Date | string | null
    fechaUltimoPago?: DateTimeNullableFilter | Date | string | null
  }

  export type empleadoCreateWithoutEscogeInput = {
    persona: personaCreateNestedOneWithoutEmpleadoInput
    empresa?: empresaCreateNestedOneWithoutEmpleadoInput
    esContratado?: esContratadoCreateNestedManyWithoutEmpleadoInput
    pago?: pagoCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutEscogeInput = {
    cedula: string
    cedulaJuridica?: string | null
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutEmpleadoInput
    pago?: pagoUncheckedCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutEscogeInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutEscogeInput, empleadoUncheckedCreateWithoutEscogeInput>
  }

  export type deduccionVoluntariaCreateWithoutEscogeInput = {
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
    proyecto: proyectoCreateNestedOneWithoutDeduccionVoluntariaInput
    aplica_dv?: aplica_dvCreateNestedManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUncheckedCreateWithoutEscogeInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
    aplica_dv?: aplica_dvUncheckedCreateNestedManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaCreateOrConnectWithoutEscogeInput = {
    where: deduccionVoluntariaWhereUniqueInput
    create: XOR<deduccionVoluntariaCreateWithoutEscogeInput, deduccionVoluntariaUncheckedCreateWithoutEscogeInput>
  }

  export type empleadoUpsertWithoutEscogeInput = {
    update: XOR<empleadoUpdateWithoutEscogeInput, empleadoUncheckedUpdateWithoutEscogeInput>
    create: XOR<empleadoCreateWithoutEscogeInput, empleadoUncheckedCreateWithoutEscogeInput>
  }

  export type empleadoUpdateWithoutEscogeInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadoInput
    empresa?: empresaUpdateOneWithoutEmpleadoInput
    esContratado?: esContratadoUpdateManyWithoutEmpleadoInput
    pago?: pagoUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUpdateManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedUpdateWithoutEscogeInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    esContratado?: esContratadoUncheckedUpdateManyWithoutEmpleadoInput
    pago?: pagoUncheckedUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedUpdateManyWithoutEmpleadoInput
  }

  export type deduccionVoluntariaUpsertWithoutEscogeInput = {
    update: XOR<deduccionVoluntariaUpdateWithoutEscogeInput, deduccionVoluntariaUncheckedUpdateWithoutEscogeInput>
    create: XOR<deduccionVoluntariaCreateWithoutEscogeInput, deduccionVoluntariaUncheckedCreateWithoutEscogeInput>
  }

  export type deduccionVoluntariaUpdateWithoutEscogeInput = {
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    proyecto?: proyectoUpdateOneRequiredWithoutDeduccionVoluntariaInput
    aplica_dv?: aplica_dvUpdateManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUncheckedUpdateWithoutEscogeInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aplica_dv?: aplica_dvUncheckedUpdateManyWithoutDeduccionVoluntariaInput
  }

  export type empleadoCreateWithoutEsContratadoInput = {
    persona: personaCreateNestedOneWithoutEmpleadoInput
    empresa?: empresaCreateNestedOneWithoutEmpleadoInput
    escoge?: escogeCreateNestedManyWithoutEmpleadoInput
    pago?: pagoCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutEsContratadoInput = {
    cedula: string
    cedulaJuridica?: string | null
    escoge?: escogeUncheckedCreateNestedManyWithoutEmpleadoInput
    pago?: pagoUncheckedCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutEsContratadoInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutEsContratadoInput, empleadoUncheckedCreateWithoutEsContratadoInput>
  }

  export type proyectoCreateWithoutEsContratadoInput = {
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    empresa: empresaCreateNestedOneWithoutProyectoInput
    beneficios?: beneficiosCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaCreateNestedManyWithoutProyectoInput
    genera?: generaCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutProyectoInput
  }

  export type proyectoUncheckedCreateWithoutEsContratadoInput = {
    cedulaJuridica: string
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    beneficios?: beneficiosUncheckedCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedCreateNestedManyWithoutProyectoInput
    genera?: generaUncheckedCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type proyectoCreateOrConnectWithoutEsContratadoInput = {
    where: proyectoWhereUniqueInput
    create: XOR<proyectoCreateWithoutEsContratadoInput, proyectoUncheckedCreateWithoutEsContratadoInput>
  }

  export type empleadoUpsertWithoutEsContratadoInput = {
    update: XOR<empleadoUpdateWithoutEsContratadoInput, empleadoUncheckedUpdateWithoutEsContratadoInput>
    create: XOR<empleadoCreateWithoutEsContratadoInput, empleadoUncheckedCreateWithoutEsContratadoInput>
  }

  export type empleadoUpdateWithoutEsContratadoInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadoInput
    empresa?: empresaUpdateOneWithoutEmpleadoInput
    escoge?: escogeUpdateManyWithoutEmpleadoInput
    pago?: pagoUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUpdateManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedUpdateWithoutEsContratadoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    escoge?: escogeUncheckedUpdateManyWithoutEmpleadoInput
    pago?: pagoUncheckedUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedUpdateManyWithoutEmpleadoInput
  }

  export type proyectoUpsertWithoutEsContratadoInput = {
    update: XOR<proyectoUpdateWithoutEsContratadoInput, proyectoUncheckedUpdateWithoutEsContratadoInput>
    create: XOR<proyectoCreateWithoutEsContratadoInput, proyectoUncheckedCreateWithoutEsContratadoInput>
  }

  export type proyectoUpdateWithoutEsContratadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: empresaUpdateOneRequiredWithoutProyectoInput
    beneficios?: beneficiosUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUpdateManyWithoutProyectoInput
    genera?: generaUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUpdateManyWithoutProyectoInput
  }

  export type proyectoUncheckedUpdateWithoutEsContratadoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficios?: beneficiosUncheckedUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedUpdateManyWithoutProyectoInput
    genera?: generaUncheckedUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutProyectoInput
  }

  export type pagoCreateWithoutGeneraInput = {
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    empleado: empleadoCreateNestedOneWithoutPagoInput
    aplica_b?: aplica_bCreateNestedManyWithoutPagoInput
    aplica_do?: aplica_doCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvCreateNestedManyWithoutPagoInput
  }

  export type pagoUncheckedCreateWithoutGeneraInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
    aplica_b?: aplica_bUncheckedCreateNestedManyWithoutPagoInput
    aplica_do?: aplica_doUncheckedCreateNestedManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedCreateNestedManyWithoutPagoInput
  }

  export type pagoCreateOrConnectWithoutGeneraInput = {
    where: pagoWhereUniqueInput
    create: XOR<pagoCreateWithoutGeneraInput, pagoUncheckedCreateWithoutGeneraInput>
  }

  export type proyectoCreateWithoutGeneraInput = {
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    empresa: empresaCreateNestedOneWithoutProyectoInput
    beneficios?: beneficiosCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutProyectoInput
  }

  export type proyectoUncheckedCreateWithoutGeneraInput = {
    cedulaJuridica: string
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    beneficios?: beneficiosUncheckedCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type proyectoCreateOrConnectWithoutGeneraInput = {
    where: proyectoWhereUniqueInput
    create: XOR<proyectoCreateWithoutGeneraInput, proyectoUncheckedCreateWithoutGeneraInput>
  }

  export type pagoUpsertWithoutGeneraInput = {
    update: XOR<pagoUpdateWithoutGeneraInput, pagoUncheckedUpdateWithoutGeneraInput>
    create: XOR<pagoCreateWithoutGeneraInput, pagoUncheckedCreateWithoutGeneraInput>
  }

  export type pagoUpdateWithoutGeneraInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateOneRequiredWithoutPagoInput
    aplica_b?: aplica_bUpdateManyWithoutPagoInput
    aplica_do?: aplica_doUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUpdateManyWithoutPagoInput
  }

  export type pagoUncheckedUpdateWithoutGeneraInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    aplica_b?: aplica_bUncheckedUpdateManyWithoutPagoInput
    aplica_do?: aplica_doUncheckedUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedUpdateManyWithoutPagoInput
  }

  export type proyectoUpsertWithoutGeneraInput = {
    update: XOR<proyectoUpdateWithoutGeneraInput, proyectoUncheckedUpdateWithoutGeneraInput>
    create: XOR<proyectoCreateWithoutGeneraInput, proyectoUncheckedCreateWithoutGeneraInput>
  }

  export type proyectoUpdateWithoutGeneraInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: empresaUpdateOneRequiredWithoutProyectoInput
    beneficios?: beneficiosUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUpdateManyWithoutProyectoInput
  }

  export type proyectoUncheckedUpdateWithoutGeneraInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficios?: beneficiosUncheckedUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutProyectoInput
  }

  export type personaCreateWithoutHace_usoInput = {
    cedula: string
    nombre?: string | null
    telefono?: string | null
    empleado?: empleadoCreateNestedOneWithoutPersonaInput
    empleador?: empleadorCreateNestedOneWithoutPersonaInput
  }

  export type personaUncheckedCreateWithoutHace_usoInput = {
    cedula: string
    nombre?: string | null
    telefono?: string | null
    empleado?: empleadoUncheckedCreateNestedOneWithoutPersonaInput
    empleador?: empleadorUncheckedCreateNestedOneWithoutPersonaInput
  }

  export type personaCreateOrConnectWithoutHace_usoInput = {
    where: personaWhereUniqueInput
    create: XOR<personaCreateWithoutHace_usoInput, personaUncheckedCreateWithoutHace_usoInput>
  }

  export type credencialesCreateWithoutHace_usoInput = {
    email: string
    contrasenna?: string | null
    verificado?: boolean | null
  }

  export type credencialesUncheckedCreateWithoutHace_usoInput = {
    email: string
    contrasenna?: string | null
    verificado?: boolean | null
  }

  export type credencialesCreateOrConnectWithoutHace_usoInput = {
    where: credencialesWhereUniqueInput
    create: XOR<credencialesCreateWithoutHace_usoInput, credencialesUncheckedCreateWithoutHace_usoInput>
  }

  export type personaUpsertWithoutHace_usoInput = {
    update: XOR<personaUpdateWithoutHace_usoInput, personaUncheckedUpdateWithoutHace_usoInput>
    create: XOR<personaCreateWithoutHace_usoInput, personaUncheckedCreateWithoutHace_usoInput>
  }

  export type personaUpdateWithoutHace_usoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateOneWithoutPersonaInput
    empleador?: empleadorUpdateOneWithoutPersonaInput
  }

  export type personaUncheckedUpdateWithoutHace_usoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUncheckedUpdateOneWithoutPersonaInput
    empleador?: empleadorUncheckedUpdateOneWithoutPersonaInput
  }

  export type credencialesUpsertWithoutHace_usoInput = {
    update: XOR<credencialesUpdateWithoutHace_usoInput, credencialesUncheckedUpdateWithoutHace_usoInput>
    create: XOR<credencialesCreateWithoutHace_usoInput, credencialesUncheckedCreateWithoutHace_usoInput>
  }

  export type credencialesUpdateWithoutHace_usoInput = {
    email?: StringFieldUpdateOperationsInput | string
    contrasenna?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type credencialesUncheckedUpdateWithoutHace_usoInput = {
    email?: StringFieldUpdateOperationsInput | string
    contrasenna?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type empleadoCreateWithoutPagoInput = {
    persona: personaCreateNestedOneWithoutEmpleadoInput
    empresa?: empresaCreateNestedOneWithoutEmpleadoInput
    escoge?: escogeCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutPagoInput = {
    cedula: string
    cedulaJuridica?: string | null
    escoge?: escogeUncheckedCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutPagoInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutPagoInput, empleadoUncheckedCreateWithoutPagoInput>
  }

  export type aplica_bCreateWithoutPagoInput = {
    beneficios: beneficiosCreateNestedOneWithoutAplica_bInput
  }

  export type aplica_bUncheckedCreateWithoutPagoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type aplica_bCreateOrConnectWithoutPagoInput = {
    where: aplica_bWhereUniqueInput
    create: XOR<aplica_bCreateWithoutPagoInput, aplica_bUncheckedCreateWithoutPagoInput>
  }

  export type aplica_bCreateManyPagoInputEnvelope = {
    data: Enumerable<aplica_bCreateManyPagoInput>
  }

  export type aplica_doCreateWithoutPagoInput = {
    deduccionObligatoria: deduccionObligatoriaCreateNestedOneWithoutAplica_doInput
  }

  export type aplica_doUncheckedCreateWithoutPagoInput = {
    nombreDO: string
  }

  export type aplica_doCreateOrConnectWithoutPagoInput = {
    where: aplica_doWhereUniqueInput
    create: XOR<aplica_doCreateWithoutPagoInput, aplica_doUncheckedCreateWithoutPagoInput>
  }

  export type aplica_doCreateManyPagoInputEnvelope = {
    data: Enumerable<aplica_doCreateManyPagoInput>
  }

  export type aplica_dvCreateWithoutPagoInput = {
    deduccionVoluntaria: deduccionVoluntariaCreateNestedOneWithoutAplica_dvInput
  }

  export type aplica_dvUncheckedCreateWithoutPagoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
  }

  export type aplica_dvCreateOrConnectWithoutPagoInput = {
    where: aplica_dvWhereUniqueInput
    create: XOR<aplica_dvCreateWithoutPagoInput, aplica_dvUncheckedCreateWithoutPagoInput>
  }

  export type aplica_dvCreateManyPagoInputEnvelope = {
    data: Enumerable<aplica_dvCreateManyPagoInput>
  }

  export type generaCreateWithoutPagoInput = {
    proyecto: proyectoCreateNestedOneWithoutGeneraInput
  }

  export type generaUncheckedCreateWithoutPagoInput = {
    cedulaJuridica: string
    nombreProyecto: string
  }

  export type generaCreateOrConnectWithoutPagoInput = {
    where: generaWhereUniqueInput
    create: XOR<generaCreateWithoutPagoInput, generaUncheckedCreateWithoutPagoInput>
  }

  export type generaCreateManyPagoInputEnvelope = {
    data: Enumerable<generaCreateManyPagoInput>
  }

  export type empleadoUpsertWithoutPagoInput = {
    update: XOR<empleadoUpdateWithoutPagoInput, empleadoUncheckedUpdateWithoutPagoInput>
    create: XOR<empleadoCreateWithoutPagoInput, empleadoUncheckedCreateWithoutPagoInput>
  }

  export type empleadoUpdateWithoutPagoInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadoInput
    empresa?: empresaUpdateOneWithoutEmpleadoInput
    escoge?: escogeUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUpdateManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedUpdateWithoutPagoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    escoge?: escogeUncheckedUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedUpdateManyWithoutEmpleadoInput
  }

  export type aplica_bUpsertWithWhereUniqueWithoutPagoInput = {
    where: aplica_bWhereUniqueInput
    update: XOR<aplica_bUpdateWithoutPagoInput, aplica_bUncheckedUpdateWithoutPagoInput>
    create: XOR<aplica_bCreateWithoutPagoInput, aplica_bUncheckedCreateWithoutPagoInput>
  }

  export type aplica_bUpdateWithWhereUniqueWithoutPagoInput = {
    where: aplica_bWhereUniqueInput
    data: XOR<aplica_bUpdateWithoutPagoInput, aplica_bUncheckedUpdateWithoutPagoInput>
  }

  export type aplica_bUpdateManyWithWhereWithoutPagoInput = {
    where: aplica_bScalarWhereInput
    data: XOR<aplica_bUpdateManyMutationInput, aplica_bUncheckedUpdateManyWithoutAplica_bInput>
  }

  export type aplica_doUpsertWithWhereUniqueWithoutPagoInput = {
    where: aplica_doWhereUniqueInput
    update: XOR<aplica_doUpdateWithoutPagoInput, aplica_doUncheckedUpdateWithoutPagoInput>
    create: XOR<aplica_doCreateWithoutPagoInput, aplica_doUncheckedCreateWithoutPagoInput>
  }

  export type aplica_doUpdateWithWhereUniqueWithoutPagoInput = {
    where: aplica_doWhereUniqueInput
    data: XOR<aplica_doUpdateWithoutPagoInput, aplica_doUncheckedUpdateWithoutPagoInput>
  }

  export type aplica_doUpdateManyWithWhereWithoutPagoInput = {
    where: aplica_doScalarWhereInput
    data: XOR<aplica_doUpdateManyMutationInput, aplica_doUncheckedUpdateManyWithoutAplica_doInput>
  }

  export type aplica_dvUpsertWithWhereUniqueWithoutPagoInput = {
    where: aplica_dvWhereUniqueInput
    update: XOR<aplica_dvUpdateWithoutPagoInput, aplica_dvUncheckedUpdateWithoutPagoInput>
    create: XOR<aplica_dvCreateWithoutPagoInput, aplica_dvUncheckedCreateWithoutPagoInput>
  }

  export type aplica_dvUpdateWithWhereUniqueWithoutPagoInput = {
    where: aplica_dvWhereUniqueInput
    data: XOR<aplica_dvUpdateWithoutPagoInput, aplica_dvUncheckedUpdateWithoutPagoInput>
  }

  export type aplica_dvUpdateManyWithWhereWithoutPagoInput = {
    where: aplica_dvScalarWhereInput
    data: XOR<aplica_dvUpdateManyMutationInput, aplica_dvUncheckedUpdateManyWithoutAplica_dvInput>
  }

  export type generaUpsertWithWhereUniqueWithoutPagoInput = {
    where: generaWhereUniqueInput
    update: XOR<generaUpdateWithoutPagoInput, generaUncheckedUpdateWithoutPagoInput>
    create: XOR<generaCreateWithoutPagoInput, generaUncheckedCreateWithoutPagoInput>
  }

  export type generaUpdateWithWhereUniqueWithoutPagoInput = {
    where: generaWhereUniqueInput
    data: XOR<generaUpdateWithoutPagoInput, generaUncheckedUpdateWithoutPagoInput>
  }

  export type generaUpdateManyWithWhereWithoutPagoInput = {
    where: generaScalarWhereInput
    data: XOR<generaUpdateManyMutationInput, generaUncheckedUpdateManyWithoutGeneraInput>
  }

  export type generaScalarWhereInput = {
    AND?: Enumerable<generaScalarWhereInput>
    OR?: Enumerable<generaScalarWhereInput>
    NOT?: Enumerable<generaScalarWhereInput>
    cedulaEmpleado?: StringFilter | string
    fechaHora?: DateTimeFilter | Date | string
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
  }

  export type empleadoCreateWithoutPersonaInput = {
    empresa?: empresaCreateNestedOneWithoutEmpleadoInput
    escoge?: escogeCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoCreateNestedManyWithoutEmpleadoInput
    pago?: pagoCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutPersonaInput = {
    cedulaJuridica?: string | null
    escoge?: escogeUncheckedCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutEmpleadoInput
    pago?: pagoUncheckedCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutPersonaInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutPersonaInput, empleadoUncheckedCreateWithoutPersonaInput>
  }

  export type empleadorCreateWithoutPersonaInput = {
    empresa?: empresaCreateNestedManyWithoutEmpleadorInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadorInput
  }

  export type empleadorUncheckedCreateWithoutPersonaInput = {
    empresa?: empresaUncheckedCreateNestedManyWithoutEmpleadorInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadorInput
  }

  export type empleadorCreateOrConnectWithoutPersonaInput = {
    where: empleadorWhereUniqueInput
    create: XOR<empleadorCreateWithoutPersonaInput, empleadorUncheckedCreateWithoutPersonaInput>
  }

  export type hace_usoCreateWithoutPersonaInput = {
    credenciales: credencialesCreateNestedOneWithoutHace_usoInput
  }

  export type hace_usoUncheckedCreateWithoutPersonaInput = {
    email: string
  }

  export type hace_usoCreateOrConnectWithoutPersonaInput = {
    where: hace_usoWhereUniqueInput
    create: XOR<hace_usoCreateWithoutPersonaInput, hace_usoUncheckedCreateWithoutPersonaInput>
  }

  export type hace_usoCreateManyPersonaInputEnvelope = {
    data: Enumerable<hace_usoCreateManyPersonaInput>
  }

  export type empleadoUpsertWithoutPersonaInput = {
    update: XOR<empleadoUpdateWithoutPersonaInput, empleadoUncheckedUpdateWithoutPersonaInput>
    create: XOR<empleadoCreateWithoutPersonaInput, empleadoUncheckedCreateWithoutPersonaInput>
  }

  export type empleadoUpdateWithoutPersonaInput = {
    empresa?: empresaUpdateOneWithoutEmpleadoInput
    escoge?: escogeUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUpdateManyWithoutEmpleadoInput
    pago?: pagoUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUpdateManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedUpdateWithoutPersonaInput = {
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    escoge?: escogeUncheckedUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutEmpleadoInput
    pago?: pagoUncheckedUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedUpdateManyWithoutEmpleadoInput
  }

  export type empleadorUpsertWithoutPersonaInput = {
    update: XOR<empleadorUpdateWithoutPersonaInput, empleadorUncheckedUpdateWithoutPersonaInput>
    create: XOR<empleadorCreateWithoutPersonaInput, empleadorUncheckedCreateWithoutPersonaInput>
  }

  export type empleadorUpdateWithoutPersonaInput = {
    empresa?: empresaUpdateManyWithoutEmpleadorInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadorInput
  }

  export type empleadorUncheckedUpdateWithoutPersonaInput = {
    empresa?: empresaUncheckedUpdateManyWithoutEmpleadorInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadorInput
  }

  export type hace_usoUpsertWithWhereUniqueWithoutPersonaInput = {
    where: hace_usoWhereUniqueInput
    update: XOR<hace_usoUpdateWithoutPersonaInput, hace_usoUncheckedUpdateWithoutPersonaInput>
    create: XOR<hace_usoCreateWithoutPersonaInput, hace_usoUncheckedCreateWithoutPersonaInput>
  }

  export type hace_usoUpdateWithWhereUniqueWithoutPersonaInput = {
    where: hace_usoWhereUniqueInput
    data: XOR<hace_usoUpdateWithoutPersonaInput, hace_usoUncheckedUpdateWithoutPersonaInput>
  }

  export type hace_usoUpdateManyWithWhereWithoutPersonaInput = {
    where: hace_usoScalarWhereInput
    data: XOR<hace_usoUpdateManyMutationInput, hace_usoUncheckedUpdateManyWithoutHace_usoInput>
  }

  export type empresaCreateWithoutProyectoInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    telefono?: string | null
    empleador?: empleadorCreateNestedOneWithoutEmpresaInput
    empleado?: empleadoCreateNestedManyWithoutEmpresaInput
  }

  export type empresaUncheckedCreateWithoutProyectoInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    cedulaEmpleador?: string | null
    telefono?: string | null
    empleado?: empleadoUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type empresaCreateOrConnectWithoutProyectoInput = {
    where: empresaWhereUniqueInput
    create: XOR<empresaCreateWithoutProyectoInput, empresaUncheckedCreateWithoutProyectoInput>
  }

  export type beneficiosCreateWithoutProyectoInput = {
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
    aplica_b?: aplica_bCreateNestedManyWithoutBeneficiosInput
    selecciona?: seleccionaCreateNestedManyWithoutBeneficiosInput
  }

  export type beneficiosUncheckedCreateWithoutProyectoInput = {
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
    aplica_b?: aplica_bUncheckedCreateNestedManyWithoutBeneficiosInput
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutBeneficiosInput
  }

  export type beneficiosCreateOrConnectWithoutProyectoInput = {
    where: beneficiosWhereUniqueInput
    create: XOR<beneficiosCreateWithoutProyectoInput, beneficiosUncheckedCreateWithoutProyectoInput>
  }

  export type beneficiosCreateManyProyectoInputEnvelope = {
    data: Enumerable<beneficiosCreateManyProyectoInput>
  }

  export type deduccionVoluntariaCreateWithoutProyectoInput = {
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
    aplica_dv?: aplica_dvCreateNestedManyWithoutDeduccionVoluntariaInput
    escoge?: escogeCreateNestedManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUncheckedCreateWithoutProyectoInput = {
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
    aplica_dv?: aplica_dvUncheckedCreateNestedManyWithoutDeduccionVoluntariaInput
    escoge?: escogeUncheckedCreateNestedManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaCreateOrConnectWithoutProyectoInput = {
    where: deduccionVoluntariaWhereUniqueInput
    create: XOR<deduccionVoluntariaCreateWithoutProyectoInput, deduccionVoluntariaUncheckedCreateWithoutProyectoInput>
  }

  export type deduccionVoluntariaCreateManyProyectoInputEnvelope = {
    data: Enumerable<deduccionVoluntariaCreateManyProyectoInput>
  }

  export type esContratadoCreateWithoutProyectoInput = {
    tipoEmpleado?: string | null
    puesto?: string | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    jornada?: string | null
    salario?: number | null
    empleado: empleadoCreateNestedOneWithoutEsContratadoInput
  }

  export type esContratadoUncheckedCreateWithoutProyectoInput = {
    cedulaEmpleado: string
    tipoEmpleado?: string | null
    puesto?: string | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    jornada?: string | null
    salario?: number | null
  }

  export type esContratadoCreateOrConnectWithoutProyectoInput = {
    where: esContratadoWhereUniqueInput
    create: XOR<esContratadoCreateWithoutProyectoInput, esContratadoUncheckedCreateWithoutProyectoInput>
  }

  export type esContratadoCreateManyProyectoInputEnvelope = {
    data: Enumerable<esContratadoCreateManyProyectoInput>
  }

  export type generaCreateWithoutProyectoInput = {
    pago: pagoCreateNestedOneWithoutGeneraInput
  }

  export type generaUncheckedCreateWithoutProyectoInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type generaCreateOrConnectWithoutProyectoInput = {
    where: generaWhereUniqueInput
    create: XOR<generaCreateWithoutProyectoInput, generaUncheckedCreateWithoutProyectoInput>
  }

  export type generaCreateManyProyectoInputEnvelope = {
    data: Enumerable<generaCreateManyProyectoInput>
  }

  export type reporteHorasCreateWithoutProyectoInput = {
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
    empleado: empleadoCreateNestedOneWithoutReporteHorasInput
    empleador?: empleadorCreateNestedOneWithoutReporteHorasInput
  }

  export type reporteHorasUncheckedCreateWithoutProyectoInput = {
    cedulaEmpleado: string
    cedulaEmpleador?: string | null
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
  }

  export type reporteHorasCreateOrConnectWithoutProyectoInput = {
    where: reporteHorasWhereUniqueInput
    create: XOR<reporteHorasCreateWithoutProyectoInput, reporteHorasUncheckedCreateWithoutProyectoInput>
  }

  export type reporteHorasCreateManyProyectoInputEnvelope = {
    data: Enumerable<reporteHorasCreateManyProyectoInput>
  }

  export type empresaUpsertWithoutProyectoInput = {
    update: XOR<empresaUpdateWithoutProyectoInput, empresaUncheckedUpdateWithoutProyectoInput>
    create: XOR<empresaCreateWithoutProyectoInput, empresaUncheckedCreateWithoutProyectoInput>
  }

  export type empresaUpdateWithoutProyectoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleador?: empleadorUpdateOneWithoutEmpresaInput
    empleado?: empleadoUpdateManyWithoutEmpresaInput
  }

  export type empresaUncheckedUpdateWithoutProyectoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cedulaEmpleador?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUncheckedUpdateManyWithoutEmpresaInput
  }

  export type beneficiosUpsertWithWhereUniqueWithoutProyectoInput = {
    where: beneficiosWhereUniqueInput
    update: XOR<beneficiosUpdateWithoutProyectoInput, beneficiosUncheckedUpdateWithoutProyectoInput>
    create: XOR<beneficiosCreateWithoutProyectoInput, beneficiosUncheckedCreateWithoutProyectoInput>
  }

  export type beneficiosUpdateWithWhereUniqueWithoutProyectoInput = {
    where: beneficiosWhereUniqueInput
    data: XOR<beneficiosUpdateWithoutProyectoInput, beneficiosUncheckedUpdateWithoutProyectoInput>
  }

  export type beneficiosUpdateManyWithWhereWithoutProyectoInput = {
    where: beneficiosScalarWhereInput
    data: XOR<beneficiosUpdateManyMutationInput, beneficiosUncheckedUpdateManyWithoutBeneficiosInput>
  }

  export type beneficiosScalarWhereInput = {
    AND?: Enumerable<beneficiosScalarWhereInput>
    OR?: Enumerable<beneficiosScalarWhereInput>
    NOT?: Enumerable<beneficiosScalarWhereInput>
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreBeneficio?: StringFilter | string
    montoPago?: FloatNullableFilter | number | null
    descripcion?: StringNullableFilter | string | null
    habilitado?: BoolNullableFilter | boolean | null
  }

  export type deduccionVoluntariaUpsertWithWhereUniqueWithoutProyectoInput = {
    where: deduccionVoluntariaWhereUniqueInput
    update: XOR<deduccionVoluntariaUpdateWithoutProyectoInput, deduccionVoluntariaUncheckedUpdateWithoutProyectoInput>
    create: XOR<deduccionVoluntariaCreateWithoutProyectoInput, deduccionVoluntariaUncheckedCreateWithoutProyectoInput>
  }

  export type deduccionVoluntariaUpdateWithWhereUniqueWithoutProyectoInput = {
    where: deduccionVoluntariaWhereUniqueInput
    data: XOR<deduccionVoluntariaUpdateWithoutProyectoInput, deduccionVoluntariaUncheckedUpdateWithoutProyectoInput>
  }

  export type deduccionVoluntariaUpdateManyWithWhereWithoutProyectoInput = {
    where: deduccionVoluntariaScalarWhereInput
    data: XOR<deduccionVoluntariaUpdateManyMutationInput, deduccionVoluntariaUncheckedUpdateManyWithoutDeduccionVoluntariaInput>
  }

  export type deduccionVoluntariaScalarWhereInput = {
    AND?: Enumerable<deduccionVoluntariaScalarWhereInput>
    OR?: Enumerable<deduccionVoluntariaScalarWhereInput>
    NOT?: Enumerable<deduccionVoluntariaScalarWhereInput>
    cedulaJuridica?: StringFilter | string
    nombreProyecto?: StringFilter | string
    nombreDeduccion?: StringFilter | string
    descripcion?: StringNullableFilter | string | null
    monto?: FloatNullableFilter | number | null
    habilitado?: BoolNullableFilter | boolean | null
  }

  export type esContratadoUpsertWithWhereUniqueWithoutProyectoInput = {
    where: esContratadoWhereUniqueInput
    update: XOR<esContratadoUpdateWithoutProyectoInput, esContratadoUncheckedUpdateWithoutProyectoInput>
    create: XOR<esContratadoCreateWithoutProyectoInput, esContratadoUncheckedCreateWithoutProyectoInput>
  }

  export type esContratadoUpdateWithWhereUniqueWithoutProyectoInput = {
    where: esContratadoWhereUniqueInput
    data: XOR<esContratadoUpdateWithoutProyectoInput, esContratadoUncheckedUpdateWithoutProyectoInput>
  }

  export type esContratadoUpdateManyWithWhereWithoutProyectoInput = {
    where: esContratadoScalarWhereInput
    data: XOR<esContratadoUpdateManyMutationInput, esContratadoUncheckedUpdateManyWithoutEsContratadoInput>
  }

  export type generaUpsertWithWhereUniqueWithoutProyectoInput = {
    where: generaWhereUniqueInput
    update: XOR<generaUpdateWithoutProyectoInput, generaUncheckedUpdateWithoutProyectoInput>
    create: XOR<generaCreateWithoutProyectoInput, generaUncheckedCreateWithoutProyectoInput>
  }

  export type generaUpdateWithWhereUniqueWithoutProyectoInput = {
    where: generaWhereUniqueInput
    data: XOR<generaUpdateWithoutProyectoInput, generaUncheckedUpdateWithoutProyectoInput>
  }

  export type generaUpdateManyWithWhereWithoutProyectoInput = {
    where: generaScalarWhereInput
    data: XOR<generaUpdateManyMutationInput, generaUncheckedUpdateManyWithoutGeneraInput>
  }

  export type reporteHorasUpsertWithWhereUniqueWithoutProyectoInput = {
    where: reporteHorasWhereUniqueInput
    update: XOR<reporteHorasUpdateWithoutProyectoInput, reporteHorasUncheckedUpdateWithoutProyectoInput>
    create: XOR<reporteHorasCreateWithoutProyectoInput, reporteHorasUncheckedCreateWithoutProyectoInput>
  }

  export type reporteHorasUpdateWithWhereUniqueWithoutProyectoInput = {
    where: reporteHorasWhereUniqueInput
    data: XOR<reporteHorasUpdateWithoutProyectoInput, reporteHorasUncheckedUpdateWithoutProyectoInput>
  }

  export type reporteHorasUpdateManyWithWhereWithoutProyectoInput = {
    where: reporteHorasScalarWhereInput
    data: XOR<reporteHorasUpdateManyMutationInput, reporteHorasUncheckedUpdateManyWithoutReporteHorasInput>
  }

  export type empleadoCreateWithoutReporteHorasInput = {
    persona: personaCreateNestedOneWithoutEmpleadoInput
    empresa?: empresaCreateNestedOneWithoutEmpleadoInput
    escoge?: escogeCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoCreateNestedManyWithoutEmpleadoInput
    pago?: pagoCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutReporteHorasInput = {
    cedula: string
    cedulaJuridica?: string | null
    escoge?: escogeUncheckedCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutEmpleadoInput
    pago?: pagoUncheckedCreateNestedManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutReporteHorasInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutReporteHorasInput, empleadoUncheckedCreateWithoutReporteHorasInput>
  }

  export type empleadorCreateWithoutReporteHorasInput = {
    persona: personaCreateNestedOneWithoutEmpleadorInput
    empresa?: empresaCreateNestedManyWithoutEmpleadorInput
  }

  export type empleadorUncheckedCreateWithoutReporteHorasInput = {
    cedula: string
    empresa?: empresaUncheckedCreateNestedManyWithoutEmpleadorInput
  }

  export type empleadorCreateOrConnectWithoutReporteHorasInput = {
    where: empleadorWhereUniqueInput
    create: XOR<empleadorCreateWithoutReporteHorasInput, empleadorUncheckedCreateWithoutReporteHorasInput>
  }

  export type proyectoCreateWithoutReporteHorasInput = {
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    empresa: empresaCreateNestedOneWithoutProyectoInput
    beneficios?: beneficiosCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoCreateNestedManyWithoutProyectoInput
    genera?: generaCreateNestedManyWithoutProyectoInput
  }

  export type proyectoUncheckedCreateWithoutReporteHorasInput = {
    cedulaJuridica: string
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
    beneficios?: beneficiosUncheckedCreateNestedManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedCreateNestedManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutProyectoInput
    genera?: generaUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type proyectoCreateOrConnectWithoutReporteHorasInput = {
    where: proyectoWhereUniqueInput
    create: XOR<proyectoCreateWithoutReporteHorasInput, proyectoUncheckedCreateWithoutReporteHorasInput>
  }

  export type empleadoUpsertWithoutReporteHorasInput = {
    update: XOR<empleadoUpdateWithoutReporteHorasInput, empleadoUncheckedUpdateWithoutReporteHorasInput>
    create: XOR<empleadoCreateWithoutReporteHorasInput, empleadoUncheckedCreateWithoutReporteHorasInput>
  }

  export type empleadoUpdateWithoutReporteHorasInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadoInput
    empresa?: empresaUpdateOneWithoutEmpleadoInput
    escoge?: escogeUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUpdateManyWithoutEmpleadoInput
    pago?: pagoUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUpdateManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedUpdateWithoutReporteHorasInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    escoge?: escogeUncheckedUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutEmpleadoInput
    pago?: pagoUncheckedUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedUpdateManyWithoutEmpleadoInput
  }

  export type empleadorUpsertWithoutReporteHorasInput = {
    update: XOR<empleadorUpdateWithoutReporteHorasInput, empleadorUncheckedUpdateWithoutReporteHorasInput>
    create: XOR<empleadorCreateWithoutReporteHorasInput, empleadorUncheckedCreateWithoutReporteHorasInput>
  }

  export type empleadorUpdateWithoutReporteHorasInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadorInput
    empresa?: empresaUpdateManyWithoutEmpleadorInput
  }

  export type empleadorUncheckedUpdateWithoutReporteHorasInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    empresa?: empresaUncheckedUpdateManyWithoutEmpleadorInput
  }

  export type proyectoUpsertWithoutReporteHorasInput = {
    update: XOR<proyectoUpdateWithoutReporteHorasInput, proyectoUncheckedUpdateWithoutReporteHorasInput>
    create: XOR<proyectoCreateWithoutReporteHorasInput, proyectoUncheckedCreateWithoutReporteHorasInput>
  }

  export type proyectoUpdateWithoutReporteHorasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: empresaUpdateOneRequiredWithoutProyectoInput
    beneficios?: beneficiosUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUpdateManyWithoutProyectoInput
    genera?: generaUpdateManyWithoutProyectoInput
  }

  export type proyectoUncheckedUpdateWithoutReporteHorasInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficios?: beneficiosUncheckedUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutProyectoInput
    genera?: generaUncheckedUpdateManyWithoutProyectoInput
  }

  export type empleadoCreateWithoutSeleccionaInput = {
    persona: personaCreateNestedOneWithoutEmpleadoInput
    empresa?: empresaCreateNestedOneWithoutEmpleadoInput
    escoge?: escogeCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoCreateNestedManyWithoutEmpleadoInput
    pago?: pagoCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutSeleccionaInput = {
    cedula: string
    cedulaJuridica?: string | null
    escoge?: escogeUncheckedCreateNestedManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedCreateNestedManyWithoutEmpleadoInput
    pago?: pagoUncheckedCreateNestedManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutSeleccionaInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutSeleccionaInput, empleadoUncheckedCreateWithoutSeleccionaInput>
  }

  export type beneficiosCreateWithoutSeleccionaInput = {
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
    proyecto: proyectoCreateNestedOneWithoutBeneficiosInput
    aplica_b?: aplica_bCreateNestedManyWithoutBeneficiosInput
  }

  export type beneficiosUncheckedCreateWithoutSeleccionaInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
    aplica_b?: aplica_bUncheckedCreateNestedManyWithoutBeneficiosInput
  }

  export type beneficiosCreateOrConnectWithoutSeleccionaInput = {
    where: beneficiosWhereUniqueInput
    create: XOR<beneficiosCreateWithoutSeleccionaInput, beneficiosUncheckedCreateWithoutSeleccionaInput>
  }

  export type empleadoUpsertWithoutSeleccionaInput = {
    update: XOR<empleadoUpdateWithoutSeleccionaInput, empleadoUncheckedUpdateWithoutSeleccionaInput>
    create: XOR<empleadoCreateWithoutSeleccionaInput, empleadoUncheckedCreateWithoutSeleccionaInput>
  }

  export type empleadoUpdateWithoutSeleccionaInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadoInput
    empresa?: empresaUpdateOneWithoutEmpleadoInput
    escoge?: escogeUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUpdateManyWithoutEmpleadoInput
    pago?: pagoUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedUpdateWithoutSeleccionaInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    escoge?: escogeUncheckedUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutEmpleadoInput
    pago?: pagoUncheckedUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadoInput
  }

  export type beneficiosUpsertWithoutSeleccionaInput = {
    update: XOR<beneficiosUpdateWithoutSeleccionaInput, beneficiosUncheckedUpdateWithoutSeleccionaInput>
    create: XOR<beneficiosCreateWithoutSeleccionaInput, beneficiosUncheckedCreateWithoutSeleccionaInput>
  }

  export type beneficiosUpdateWithoutSeleccionaInput = {
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    proyecto?: proyectoUpdateOneRequiredWithoutBeneficiosInput
    aplica_b?: aplica_bUpdateManyWithoutBeneficiosInput
  }

  export type beneficiosUncheckedUpdateWithoutSeleccionaInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aplica_b?: aplica_bUncheckedUpdateManyWithoutBeneficiosInput
  }

  export type aplica_bCreateManyBeneficiosInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type seleccionaCreateManyBeneficiosInput = {
    cedulaEmpleado: string
  }

  export type aplica_bUpdateWithoutBeneficiosInput = {
    pago?: pagoUpdateOneRequiredWithoutAplica_bInput
  }

  export type aplica_bUncheckedUpdateWithoutBeneficiosInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aplica_bUncheckedUpdateManyWithoutAplica_bInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type seleccionaUpdateWithoutBeneficiosInput = {
    empleado?: empleadoUpdateOneRequiredWithoutSeleccionaInput
  }

  export type seleccionaUncheckedUpdateWithoutBeneficiosInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
  }

  export type seleccionaUncheckedUpdateManyWithoutSeleccionaInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
  }

  export type hace_usoCreateManyCredencialesInput = {
    cedula: string
  }

  export type hace_usoUpdateWithoutCredencialesInput = {
    persona?: personaUpdateOneRequiredWithoutHace_usoInput
  }

  export type hace_usoUncheckedUpdateWithoutCredencialesInput = {
    cedula?: StringFieldUpdateOperationsInput | string
  }

  export type hace_usoUncheckedUpdateManyWithoutHace_usoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
  }

  export type aplica_doCreateManyDeduccionObligatoriaInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type aplica_doUpdateWithoutDeduccionObligatoriaInput = {
    pago?: pagoUpdateOneRequiredWithoutAplica_doInput
  }

  export type aplica_doUncheckedUpdateWithoutDeduccionObligatoriaInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aplica_doUncheckedUpdateManyWithoutAplica_doInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aplica_dvCreateManyDeduccionVoluntariaInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type escogeCreateManyDeduccionVoluntariaInput = {
    cedulaEmpleado: string
    aporte?: number | null
  }

  export type aplica_dvUpdateWithoutDeduccionVoluntariaInput = {
    pago?: pagoUpdateOneRequiredWithoutAplica_dvInput
  }

  export type aplica_dvUncheckedUpdateWithoutDeduccionVoluntariaInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aplica_dvUncheckedUpdateManyWithoutAplica_dvInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escogeUpdateWithoutDeduccionVoluntariaInput = {
    aporte?: NullableFloatFieldUpdateOperationsInput | number | null
    empleado?: empleadoUpdateOneRequiredWithoutEscogeInput
  }

  export type escogeUncheckedUpdateWithoutDeduccionVoluntariaInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    aporte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type escogeUncheckedUpdateManyWithoutEscogeInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    aporte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type escogeCreateManyEmpleadoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
    aporte?: number | null
  }

  export type esContratadoCreateManyEmpleadoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    tipoEmpleado?: string | null
    puesto?: string | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    jornada?: string | null
    salario?: number | null
  }

  export type pagoCreateManyEmpleadoInput = {
    fechaHora: Date | string
    deduccionesEmpleado?: string | null
    deduccionesPatrono?: string | null
    salarioBruto?: number | null
    beneficios?: string | null
    salarioNeto?: number | null
    deduccionesVoluntarias?: string | null
  }

  export type reporteHorasCreateManyEmpleadoInput = {
    cedulaEmpleador?: string | null
    cedulaJuridica?: string | null
    nombreProyecto?: string | null
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
  }

  export type seleccionaCreateManyEmpleadoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type escogeUpdateWithoutEmpleadoInput = {
    aporte?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionVoluntaria?: deduccionVoluntariaUpdateOneRequiredWithoutEscogeInput
  }

  export type escogeUncheckedUpdateWithoutEmpleadoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    aporte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type esContratadoUpdateWithoutEmpleadoInput = {
    tipoEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jornada?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    proyecto?: proyectoUpdateOneRequiredWithoutEsContratadoInput
  }

  export type esContratadoUncheckedUpdateWithoutEmpleadoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    tipoEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jornada?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type esContratadoUncheckedUpdateManyWithoutEsContratadoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    tipoEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jornada?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type pagoUpdateWithoutEmpleadoInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    aplica_b?: aplica_bUpdateManyWithoutPagoInput
    aplica_do?: aplica_doUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUpdateManyWithoutPagoInput
    genera?: generaUpdateManyWithoutPagoInput
  }

  export type pagoUncheckedUpdateWithoutEmpleadoInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
    aplica_b?: aplica_bUncheckedUpdateManyWithoutPagoInput
    aplica_do?: aplica_doUncheckedUpdateManyWithoutPagoInput
    aplica_dv?: aplica_dvUncheckedUpdateManyWithoutPagoInput
    genera?: generaUncheckedUpdateManyWithoutPagoInput
  }

  export type pagoUncheckedUpdateManyWithoutPagoInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    deduccionesEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    deduccionesPatrono?: NullableStringFieldUpdateOperationsInput | string | null
    salarioBruto?: NullableFloatFieldUpdateOperationsInput | number | null
    beneficios?: NullableStringFieldUpdateOperationsInput | string | null
    salarioNeto?: NullableFloatFieldUpdateOperationsInput | number | null
    deduccionesVoluntarias?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reporteHorasUpdateWithoutEmpleadoInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empleador?: empleadorUpdateOneWithoutReporteHorasInput
    proyecto?: proyectoUpdateOneWithoutReporteHorasInput
  }

  export type reporteHorasUncheckedUpdateWithoutEmpleadoInput = {
    cedulaEmpleador?: NullableStringFieldUpdateOperationsInput | string | null
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    nombreProyecto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reporteHorasUncheckedUpdateManyWithoutReporteHorasInput = {
    cedulaEmpleador?: NullableStringFieldUpdateOperationsInput | string | null
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    nombreProyecto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type seleccionaUpdateWithoutEmpleadoInput = {
    beneficios?: beneficiosUpdateOneRequiredWithoutSeleccionaInput
  }

  export type seleccionaUncheckedUpdateWithoutEmpleadoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
  }

  export type empresaCreateManyEmpleadorInput = {
    cedulaJuridica: string
    direccion?: string | null
    razonSocial?: string | null
    email?: string | null
    habilitado?: boolean | null
    telefono?: string | null
  }

  export type reporteHorasCreateManyEmpleadorInput = {
    cedulaEmpleado: string
    cedulaJuridica?: string | null
    nombreProyecto?: string | null
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
  }

  export type empresaUpdateWithoutEmpleadorInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateManyWithoutEmpresaInput
    proyecto?: proyectoUpdateManyWithoutEmpresaInput
  }

  export type empresaUncheckedUpdateWithoutEmpleadorInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUncheckedUpdateManyWithoutEmpresaInput
    proyecto?: proyectoUncheckedUpdateManyWithoutEmpresaInput
  }

  export type empresaUncheckedUpdateManyWithoutEmpresaInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reporteHorasUpdateWithoutEmpleadorInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empleado?: empleadoUpdateOneRequiredWithoutReporteHorasInput
    proyecto?: proyectoUpdateOneWithoutReporteHorasInput
  }

  export type reporteHorasUncheckedUpdateWithoutEmpleadorInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    cedulaJuridica?: NullableStringFieldUpdateOperationsInput | string | null
    nombreProyecto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empleadoCreateManyEmpresaInput = {
    cedula: string
  }

  export type proyectoCreateManyEmpresaInput = {
    nombre: string
    cantidadMaximaBeneficios?: number | null
    montoMaximoBeneficio?: number | null
    frecuenciaPago?: string | null
    moneda?: string | null
    fechaInicio?: Date | string | null
    habilitado?: boolean | null
    fechaFin?: Date | string | null
    fechaUltimoPago?: Date | string | null
  }

  export type empleadoUpdateWithoutEmpresaInput = {
    persona?: personaUpdateOneRequiredWithoutEmpleadoInput
    escoge?: escogeUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUpdateManyWithoutEmpleadoInput
    pago?: pagoUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUpdateManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedUpdateWithoutEmpresaInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    escoge?: escogeUncheckedUpdateManyWithoutEmpleadoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutEmpleadoInput
    pago?: pagoUncheckedUpdateManyWithoutEmpleadoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutEmpleadoInput
    selecciona?: seleccionaUncheckedUpdateManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedUpdateManyWithoutEmpleadoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
  }

  export type proyectoUpdateWithoutEmpresaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficios?: beneficiosUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUpdateManyWithoutProyectoInput
    genera?: generaUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUpdateManyWithoutProyectoInput
  }

  export type proyectoUncheckedUpdateWithoutEmpresaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficios?: beneficiosUncheckedUpdateManyWithoutProyectoInput
    deduccionVoluntaria?: deduccionVoluntariaUncheckedUpdateManyWithoutProyectoInput
    esContratado?: esContratadoUncheckedUpdateManyWithoutProyectoInput
    genera?: generaUncheckedUpdateManyWithoutProyectoInput
    reporteHoras?: reporteHorasUncheckedUpdateManyWithoutProyectoInput
  }

  export type proyectoUncheckedUpdateManyWithoutProyectoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cantidadMaximaBeneficios?: NullableIntFieldUpdateOperationsInput | number | null
    montoMaximoBeneficio?: NullableIntFieldUpdateOperationsInput | number | null
    frecuenciaPago?: NullableStringFieldUpdateOperationsInput | string | null
    moneda?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaUltimoPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type aplica_bCreateManyPagoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreBeneficio: string
  }

  export type aplica_doCreateManyPagoInput = {
    nombreDO: string
  }

  export type aplica_dvCreateManyPagoInput = {
    cedulaJuridica: string
    nombreProyecto: string
    nombreDeduccion: string
  }

  export type generaCreateManyPagoInput = {
    cedulaJuridica: string
    nombreProyecto: string
  }

  export type aplica_bUpdateWithoutPagoInput = {
    beneficios?: beneficiosUpdateOneRequiredWithoutAplica_bInput
  }

  export type aplica_bUncheckedUpdateWithoutPagoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
  }

  export type aplica_doUpdateWithoutPagoInput = {
    deduccionObligatoria?: deduccionObligatoriaUpdateOneRequiredWithoutAplica_doInput
  }

  export type aplica_doUncheckedUpdateWithoutPagoInput = {
    nombreDO?: StringFieldUpdateOperationsInput | string
  }

  export type aplica_dvUpdateWithoutPagoInput = {
    deduccionVoluntaria?: deduccionVoluntariaUpdateOneRequiredWithoutAplica_dvInput
  }

  export type aplica_dvUncheckedUpdateWithoutPagoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
  }

  export type generaUpdateWithoutPagoInput = {
    proyecto?: proyectoUpdateOneRequiredWithoutGeneraInput
  }

  export type generaUncheckedUpdateWithoutPagoInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
  }

  export type generaUncheckedUpdateManyWithoutGeneraInput = {
    cedulaJuridica?: StringFieldUpdateOperationsInput | string
    nombreProyecto?: StringFieldUpdateOperationsInput | string
  }

  export type hace_usoCreateManyPersonaInput = {
    email: string
  }

  export type hace_usoUpdateWithoutPersonaInput = {
    credenciales?: credencialesUpdateOneRequiredWithoutHace_usoInput
  }

  export type hace_usoUncheckedUpdateWithoutPersonaInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type beneficiosCreateManyProyectoInput = {
    nombreBeneficio: string
    montoPago?: number | null
    descripcion?: string | null
    habilitado?: boolean | null
  }

  export type deduccionVoluntariaCreateManyProyectoInput = {
    nombreDeduccion: string
    descripcion?: string | null
    monto?: number | null
    habilitado?: boolean | null
  }

  export type esContratadoCreateManyProyectoInput = {
    cedulaEmpleado: string
    tipoEmpleado?: string | null
    puesto?: string | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    jornada?: string | null
    salario?: number | null
  }

  export type generaCreateManyProyectoInput = {
    cedulaEmpleado: string
    fechaHora: Date | string
  }

  export type reporteHorasCreateManyProyectoInput = {
    cedulaEmpleado: string
    cedulaEmpleador?: string | null
    fechaHora: Date | string
    horasTrabajadas?: number | null
    estado?: number | null
  }

  export type beneficiosUpdateWithoutProyectoInput = {
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aplica_b?: aplica_bUpdateManyWithoutBeneficiosInput
    selecciona?: seleccionaUpdateManyWithoutBeneficiosInput
  }

  export type beneficiosUncheckedUpdateWithoutProyectoInput = {
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aplica_b?: aplica_bUncheckedUpdateManyWithoutBeneficiosInput
    selecciona?: seleccionaUncheckedUpdateManyWithoutBeneficiosInput
  }

  export type beneficiosUncheckedUpdateManyWithoutBeneficiosInput = {
    nombreBeneficio?: StringFieldUpdateOperationsInput | string
    montoPago?: NullableFloatFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type deduccionVoluntariaUpdateWithoutProyectoInput = {
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aplica_dv?: aplica_dvUpdateManyWithoutDeduccionVoluntariaInput
    escoge?: escogeUpdateManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUncheckedUpdateWithoutProyectoInput = {
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    aplica_dv?: aplica_dvUncheckedUpdateManyWithoutDeduccionVoluntariaInput
    escoge?: escogeUncheckedUpdateManyWithoutDeduccionVoluntariaInput
  }

  export type deduccionVoluntariaUncheckedUpdateManyWithoutDeduccionVoluntariaInput = {
    nombreDeduccion?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    habilitado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type esContratadoUpdateWithoutProyectoInput = {
    tipoEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jornada?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    empleado?: empleadoUpdateOneRequiredWithoutEsContratadoInput
  }

  export type esContratadoUncheckedUpdateWithoutProyectoInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    tipoEmpleado?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jornada?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type generaUpdateWithoutProyectoInput = {
    pago?: pagoUpdateOneRequiredWithoutGeneraInput
  }

  export type generaUncheckedUpdateWithoutProyectoInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reporteHorasUpdateWithoutProyectoInput = {
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empleado?: empleadoUpdateOneRequiredWithoutReporteHorasInput
    empleador?: empleadorUpdateOneWithoutReporteHorasInput
  }

  export type reporteHorasUncheckedUpdateWithoutProyectoInput = {
    cedulaEmpleado?: StringFieldUpdateOperationsInput | string
    cedulaEmpleador?: NullableStringFieldUpdateOperationsInput | string | null
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    horasTrabajadas?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}